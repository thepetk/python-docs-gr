# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-10 10:19+0300\n"
"PO-Revision-Date: 2025-05-03 00:13+0300\n"
"Last-Translator: Theofanis Petkos <thepetk@gmail.com>\n"
"Language-Team: PyGreece <organizers@pygreece.org>\n"
"Language: el\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.5\n"

#: library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Τύποι Built-in"

#: library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"Οι παρακάτω κατηγορίες περιγράφουν τους standard τύπους που είναι "
"ενσωματωμένοι (built) μέσα στον interpreter."

#: library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""
"Οι κύριοι ενσωματωμένοι (built) τύποι είναι αριθμοί, ακολουθίες, "
"αντιστοιχίσεις (mappings), κλάσεις, instances και exceptions."

#: library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never "
"return the collection instance itself but ``None``."
msgstr ""
"Ορισμένες collection κλάσεις είναι μεταβλητές (mutable). Οι μέθοδοι που "
"προσθέτουν, αφαιρούν ή αναδιατάσσουν τα μέλη τους και δεν επιστρέφουν ένα "
"συγκεκριμένο αντικείμενο, ποτέ δεν επιστρέφουν το ίδιο collection instance "
"αλλά ``None``."

#: library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared for equality, tested for truth "
"value, and converted to a string (with the :func:`repr` function or the "
"slightly different :func:`str` function).  The latter function is implicitly "
"used when an object is written by the :func:`print` function."
msgstr ""
"Ορισμένες λειτουργίες υποστηρίζονται από διάφορους τύπους αντικειμένων· "
"ειδικότερα, σχεδόν όλα τα αντικείμενα μπορούν να συγκριθούν ως προς την "
"ισότητα, να ελεγχθούν για την έγκυρη τιμή και να μετατραπούν σε συμβολοσειρά "
"(string) (με τη συνάρτηση :func:`repr` ή την ελαφρώς διαφορετική συνάρτηση :"
"func:`str`). Η τελευταία συνάρτηση χρησιμοποιείται έμμεσα όταν ένα "
"αντικείμενο γράφεται από τη συνάρτηση :func:`print`."

#: library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "Έλεγχος Έγκυρης Τιμής"

#: library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"Οποιοδήποτε αντικείμενο μπορεί να ελεγχθεί ως προς την εγκυρότητα της τιμής "
"του, για χρήση σε :keyword:`if` ή :keyword:`while` συνθήκη ή ως τελεστής των "
"λογικών πράξεων παρακάτω."

#: library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either a :"
"meth:`~object.__bool__` method that returns ``False`` or a :meth:`~object."
"__len__` method that returns zero, when called with the object. [1]_  Here "
"are most of the built-in objects considered false:"
msgstr ""
"Ως προεπιλογή, ένα αντικείμενο θεωρείται true εκτός εάν η κλάση του ορίζει "
"μία :meth:`~object.__bool__` μέθοδο που επιστρέφει ``False`` ή μία :meth:"
"`~object.__len__` μέθοδο που επιστρέφει μηδέν, όταν καλείται με το "
"αντικείμενο. [1]_ Εδώ τα περισσότερα από τα ενσωματωμένα (built-in) "
"αντικείμενα θεωρούνται false:"

#: library/stdtypes.rst:56
msgid "constants defined to be false: ``None`` and ``False``"
msgstr "σταθερές που έχουν οριστεί ως false: ``None`` και ``False``"

#: library/stdtypes.rst:58
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"μηδέν οποιουδήποτε αριθμητικού τύπου: ``0``, ``0,0``, ``0j``, "
"``Decimanl(0)``, ``Fraction(0, 1)``"

#: library/stdtypes.rst:61
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"
msgstr ""
"κενές ακολουθίες και collections: ``''``, ``()``, ``[]``, ``{}``, ``set()``, "
"``range(0)``"

#: library/stdtypes.rst:70
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Οι πράξεις και οι ενσωματωμένες (built-in) συναρτήσεις που έχουν αποτέλεσμα "
"Boolean πάντα επιστρέφουν ``0`` ή ``False`` για false και ``1`` ή ``True`` "
"για true, εκτός εάν δηλώνεται διαφορετικά. (Σημαντική εξαίρεση: οι λογικές "
"(Boolean) πράξεις ``or`` και ``and`` επιστρέφουν πάντα έναν από τους "
"τελεστές τους.)"

#: library/stdtypes.rst:79
msgid "Boolean Operations --- :keyword:`!and`, :keyword:`!or`, :keyword:`!not`"
msgstr ""
"Λογικές (Boolean) Πράξεις ---  :keyword:`!and`, :keyword:`!or`, :keyword:`!"
"not`"

#: library/stdtypes.rst:83
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr ""
"Αυτές είναι οι λογικές (Boolean) πράξεις, ταξινομημένες βάσει προτεραιότητας:"

#: library/stdtypes.rst:144 library/stdtypes.rst:372 library/stdtypes.rst:1007
#: library/stdtypes.rst:1212
msgid "Operation"
msgstr "Πράξη"

#: library/stdtypes.rst:282 library/stdtypes.rst:422 library/stdtypes.rst:1212
msgid "Result"
msgstr "Αποτέλεσμα"

#: library/stdtypes.rst:282 library/stdtypes.rst:1007 library/stdtypes.rst:2714
#: library/stdtypes.rst:3973
msgid "Notes"
msgstr "Σημειώσεις"

#: library/stdtypes.rst:88
msgid "``x or y``"
msgstr "``x or y``"

#: library/stdtypes.rst:88
msgid "if *x* is true, then *x*, else *y*"
msgstr "αν το *x* είναι true, τότε *x*, αλλιώς *y*"

#: library/stdtypes.rst:1009 library/stdtypes.rst:1223
#: library/stdtypes.rst:3979
msgid "\\(1)"
msgstr "\\(1)"

#: library/stdtypes.rst:91
msgid "``x and y``"
msgstr "``x and y``"

#: library/stdtypes.rst:91
msgid "if *x* is false, then *x*, else *y*"
msgstr "αν το *x* είναι false, τότε *x*, αλλιώς *y*"

#: library/stdtypes.rst:295 library/stdtypes.rst:1251 library/stdtypes.rst:2726
#: library/stdtypes.rst:3985
msgid "\\(2)"
msgstr "\\(2)"

#: library/stdtypes.rst:94
msgid "``not x``"
msgstr "``not x``"

#: library/stdtypes.rst:94
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "if *x* είναι false, τότε ``True``, αλλιώς ``False``"

#: library/stdtypes.rst:1021 library/stdtypes.rst:2728
#: library/stdtypes.rst:2732 library/stdtypes.rst:3987
#: library/stdtypes.rst:3991 library/stdtypes.rst:3993
msgid "\\(3)"
msgstr "\\(3)"

#: library/stdtypes.rst:326 library/stdtypes.rst:1058 library/stdtypes.rst:2760
#: library/stdtypes.rst:4023
msgid "Notes:"
msgstr "Σημειώσεις:"

#: library/stdtypes.rst:106
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Αυτός είναι ένας τελεστής μικρού κυκλώματος, επομένως αξιολογεί μόνο το "
"δεύτερο όρισμα αν το πρώτο είναι false."

#: library/stdtypes.rst:110
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Αυτός είναι ένας τελεστής μικρού κυκλώματος, επομένως αξιολογεί μόνο το "
"δεύτερο όρισμα αν το πρώτο είναι true."

#: library/stdtypes.rst:114
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"To ``not`` έχει χαμηλότερη προτεραιότητα από τους μη λογικούς (non-Boolean) "
"τελεστές, οπότε το ``not a == b`` μεταφράζεται σαν ``not (a==b)``, και το "
"``a == not b`` είναι συντακτικό σφάλμα."

#: library/stdtypes.rst:121
msgid "Comparisons"
msgstr "Συγκρίσεις"

#: library/stdtypes.rst:135
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""
"Υπάρχουν οκτώ πράξεις σύγκρισης στην Python. Όλες έχουν την ίδια "
"προτεραιότητα (η οποία είναι υψηλότερη από αυτή των λογικών (Boolean) "
"πράξεων). Οι συγκρίσεις μπορεί να αλυσοδεθούν αυθαίρετα· για παράδειγμα, το "
"``x < y <= z`` ισοδυναμεί με ``x < y και y <= z``, εκτός από το ότι το *y* "
"αξιολογείται μόνο μία φορά (αλλά και στις δύο περιπτώσεις το *z* δεν "
"αξιολογείται καθόλου όταν το ``x < y`` είναι false)."

#: library/stdtypes.rst:141
msgid "This table summarizes the comparison operations:"
msgstr "Αυτός ο πίνακας συνοψίζει τις πράξεις σύγκρισης:"

#: library/stdtypes.rst:2546 library/stdtypes.rst:2714
#: library/stdtypes.rst:3973
msgid "Meaning"
msgstr "Έννοια"

#: library/stdtypes.rst:146
msgid "``<``"
msgstr "``<``"

#: library/stdtypes.rst:146
msgid "strictly less than"
msgstr "αυστηρά μικρότερο από"

#: library/stdtypes.rst:148
msgid "``<=``"
msgstr "``<=``"

#: library/stdtypes.rst:148
msgid "less than or equal"
msgstr "μικρότερο από ή ίσο"

#: library/stdtypes.rst:150
msgid "``>``"
msgstr "``>``"

#: library/stdtypes.rst:150
msgid "strictly greater than"
msgstr "αυστηρά μεγαλύτερο από"

#: library/stdtypes.rst:152
msgid "``>=``"
msgstr "``>=``"

#: library/stdtypes.rst:152
msgid "greater than or equal"
msgstr "μεγαλύτερο από ή ίσο"

#: library/stdtypes.rst:154
msgid "``==``"
msgstr "``==``"

#: library/stdtypes.rst:154
msgid "equal"
msgstr "ίσο"

#: library/stdtypes.rst:156
msgid "``!=``"
msgstr "``!=``"

#: library/stdtypes.rst:156
msgid "not equal"
msgstr "διάφορο"

#: library/stdtypes.rst:158
msgid "``is``"
msgstr "``is``"

#: library/stdtypes.rst:158
msgid "object identity"
msgstr "ταυτότητα αντικειμένου"

#: library/stdtypes.rst:160
msgid "``is not``"
msgstr "``is not``"

#: library/stdtypes.rst:160
msgid "negated object identity"
msgstr "αρνητική ταυτότητα αντικειμένου"

#: library/stdtypes.rst:167
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. The ``==`` operator is always defined but for some object types (for "
"example, class objects) is equivalent to :keyword:`is`. The ``<``, ``<=``, "
"``>`` and ``>=`` operators are only defined where they make sense; for "
"example, they raise a :exc:`TypeError` exception when one of the arguments "
"is a complex number."
msgstr ""
"Αντικείμενα διαφορετικών τύπων, εκτός από διαφορετικούς αριθμητικούς τύπους, "
"δεν συγκρίνονται ποτέ ως ίσα. Ο τελεστής ``==`` ορίζεται πάντα αλλά για "
"ορισμένους τύπους αντικειμένων (για παράδειγμα, αντικείμενα κλάσης) "
"ισοδυναμεί με :keyword:`is`. Οι τελεστές ``<``, ``<=``, ``>`` και ``>=`` "
"ορίζονται μόνο όπου έχουν νόημα· για παράδειγμα, δημιουργούν μια εξαίρεση :"
"exc:`TypeError` όταν ένα από τα ορίσματα είναι μιγαδικός αριθμός."

#: library/stdtypes.rst:181
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`~object.__eq__` method."
msgstr ""
"Μη πανομοιότυπα instances μιας κλάσης συνήθως συγκρίνονται ως μη ίσα εκτός "
"εάν το η κλάση ορίζει τη μέθοδο :meth:`~object.__eq__`."

#: library/stdtypes.rst:184
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`~object.__lt__`, :meth:`~object.__le__`, :meth:`~object."
"__gt__`, and :meth:`~object.__ge__` (in general, :meth:`~object.__lt__` and :"
"meth:`~object.__eq__` are sufficient, if you want the conventional meanings "
"of the comparison operators)."
msgstr ""
"Τα instances μιας κλάσης δεν μπορούν να ταξινομηθούν σε σχέση με άλλα "
"instances της ίδιας κλάσης, ή άλλους τύπους του αντικειμένου, εκτός εάν η "
"κλάση ορίζει αρκετές από τις μεθόδους :meth:`~object.__lt__`, :meth:`~object."
"__le__`, :meth:`~object.__gt__`, και :meth:`~object.__ge__` (γενικά, :meth:"
"`~object.__lt__` και :meth:`~object.__eq__` είναι αρκετά, αν θέλετε τις "
"συμβατικές έννοιες των τελεστών σύγκρισης)."

#: library/stdtypes.rst:191
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""
"Η συμπεριφορά των τελεστών :keyword:`is` και :keyword:`is not` δεν μπορεί να "
"είναι προσαρμοσμένη· επίσης, μπορούν να εφαρμοστούν σε οποιαδήποτε δύο "
"αντικείμενα και ποτέ να μην δημιουργήσουν μία εξαίρεση."

#: library/stdtypes.rst:199
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported by types that are :term:`iterable` or "
"implement the :meth:`~object.__contains__` method."
msgstr ""
"Δύο ακόμη πράξεις με την ίδια συντακτική προτεραιότητα, :keyword:`in` και :"
"keyword:`not in`, υποστηρίζονται από τύπους που είναι :term:`Iterable` ή "
"υλοποιούν τη μέθοδο :meth:`~object.__contains__`."

#: library/stdtypes.rst:206
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "Αριμθητικοί Τύποι --- :class:`int`, :class:`float`, :class:`complex`"

#: library/stdtypes.rst:216
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating-"
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating-point "
"numbers are usually implemented using :c:expr:`double` in C; information "
"about the precision and internal representation of floating-point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating-point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes the additional "
"numeric types :mod:`fractions.Fraction`, for rationals, and :mod:`decimal."
"Decimal`, for floating-point numbers with user-definable precision.)"
msgstr ""
"Υπάρχουν τρεις διαφορετικοί αριθμητικοί τύποι: :dfn:`integers`, :dfn:"
"`floating point numbers` και :dfn:`complex numbers`. Επιπλέον, τα Booleans "
"είναι υπό-τύπος ακεραίων (integers). Οι ακέραιοι αριθμοί έχουν απεριόριστη "
"ακρίβεια. Οι Αριθμοί κινητής υποδιαστολής (floating point numbers) συνήθως "
"υλοποιούνται χρησιμοποιώντας το :c:expr:`double` στη C· πληροφορίες σχετικά "
"με την ακρίβεια και την εσωτερική αναπαράσταση αριθμών κινητής υποδιαστολής "
"για το μηχάνημα στο οποίο εκτελείται το πρόγραμμά σας είναι διαθέσιμο στο :"
"data:`sys.float_info`. Οι μιγαδικοί αριθμοί (complex numbers) έχουν ένα "
"πραγματικό και φανταστικό μέρος, κάθε ένα από τα οποία ένας αριθμός κινητής "
"υποδιαστολής. Για να εξαγάγετε αυτά τα μέρη από έναν μιγαδικό αριθμό *z*, "
"χρησιμοποιήστε ``z.real`` και ``z.imag``. (Η standard βιβλιοθήκη "
"περιλαμβάνει τους πρόσθετους αριθμητικούς τύπους :mod:`fractions.Fraction`, "
"για ορθολογικούς, και :mod:`decimal.Decimal`, για αριθμούς κινητής "
"υποδιαστολής με ακρίβεια που ορίζει ο χρήστης.)"

#: library/stdtypes.rst:238
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating-point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""
"Οι αριθμοί δημιουργούνται με αριθμητικά γράμματα ή ως αποτέλεσμα "
"ενσωματωμένων (built-in) συναρτήσεων και τελεστών. Ακέραιοι αριθμοί "
"(συμπεριλαμβανομένων του εξαδικού, του οκταδικού και των δυαδικοί αριθμών) "
"αποδίδουν ακέραιους αριθμούς. Αριθμητικά που περιέχουν δεκαδικό  ή εκθέτη "
"παράγουν αριθμούς κινητής υποδιαστολής. Η προσάρτηση του ``'j'`` ή του "
"``'J'`` σε ένα αριθμητικό παράγει έναν φανταστικό αριθμό (έναν μιγαδικό "
"αριθμό με μηδενικό πραγματικό μέρος) το οποίο μπορείτε να προσθέσετε σε έναν "
"ακέραιο ή κινητής υποδιαστολής για να πάρετε έναν μιγαδικό αριθμό με "
"πραγματικό και φανταστικό μέρος."

#: library/stdtypes.rst:246
msgid ""
"The constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr ""
"Μπορούν να χρησιμοποιηθούν οι κατασκευαστές :func:`int`, :func:`float` και :"
"func:`complex` για να παράγουν αριθμούς συγκεκριμένου τύπου."

#: library/stdtypes.rst:266
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point. Arithmetic with complex and real operands is defined by the "
"usual mathematical formula, for example::"
msgstr ""
"Η Python υποστηρίζει πλήρως τα μικτά αριθμητικά: όταν ένας δυαδικός "
"αριθμητικός τελεστής έχει τελεστές διαφορετικών αριθμητικών τύπων, ο "
"τελεστής με το \"στενότερο\" τύπο διευρύνεται σε αυτόν του άλλου, όπου ένας "
"ακέραιος αριθμός είναι στενότερος από έναν με κινητή υποδιαστολή. Η "
"αριθμητική με μιγαδικούς και πραγματικούς τελεστές ορίζεται από τον συνήθη "
"μαθηματικό τύπο, για παράδειγμα::"

#: library/stdtypes.rst:272
msgid ""
"x + complex(u, v) = complex(x + u, v)\n"
"x * complex(u, v) = complex(x * u, x * v)"
msgstr ""
"x + complex(u, v) = complex(x + u, v)\n"
"x * complex(u, v) = complex(x * u, x * v)"

#: library/stdtypes.rst:275
msgid ""
"A comparison between numbers of different types behaves as though the exact "
"values of those numbers were being compared. [2]_"
msgstr ""
"Μια σύγκριση μεταξύ αριθμών διαφορετικών τύπων συμπεριφέρεται σαν να "
"συγκρίνονται οι ακριβείς τιμές αυτών των αριθμών. [2]_"

#: library/stdtypes.rst:278
msgid ""
"All numeric types (except complex) support the following operations (for "
"priorities of the operations, see :ref:`operator-summary`):"
msgstr ""
"Όλοι οι αριθμητικοί τύποι (εκτός των μιγαδικών) υποστηρίζουν τις ακόλουθες "
"πράξεις (για προτεραιότητες των πράξεων, βλέπε :ref:`operator-summary`):"

#: library/stdtypes.rst:282
msgid "Full documentation"
msgstr "Ολόκληρη τεκμηρίωση"

#: library/stdtypes.rst:284
msgid "``x + y``"
msgstr "``x + y``"

#: library/stdtypes.rst:284
msgid "sum of *x* and *y*"
msgstr "άθροισμα του *x* και *y*"

#: library/stdtypes.rst:286
msgid "``x - y``"
msgstr "``x - y``"

#: library/stdtypes.rst:286
msgid "difference of *x* and *y*"
msgstr "διαφορά του *x* και *y*"

#: library/stdtypes.rst:288
msgid "``x * y``"
msgstr "``x * y``"

#: library/stdtypes.rst:288
msgid "product of *x* and *y*"
msgstr "γινόμενο των *x* και *y*"

#: library/stdtypes.rst:290
msgid "``x / y``"
msgstr "``x / y``"

#: library/stdtypes.rst:290
msgid "quotient of *x* and *y*"
msgstr "πηλίκο των *x* και *y*"

#: library/stdtypes.rst:292
msgid "``x // y``"
msgstr "``x // y``"

#: library/stdtypes.rst:292
msgid "floored quotient of *x* and *y*"
msgstr "ακέραιο μέρος του πηλίκου των *x* και *y*"

#: library/stdtypes.rst:292
msgid "\\(1)\\(2)"
msgstr "\\(1)\\(2)"

#: library/stdtypes.rst:295
msgid "``x % y``"
msgstr "``x % y``"

#: library/stdtypes.rst:295
msgid "remainder of ``x / y``"
msgstr "υπόλοιπο του ``x / y``"

#: library/stdtypes.rst:297
msgid "``-x``"
msgstr "``-x``"

#: library/stdtypes.rst:297
msgid "*x* negated"
msgstr "*x* αρνητικό"

#: library/stdtypes.rst:299
msgid "``+x``"
msgstr "``+x``"

#: library/stdtypes.rst:299
msgid "*x* unchanged"
msgstr "*x* αμετάβλητο"

#: library/stdtypes.rst:301
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: library/stdtypes.rst:301
msgid "absolute value or magnitude of *x*"
msgstr "απόλυτη τιμή ή μέγεθος του *x*"

#: library/stdtypes.rst:301
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: library/stdtypes.rst:304
msgid "``int(x)``"
msgstr "``int(x)``"

#: library/stdtypes.rst:304
msgid "*x* converted to integer"
msgstr "μετατροπή του *x* σε ακέραιο"

#: library/stdtypes.rst:304
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: library/stdtypes.rst:304
msgid ":func:`int`"
msgstr ":func:`int`"

#: library/stdtypes.rst:306
msgid "``float(x)``"
msgstr "``float(x)``"

#: library/stdtypes.rst:306
msgid "*x* converted to floating point"
msgstr "μετατροπή του *x* σε κινητής υποδιαστολής"

#: library/stdtypes.rst:306
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: library/stdtypes.rst:306
msgid ":func:`float`"
msgstr ":func:`float`"

#: library/stdtypes.rst:308
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: library/stdtypes.rst:308
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"ένας μιγαδικός αριθμός με πραγματικό μέρος *re*, φανταστικό μέρος *im*. Το "
"*im* μετατρέπεται αυτόματα σε μηδέν."

#: library/stdtypes.rst:1244 library/stdtypes.rst:4010
msgid "\\(6)"
msgstr "\\(6)"

#: library/stdtypes.rst:308
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: library/stdtypes.rst:312
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: library/stdtypes.rst:312
msgid "conjugate of the complex number *c*"
msgstr "συζυγές του μιγαδικού αριθμού *c*"

#: library/stdtypes.rst:315
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: library/stdtypes.rst:315
msgid "the pair ``(x // y, x % y)``"
msgstr "το ζευγάρι ``(x // y, x % y)``"

#: library/stdtypes.rst:315
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: library/stdtypes.rst:317
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: library/stdtypes.rst:319
msgid "*x* to the power *y*"
msgstr "*x* σε δύναμη του *y*"

#: library/stdtypes.rst:319 library/stdtypes.rst:1236 library/stdtypes.rst:2750
#: library/stdtypes.rst:4006 library/stdtypes.rst:4013
msgid "\\(5)"
msgstr "\\(5)"

#: library/stdtypes.rst:317
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: library/stdtypes.rst:319
msgid "``x ** y``"
msgstr "``x ** y``"

#: library/stdtypes.rst:329
msgid ""
"Also referred to as integer division.  For operands of type :class:`int`, "
"the result has type :class:`int`.  For operands of type :class:`float`, the "
"result has type :class:`float`.  In general, the result is a whole integer, "
"though the result's type is not necessarily :class:`int`.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"Αναφέρεται επίσης ως διαίρεση ακέραιου αριθμού. Για τελεστές τύπου :class:"
"`int`, το αποτέλεσμα έχει τύπο :class:`int`. Για τελεστές τύπου :class:"
"`float`, το αποτέλεσμα έχει τύπο :class:`float`. Γενικά, το αποτέλεσμα είναι "
"ένας ολόκληρος ακέραιος αριθμός, αν και ο τύπος του αποτελέσματος δεν είναι "
"απαραίτητα :class:`int`. Το αποτέλεσμα είναι πάντα στρογγυλεμένο προς το "
"μείον άπειρο: ``1//2`` είναι ``0``, ``(-1)//2`` είναι ``-1``, ``1//(-2)`` "
"είναι ``-1``, και ``(-1)//(-2)`` είναι ``0``."

#: library/stdtypes.rst:337
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""
"Όχι για μιγαδικούς αριθμούς. Αντίθετα μετατρέψτε σε float χρησιμοποιώντας :"
"func:`abs` εάν είναι εφαρμόσιμο."

#: library/stdtypes.rst:348
msgid ""
"Conversion from :class:`float` to :class:`int` truncates, discarding the "
"fractional part. See functions :func:`math.floor` and :func:`math.ceil` for "
"alternative conversions."
msgstr ""
"Η μετατροπή από :class:`float` σε :class:`int` περικόπτει, απορρίπτοντας το "
"κλασματικό μέρος. Δείτε τις συναρτήσεις :func:`math.floor` και :func:`math."
"ceil` για εναλλακτικές μετατροπές."

#: library/stdtypes.rst:353
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"το float δέχεται επίσης τις συμβολοσειρές (strings) \"nan\" και \"inf\" με "
"ένα προαιρετικό πρόθεμα \"+\" ή \"-\" για το Not a Number (NaN - Όχι "
"αριθμός) και θετικό ή αρνητικό άπειρο."

#: library/stdtypes.rst:357
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Η Python ορίζει το ``pow(0, 0)`` και το ``0 ** 0`` ως ``1``, όπως "
"συνηθίζεται για τις γλώσσες προγραμματισμού."

#: library/stdtypes.rst:361
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"Τα αριθμητικά κυριολεκτικά (numeric literals) που γίνονται δεκτά "
"περιλαμβάνουν τα ψηφία ``0`` έως ``9`` ή οποιοδήποτε ισοδύναμο Unicode "
"(σημεία κώδικα με την ιδιότητα ``Nd``)."

#: library/stdtypes.rst:364
msgid ""
"See `the Unicode Standard <https://unicode.org/Public/UNIDATA/extracted/"
"DerivedNumericType.txt>`_ for a complete list of code points with the ``Nd`` "
"property."
msgstr ""
"Δείτε το `Thε Unicode Standard <https://unicode.org/Public/UNIDATA/extracted/"
"DerivedNumericType.txt>`_ για μια πλήρη λίστα σημείων κώδικα με το ``Nd`` "
"property."

#: library/stdtypes.rst:368
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"Όλοι οι τύποι :class:`numbers.Real` (:class:`int` και :class:`float`) επίσης "
"περιλαμβάνουν τις ακόλουθες λειτουργίες:"

#: library/stdtypes.rst:374
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: library/stdtypes.rst:374
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* μετατρέπεται σε :class:`~numbers.Integral`"

#: library/stdtypes.rst:377
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: library/stdtypes.rst:377
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr ""
"*x* στρογγυλοποιημένο σε *n* ψηφία, στρογγυλοποιώντας το μισό σε ζυγό. Εάν "
"το *n* παραλειφθεί, το default του είναι το 0."

#: library/stdtypes.rst:381
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: library/stdtypes.rst:381
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "το μεγαλύτερο :class:`~numbers.Integral` <= *x*"

#: library/stdtypes.rst:384
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: library/stdtypes.rst:384
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "το μικρότερο :class:`~numbers.Integral` >= *x*"

#: library/stdtypes.rst:388
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""
"Για περαιτέρω αριθμητικές πράξεις δείτε τα modules :mod:`math` και :mod:"
"`cmath`."

#: library/stdtypes.rst:397
msgid "Bitwise Operations on Integer Types"
msgstr "Bitwise Πράξεις σε Ακέραιους Τύπους"

#: library/stdtypes.rst:411
msgid ""
"Bitwise operations only make sense for integers. The result of bitwise "
"operations is calculated as though carried out in two's complement with an "
"infinite number of sign bits."
msgstr ""
"Οι πράξεις bitwise έχουν νόημα μόνο για ακέραιους αριθμούς. Το αποτέλεσμα "
"των bitwise πράξεων υπολογίζεται σαν να εκτελείται σε συμπλήρωμα ως προς δύο "
"με άπειρο αριθμό bits πρόσημου."

#: library/stdtypes.rst:415
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""
"Οι προτεραιότητες των δυαδικών πράξεων bitwise είναι όλες χαμηλότερες από "
"τις αριθμητικές πράξεις και υψηλότερες από τις συγκρίσεις· η μοναδιαία πράξη "
"``~`` έχει την ίδια προτεραιότητα με τις άλλες μοναδιαίες αριθμητικές "
"πράξεις (``+`` και ``-``)."

#: library/stdtypes.rst:419
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"Αυτός ο πίνακας παραθέτει όλες τις bitwise πράξεις ταξινομημένες σε αύξουσα "
"σειρά:"

#: library/stdtypes.rst:424
msgid "``x | y``"
msgstr "``x | y``"

#: library/stdtypes.rst:424
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "bitwise :dfn:`or` των *x* και *y*"

#: library/stdtypes.rst:427 library/stdtypes.rst:1258 library/stdtypes.rst:2740
#: library/stdtypes.rst:3999
msgid "\\(4)"
msgstr "\\(4)"

#: library/stdtypes.rst:427
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: library/stdtypes.rst:427
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "bitwise :dfn:`exclusive or` των *x* και *y*"

#: library/stdtypes.rst:430
msgid "``x & y``"
msgstr "``x & y``"

#: library/stdtypes.rst:430
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "bitwise :dfn:`and` των *x* και *y*"

#: library/stdtypes.rst:433
msgid "``x << n``"
msgstr "``x << n``"

#: library/stdtypes.rst:433
msgid "*x* shifted left by *n* bits"
msgstr "*x* ολισθημένο (shifted) αριστερά κατά *n* bits"

#: library/stdtypes.rst:433
msgid "(1)(2)"
msgstr "(1)(2)"

#: library/stdtypes.rst:435
msgid "``x >> n``"
msgstr "``x >> n``"

#: library/stdtypes.rst:435
msgid "*x* shifted right by *n* bits"
msgstr "*x* ολισθημένο (shifted) δεξιά κατά *n* bits"

#: library/stdtypes.rst:435
msgid "(1)(3)"
msgstr "(1)(3)"

#: library/stdtypes.rst:437
msgid "``~x``"
msgstr "``~x``"

#: library/stdtypes.rst:437
msgid "the bits of *x* inverted"
msgstr "τα bits του *x* αντιστραμμένα"

#: library/stdtypes.rst:443
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""
"Οι μετρήσεις αρνητικών ολισθήσεων (negative shift) είναι άκυρες και κάνουν "
"raise :exc:`ValueError`."

#: library/stdtypes.rst:446
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``."
msgstr ""
"Μια αριστερή ολίσθηση (shift) κατά *n* bits ισοδυναμεί με πολλαπλασιασμό με "
"``pow(2, n)``."

#: library/stdtypes.rst:449
msgid ""
"A right shift by *n* bits is equivalent to floor division by ``pow(2, n)``."
msgstr ""
"Μια δεξιά ολίσθηση (shift) κατά *n* bits ισοδυναμεί με διαίρεση πατώματος με "
"``pow(2, n)``."

#: library/stdtypes.rst:452
msgid ""
"Performing these calculations with at least one extra sign extension bit in "
"a finite two's complement representation (a working bit-width of ``1 + max(x."
"bit_length(), y.bit_length())`` or more) is sufficient to get the same "
"result as if there were an infinite number of sign bits."
msgstr ""
"Η εκτέλεση αυτών των υπολογισμών με τουλάχιστον ένα επιπλέον bit επέκτασης "
"πρόσημου σε μια αναπαράσταση ενός πεπερασμένου συμπληρώματος ως προς δύο "
"(ένα ωφέλιμο bit-width ``1 + max(x.bit_length(), y.bit_length())`` ή "
"περισσότερο) είναι αρκετό για να πάρει το ίδιο αποτέλεσμα σαν να υπήρχε ένας "
"άπειρος αριθμός bits πρόσημου."

#: library/stdtypes.rst:459
msgid "Additional Methods on Integer Types"
msgstr "Περαιτέρω Μέθοδοι των Ακέραιων Τύπων"

#: library/stdtypes.rst:461
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides a few more methods:"
msgstr ""
"Ο τύπος int υλοποιεί την :class:`numbers.Integral` :term:`abstract base "
"class`. Επιπλέον, παρέχει μερικές ακόμη μεθόδους:"

#: library/stdtypes.rst:466
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"Επιστρέφει τον αριθμό των bits που είναι απαραίτητος για να αναπαραστήσει "
"έναν ακέραιο σε δυαδικό, αποκλείοντας το πρόσημο και τα αρχικά μηδέν::"

#: library/stdtypes.rst:469
msgid ""
">>> n = -37\n"
">>> bin(n)\n"
"'-0b100101'\n"
">>> n.bit_length()\n"
"6"
msgstr ""
">>> n = -37\n"
">>> bin(n)\n"
"'-0b100101'\n"
">>> n.bit_length()\n"
"6"

#: library/stdtypes.rst:475
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""
"Πιο συγκεκριμένα, εάν το ``x`` είναι μη μηδενικό, τότε το ``x.bit_length()`` "
"είναι μοναδικός θετικός αριθμός ``k`` έτσι ώστε ``2**(k-1) <= abs(x) < "
"2**k``. Ισοδύναμα, όταν το ``abs(x)`` είναι αρκετά μικρό για να έχει ένα "
"σωστά στρογγυλοποιημένο λογάριθμο, τότε ``k = 1 + int(log(abs(x), 2))``. Εάν "
"το ``x`` είναι μηδέν, τότε το ``x.bit_length()`` επιστρέφει ``0``."

#: library/stdtypes.rst:504 library/stdtypes.rst:593
msgid "Equivalent to::"
msgstr "Ισοδύναμο με::"

#: library/stdtypes.rst:483
msgid ""
"def bit_length(self):\n"
"    s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'\n"
"    s = s.lstrip('-0b') # remove leading zeros and minus sign\n"
"    return len(s)       # len('100101') --> 6"
msgstr ""
"def bit_length(self):\n"
"    s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'\n"
"    s = s.lstrip('-0b') # remove leading zeros and minus sign\n"
"    return len(s)       # len('100101') --> 6"

#: library/stdtypes.rst:492
msgid ""
"Return the number of ones in the binary representation of the absolute value "
"of the integer. This is also known as the population count. Example::"
msgstr ""
"Επιστρέφει τον αριθμό των μονάδων στην δυαδική αναπαράσταση της απόλυτης "
"τιμής του ακεραίου. Αυτό είναι επίσης γνωστό ως το μέτρημα πληθυσμού "
"(population count). Παράδειγμα::"

#: library/stdtypes.rst:496
msgid ""
">>> n = 19\n"
">>> bin(n)\n"
"'0b10011'\n"
">>> n.bit_count()\n"
"3\n"
">>> (-n).bit_count()\n"
"3"
msgstr ""
">>> n = 19\n"
">>> bin(n)\n"
"'0b10011'\n"
">>> n.bit_count()\n"
"3\n"
">>> (-n).bit_count()\n"
"3"

#: library/stdtypes.rst:506
msgid ""
"def bit_count(self):\n"
"    return bin(self).count(\"1\")"
msgstr ""
"def bit_count(self):\n"
"    return bin(self).count(\"1\")"

#: library/stdtypes.rst:513
msgid "Return an array of bytes representing an integer."
msgstr "Επιστρέφει ένα πίνακα από bytes που αναπαριστούν έναν ακέραιο."

#: library/stdtypes.rst:525
msgid ""
"The integer is represented using *length* bytes, and defaults to 1.  An :exc:"
"`OverflowError` is raised if the integer is not representable with the given "
"number of bytes."
msgstr ""
"Ο ακέραιος αναπαρίσταται χρησιμοποιώντας *length* bytes και η προεπιλεγμένη "
"του τιμή (default) είναι 1.  Ένα :exc:`OverflowError` γίνεται raise αν ο "
"ακέραιος αριθμός δεν δύναται να αναπαρασταθεί με τον αριθμό bytes που δόθηκε."

#: library/stdtypes.rst:529
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte array."
msgstr ""
"Το όρισμα *byteorder* καθορίζει τη σειρά των byte που χρησιμοποιούνται για "
"την αναπαράσταση του ακέραιου αριθμού, και έχουν προεπιλεγμένη τιμή "
"(default) ``\"big\"``. Εάν το *byteorder* είναι ``\"big\"``, το πιο "
"σημαντικό byte βρίσκεται στην αρχή του πίνακα των bytes. Εάν το *byteorder* "
"είναι ``\"little\"``, το πιο σημαντικό byte βρίσκεται στο τέλος του πίνακα "
"των bytes."

#: library/stdtypes.rst:535
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""
"Το όρισμα *signed* καθορίζει εάν το συμπλήρωμα ως προς δύο χρησιμοποιείται "
"για να αντιπροσωπεύσει τον ακέραιο. Εάν το *signed* είναι ``False`` και έχει "
"δοθεί ένας αρνητικός ακέραιος, γίνεται raise ένα :exc:`OverflowError`. Η "
"προεπιλεγμένη τιμή (default) για το *signed* είναι ``False``."

#: library/stdtypes.rst:540
msgid ""
"The default values can be used to conveniently turn an integer into a single "
"byte object::"
msgstr ""
"Οι προεπιλεγμένες τιμές (defaults) μπορούν να χρησιμοποιηθούν για να "
"μετατρέψουν βολικά έναν ακέραιο σε ένα μόνο byte αντικείμενο::"

#: library/stdtypes.rst:543
msgid ""
">>> (65).to_bytes()\n"
"b'A'"
msgstr ""
">>> (65).to_bytes()\n"
"b'A'"

#: library/stdtypes.rst:546
msgid ""
"However, when using the default arguments, don't try to convert a value "
"greater than 255 or you'll get an :exc:`OverflowError`."
msgstr ""
"Ωστόσο, όταν χρησιμοποιείτε προεπιλεγμένα ορίσματα, μην προσπαθήσετε να "
"μετατρέψετε μια τιμή μεγαλύτερη από 255 ή διαφορετικά θα λάβετε ένα :exc:"
"`OverflowError`."

#: library/stdtypes.rst:551
msgid ""
"def to_bytes(n, length=1, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        order = range(length)\n"
"    elif byteorder == 'big':\n"
"        order = reversed(range(length))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    return bytes((n >> i*8) & 0xff for i in order)"
msgstr ""
"def to_bytes(n, length=1, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        order = range(length)\n"
"    elif byteorder == 'big':\n"
"        order = reversed(range(length))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    return bytes((n >> i*8) & 0xff for i in order)"

#: library/stdtypes.rst:562
msgid "Added default argument values for ``length`` and ``byteorder``."
msgstr ""
"Προστιθέμενες προεπιλεγμένες τιμές (defaults) ορίσματος για ``length`` και "
"``byteorder``."

#: library/stdtypes.rst:567
msgid "Return the integer represented by the given array of bytes."
msgstr ""
"Επιστρέφει έναν ακέραιο που αναπαρίσταται από τον δοσμένο πίνακα των bytes."

#: library/stdtypes.rst:580
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"Το όρισμα *bytes* πρέπει είτε να είναι ένα :term:`bytes-like object` είτε "
"ένα iterable που παράγει bytes."

#: library/stdtypes.rst:583
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer, and defaults to ``\"big\"``.  If *byteorder* is ``\"big\"``, the "
"most significant byte is at the beginning of the byte array.  If *byteorder* "
"is ``\"little\"``, the most significant byte is at the end of the byte "
"array.  To request the native byte order of the host system, use :data:`sys."
"byteorder` as the byte order value."
msgstr ""
"Το όρισμα *byteorder* καθορίζει τη σειρά byte που χρησιμοποιείται για την "
"αναπαράσταση του ακέραιου αριθμού, και η προεπιλεγμένη τιμή (default) είναι "
"``\"big\"``. Εάν το *byteorder* είναι ``\"big\"``, το το πιο σημαντικό byte "
"βρίσκεται στην αρχή του πίνακα των bytes. Εάν το *byteorder* είναι "
"``\"little\"``, το πιο σημαντικό byte βρίσκεται στο τέλος του πίνακα των "
"bytes. Για να ζητήσετε την εγγενή σειρά των bytes του host συστήματος, "
"χρησιμοποιήστε το :data:`sys.byteorder` ως τιμή της σειράς byte."

#: library/stdtypes.rst:590
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""
"Το όρισμα *signed* υποδεικνύει εάν το συμπλήρωμα ως προς δύο χρησιμοποιείται "
"για να αντιπροσωπεύσει τον ακέραιο."

#: library/stdtypes.rst:595
msgid ""
"def from_bytes(bytes, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        little_ordered = list(bytes)\n"
"    elif byteorder == 'big':\n"
"        little_ordered = list(reversed(bytes))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    n = sum(b << i*8 for i, b in enumerate(little_ordered))\n"
"    if signed and little_ordered and (little_ordered[-1] & 0x80):\n"
"        n -= 1 << 8*len(little_ordered)\n"
"\n"
"    return n"
msgstr ""
"def from_bytes(bytes, byteorder='big', signed=False):\n"
"    if byteorder == 'little':\n"
"        little_ordered = list(bytes)\n"
"    elif byteorder == 'big':\n"
"        little_ordered = list(reversed(bytes))\n"
"    else:\n"
"        raise ValueError(\"byteorder must be either 'little' or 'big'\")\n"
"\n"
"    n = sum(b << i*8 for i, b in enumerate(little_ordered))\n"
"    if signed and little_ordered and (little_ordered[-1] & 0x80):\n"
"        n -= 1 << 8*len(little_ordered)\n"
"\n"
"    return n"

#: library/stdtypes.rst:610
msgid "Added default argument value for ``byteorder``."
msgstr ""
"Προστιθέμενη προεπιλεγμένη τιμή (default) ορίσματος για το ``byteorder``."

#: library/stdtypes.rst:615
msgid ""
"Return a pair of integers whose ratio is equal to the original integer and "
"has a positive denominator.  The integer ratio of integers (whole numbers) "
"is always the integer as the numerator and ``1`` as the denominator."
msgstr ""
"Επιστρέφει ένα ζεύγος ακεραίων των οποίων η αναλογία είναι ίση με τον αρχικό "
"ακέραιο και έχει θετικό παρονομαστή. Ο ακέραιος λόγος ακεραίων (ολόκληρων "
"αριθμών) είναι πάντα ο ακέραιος αριθμός ως αριθμητής και το ``1`` ως "
"παρονομαστής."

#: library/stdtypes.rst:624
msgid ""
"Returns ``True``. Exists for duck type compatibility with :meth:`float."
"is_integer`."
msgstr ""
"Επιστρέφει ``True``. Υπάρχει για συμβατότητα τύπου duck με :meth:`float."
"is_integer`."

#: library/stdtypes.rst:629
msgid "Additional Methods on Float"
msgstr "Περαιτέρω Μέθοδοι για Float"

#: library/stdtypes.rst:631
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"Ο τύπος float (κινητής υποδιαστολής) υλοποιεί την :class:`numbers.Real` :"
"term:`abstract base class`. Ο float έχει επίσης τις ακόλουθες πρόσθετες "
"μεθόδους."

#: library/stdtypes.rst:636
msgid ""
"Class method to return a floating-point number constructed from a number *x*."
msgstr ""
"Μέθοδος κλάσης για την επιστροφή ενός αριθμού κινητής υποδιαστολής που "
"κατασκευάζεται από έναν αριθμό *x*."

#: library/stdtypes.rst:638
msgid ""
"If the argument is an integer or a floating-point number, a floating-point "
"number with the same value (within Python's floating-point precision) is "
"returned.  If the argument is outside the range of a Python float, an :exc:"
"`OverflowError` will be raised."
msgstr ""
"Εάν το όρισμα είναι ακέραιος ή αριθμός κινητής υποδιαστολής, επιστρέφεται "
"ένας αριθμός κινητής υποδιαστολής με την ίδια τιμή (εντός της ακρίβειας "
"κινητής υποδιαστολής της Python). Εάν το όρισμα βρίσκεται εκτός του εύρους "
"ενός Python float, θα κάνει raise μια :exc:`OverflowError`."

#: library/stdtypes.rst:643
msgid ""
"For a general Python object ``x``, ``float.from_number(x)`` delegates to ``x."
"__float__()``. If :meth:`~object.__float__` is not defined then it falls "
"back to :meth:`~object.__index__`."
msgstr ""
"Για ένα γενικό αντικείμενο Python ``x``, ``float.from_number(x)`` ανατίθεται "
"στο ``x.__float__()``. Εάν η :meth:`~object.__float__` δεν έχει οριστεί, "
"τότε επιστρέφει στη :meth:`~object.__index__`."

#: library/stdtypes.rst:653
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"float. The ratio is in lowest terms and has a positive denominator.  Raises :"
"exc:`OverflowError` on infinities and a :exc:`ValueError` on NaNs."
msgstr ""
"Επιστρέφει ένα ζεύγος ακεραίων των οποίων η αναλογία είναι ακριβώς ίση με το "
"αρχικό float. Ο λόγος είναι στο χαμηλότερο επίπεδο και έχει θετικό "
"παρονομαστή. Κάνει raise :exc:`OverflowError` στα άπειρα και ένα :exc:"
"`ValueError` για NaNs."

#: library/stdtypes.rst:660
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Επιστρέφει ``True`` εάν το float instance είναι πεπερασμένο με ακέραια τιμή "
"και ``False`` διαφορετικά::"

#: library/stdtypes.rst:663
msgid ""
">>> (-2.0).is_integer()\n"
"True\n"
">>> (3.2).is_integer()\n"
"False"
msgstr ""
">>> (-2.0).is_integer()\n"
"True\n"
">>> (3.2).is_integer()\n"
"False"

#: library/stdtypes.rst:668
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"Δύο μέθοδοι υποστηρίζουν τη μετατροπή από και προς δεκαεξαδικές "
"συμβολοσειρές (strings). Αφού τα floats της Python αποθηκεύονται εσωτερικά "
"ως δυαδικοί αριθμοί, η μετατροπή ενός float προς ή από μια *δεκαδική* "
"συμβολοσειρά συνήθως περιλαμβάνει ένα μικρό σφάλμα στρογγυλοποίησης. "
"Αντιθέτως, οι δεκαεξαδικές συμβολοσειρές επιτρέπουν ακριβή αναπαράσταση και "
"συγκεκριμενοποίηση των αριθμών κινητής υποδιαστολής. Αυτό μπορεί να είναι "
"χρήσιμο κατά το debugging και στην αριθμητική."

#: library/stdtypes.rst:679
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Επιστρέφει μια αναπαράσταση ενός αριθμού κινητής υποδιαστολής ως δεκαεξαδική "
"συμβολοσειρά (string).  Για πεπερασμένους αριθμούς κινητής υποδιαστολής, "
"αυτή η αναπαράσταση θα περιλαμβάνει πάντα ένα προπορευόμενο ``0x`` και ένα "
"τελευταίο ``p`` και εκθέτη."

#: library/stdtypes.rst:687
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Μέθοδος κλάσης για την επιστροφή του float που αντιπροσωπεύεται από μια "
"δεκαεξαδική συμβολοσειρά (string) *s*.  Η συμβολοσειρά *s* μπορεί να έχει "
"κενό διάστημα που στην αρχή ή το τέλος."

#: library/stdtypes.rst:692
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""
"Σημειώστε ότι το :meth:`float.hex` είναι ένα instance method, ενώ το :meth:"
"`float.fromhex` είναι μια μέθοδος κλάσης."

#: library/stdtypes.rst:695
msgid "A hexadecimal string takes the form::"
msgstr "Μια δεκαεξαδική συμβολοσειρά (string) έχει τη μορφή::"

#: library/stdtypes.rst:697
msgid "[sign] ['0x'] integer ['.' fraction] ['p' exponent]"
msgstr "[sign] ['0x'] integer ['.' fraction] ['p' exponent]"

#: library/stdtypes.rst:699
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""
"όπου το προαιρετικό ``sign`` μπορεί να είναι είτε ``+`` ή ``-``, ``integer`` "
"και ``fraction`` είναι συμβολοσειρές (strings) δεκαεξαδικών ψηφίων και ο "
"``exponent`` (εκθέτης) είναι ένας δεκαδικός ακέραιος με προαιρετικό πρόσημο. "
"Τα πεζά ή κεφαλαία δεν είναι σημαντικά και πρέπει να υπάρχει τουλάχιστον ένα "
"δεκαεξαδικό ψηφίο είτε στον ακέραιο είτε στο κλάσμα. Αυτή η σύνταξη είναι "
"παρόμοια με τη σύνταξη που καθορίζεται στην ενότητα 6.4.4.2 του προτύπου "
"C99, καθώς και στη σύνταξη που χρησιμοποιείται στην Java 1.5 και μετά. "
"Ιδιαίτερα, η έξοδος του :meth:`float.hex` μπορεί να χρησιμοποιηθεί ως "
"δεκαεξαδικό Κυριολεκτική κινητής υποδιαστολής σε κώδικα C ή Java, και "
"παράχθηκαν δεκαεξαδικές συμβολοσειρές με τον χαρακτήρα μορφής ``%a`` της C ή "
"το `Double.toHexString` της Java είναι αποδεκτά από το :meth:`float.fromhex`."

#: library/stdtypes.rst:712
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Σημειώστε ότι ο εκθέτης είναι γραμμένος με δεκαδικό και όχι δεκαεξαδικό και "
"ότι δίνει τη δύναμη του 2 με την οποία πολλαπλασιάζεται ο συντελεστής. Για "
"παράδειγμα, η δεκαεξαδική συμβολοσειρά (string) ``0x3.a7p10`` αντιπροσωπεύει "
"τον αριθμό κινητής υποδιαστολής ``(3 + 10./16 + 7./16**2) * 2,0**10``, ή "
"``3740,0``::"

#: library/stdtypes.rst:718
msgid ""
">>> float.fromhex('0x3.a7p10')\n"
"3740.0"
msgstr ""
">>> float.fromhex('0x3.a7p10')\n"
"3740.0"

#: library/stdtypes.rst:722
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"Η εφαρμογή της αντίστροφης μετατροπής σε ``3740.0`` δίνει μία διαφορετική "
"δεκαεξαδική συμβολοσειρά (string) που αντιπροσωπεύει τον ίδιο αριθμό::"

#: library/stdtypes.rst:725
msgid ""
">>> float.hex(3740.0)\n"
"'0x1.d380000000000p+11'"
msgstr ""
">>> float.hex(3740.0)\n"
"'0x1.d380000000000p+11'"

#: library/stdtypes.rst:730
msgid "Additional Methods on Complex"
msgstr "Περαιτέρω Μέθοδοι για Μιγαδικούς"

#: library/stdtypes.rst:732
msgid ""
"The :class:`!complex` type implements the :class:`numbers.Complex` :term:"
"`abstract base class`. :class:`!complex` also has the following additional "
"methods."
msgstr ""
"Ο τύπος :class:`!complex` υλοποιεί την :class:`numbers.Complex` :term:"
"`abstract base class`. Η :class:`!complex` έχει επίσης τις ακόλουθες "
"πρόσθετε μεθόδους."

#: library/stdtypes.rst:738
msgid "Class method to convert a number to a complex number."
msgstr "Μέθοδος κλάσης για τη μετατροπή ενός αριθμούς σε ένα μιγαδικό αριθμός."

#: library/stdtypes.rst:740
msgid ""
"For a general Python object ``x``, ``complex.from_number(x)`` delegates to "
"``x.__complex__()``.  If :meth:`~object.__complex__` is not defined then it "
"falls back to :meth:`~object.__float__`.  If :meth:`!__float__` is not "
"defined then it falls back to :meth:`~object.__index__`."
msgstr ""
"Για ένα γενικό αντικείμενο Python ``x``, ``complex.from_number(x)`` "
"ανατίθεται στο ``x.__complex__()``. Εάν η :meth:`~object.__complex__` δεν "
"έχει οριστεί, τότε επιστρέφει :meth:`~object.__float__`. Εάν η :meth:`!"
"__float__` δεν έχει οριστεί, τότε επιστρέφει στη :meth:`~object.__index__`."

#: library/stdtypes.rst:751
msgid "Hashing of numeric types"
msgstr "Κατακερματισμός των αριθμητικών τύπων"

#: library/stdtypes.rst:753
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`~object."
"__hash__` method documentation for more details).  For ease of "
"implementation and efficiency across a variety of numeric types (including :"
"class:`int`, :class:`float`, :class:`decimal.Decimal` and :class:`fractions."
"Fraction`) Python's hash for numeric types is based on a single mathematical "
"function that's defined for any rational number, and hence applies to all "
"instances of :class:`int` and :class:`fractions.Fraction`, and all finite "
"instances of :class:`float` and :class:`decimal.Decimal`.  Essentially, this "
"function is given by reduction modulo ``P`` for a fixed prime ``P``.  The "
"value of ``P`` is made available to Python as the :attr:`~sys.hash_info."
"modulus` attribute of :data:`sys.hash_info`."
msgstr ""
"Για αριθμούς ``x`` και ``y``, πιθανώς διαφορετικών τύπων, είναι "
"προαπαιτούμενο ότι ``hash(x) == hash(y)`` όποτε ``x == y`` (δείτε την "
"τεκμηρίωση για την μέθοδο :meth:`~object.__hash__` για περισσότερες "
"λεπτομέρειες). Για την ευκολότερη εφαρμογή και αποτελεσματικότητα σε ένα "
"εύρος αριθμητικών τύπων (συμπεριλαμβανομένων των :class:`int`, :class:"
"`float`, :class:`decimal.Decimal` και :class:`fractions.Fracion`) o "
"κατακερματισμός της Python για αριθμητικούς τύπους βασίζεται σε μία μόνο "
"μαθηματική συνάρτηση που ορίζεται για οποιονδήποτε ρητό αριθμό, και ως εκ "
"τούτου ισχύει για όλα τα instances :class:`int` και :class:`fractions."
"Fraction` και όλα πεπερασμένα instances :class:`float` και :class:`decimal."
"Decimal`. Ουσιαστικά, αυτή η συνάρτηση δίνεται από το modulo μείωσης ``P`` "
"για ένα σταθερό πρώτο ``P``. Η τιμή του ``P`` διατίθεται στην Python ως "
"χαρακτηριστικό :attr:`~sys.hash_info.modulus` του :data:`sys.hash_info`."

#: library/stdtypes.rst:768
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"Αυτή τη στιγμή, ο πρώτος που χρησιμοποιείται είναι ``P = 2**31 - 1`` σε "
"μηχανήματα με μήκους 32-bit C και ``P = 2**61 - 1`` σε μηχανήματα με μήκους "
"64-bit C."

#: library/stdtypes.rst:771
msgid "Here are the rules in detail:"
msgstr "Εδώ οι κανόνες λεπτομερώς:"

#: library/stdtypes.rst:773
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"Αν το ``x = m / n`` είναι ένας μη αρνητικός ρητός αριθμός και το ``n`` δεν "
"διαιρείται από ``P``, ορίστε το ``hash(x)`` ως ``m * invmod(n, P) % P``, "
"όπου το ``invmod(n, P)`` μας δίνει το αντίστροφο του modulo ``n`` ``P``."

#: library/stdtypes.rst:777
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""
"Αν το ``x = m / n`` είναι ένας μη αρνητικός ρητός αριθμός και το ``n`` "
"διαιρείται με το ``P`` (αλλά το ``m`` όχι) τότε το ``n`` δεν έχει αντίστροφο "
"modulo ``P`` και ο κανόνας παραπάνω δεν ισχύει. Σε αυτήν την περίπτωση "
"ορίστε το ``hash(x)`` ως σταθερή τιμή ``sys.hash_info.inf``."

#: library/stdtypes.rst:782
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"Αν ``x = m / n`` είναι ένας αρνητικός ρητός αριθμός τότε το ``hash(x)`` "
"ορίζεται ως ``-hash(-x)``.  Αν το hash που προκύπτει είναι ``-1``, "
"αντικαθίσταται με ``-2``."

#: library/stdtypes.rst:786
msgid ""
"The particular values ``sys.hash_info.inf`` and ``-sys.hash_info.inf`` are "
"used as hash values for positive infinity or negative infinity "
"(respectively)."
msgstr ""
"Οι συγκεκριμένες τιμές των ``sys.hash_info.inf`` και ``-sys.hash_info.inf`` "
"χρησιμοποιούνται ως τιμές κατακερματισμού για το θετικό άπειρο ή το αρνητικό "
"άπειρο (αντίστοιχα)."

#: library/stdtypes.rst:790
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"Για έναν :class:`complex` αριθμό ``z``, οι τιμές κατακερματισμού των "
"πραγματικών και φανταστικών μερών συνδυάζονται με τον υπολογισμό ``hash(z."
"real) + sys.hash_info.imag * hash(z.imag)``, μειωμένο modulo ``2**sys."
"hash_info.width`` έτσι ώστε να βρίσκεται στο ``range(-2**(sys.hash_info."
"width - 1), 2**(sys.hash_info.width - 1))``.  Και πάλι, αν το αποτέλεσμα "
"είναι ``-1``, αντικαθίσταται με ``-2``."

#: library/stdtypes.rst:798
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the built-in hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""
"Για να αποσαφηνίσουμε τους παραπάνω κανόνες, εδώ είναι ένα παράδειγμα κώδικα "
"της Python, ισοδύναμο με το built-in hash, για τον υπολογισμό του hash ενός "
"ρητού αριθμού, :class:`float`, ή :class:`complex`::"

#: library/stdtypes.rst:803
msgid ""
"import sys, math\n"
"\n"
"def hash_fraction(m, n):\n"
"    \"\"\"Compute the hash of a rational number m / n.\n"
"\n"
"    Assumes m and n are integers, with n positive.\n"
"    Equivalent to hash(fractions.Fraction(m, n)).\n"
"\n"
"    \"\"\"\n"
"    P = sys.hash_info.modulus\n"
"    # Remove common factors of P.  (Unnecessary if m and n already "
"coprime.)\n"
"    while m % P == n % P == 0:\n"
"        m, n = m // P, n // P\n"
"\n"
"    if n % P == 0:\n"
"        hash_value = sys.hash_info.inf\n"
"    else:\n"
"        # Fermat's Little Theorem: pow(n, P-1, P) is 1, so\n"
"        # pow(n, P-2, P) gives the inverse of n modulo P.\n"
"        hash_value = (abs(m) % P) * pow(n, P - 2, P) % P\n"
"    if m < 0:\n"
"        hash_value = -hash_value\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value\n"
"\n"
"def hash_float(x):\n"
"    \"\"\"Compute the hash of a float x.\"\"\"\n"
"\n"
"    if math.isnan(x):\n"
"        return object.__hash__(x)\n"
"    elif math.isinf(x):\n"
"        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf\n"
"    else:\n"
"        return hash_fraction(*x.as_integer_ratio())\n"
"\n"
"def hash_complex(z):\n"
"    \"\"\"Compute the hash of a complex number z.\"\"\"\n"
"\n"
"    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z."
"imag)\n"
"    # do a signed reduction modulo 2**sys.hash_info.width\n"
"    M = 2**(sys.hash_info.width - 1)\n"
"    hash_value = (hash_value & (M - 1)) - (hash_value & M)\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value"
msgstr ""
"import sys, math\n"
"\n"
"def hash_fraction(m, n):\n"
"    \"\"\"Compute the hash of a rational number m / n.\n"
"\n"
"    Assumes m and n are integers, with n positive.\n"
"    Equivalent to hash(fractions.Fraction(m, n)).\n"
"\n"
"    \"\"\"\n"
"    P = sys.hash_info.modulus\n"
"    # Remove common factors of P.  (Unnecessary if m and n already "
"coprime.)\n"
"    while m % P == n % P == 0:\n"
"        m, n = m // P, n // P\n"
"\n"
"    if n % P == 0:\n"
"        hash_value = sys.hash_info.inf\n"
"    else:\n"
"        # Fermat's Little Theorem: pow(n, P-1, P) is 1, so\n"
"        # pow(n, P-2, P) gives the inverse of n modulo P.\n"
"        hash_value = (abs(m) % P) * pow(n, P - 2, P) % P\n"
"    if m < 0:\n"
"        hash_value = -hash_value\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value\n"
"\n"
"def hash_float(x):\n"
"    \"\"\"Compute the hash of a float x.\"\"\"\n"
"\n"
"    if math.isnan(x):\n"
"        return object.__hash__(x)\n"
"    elif math.isinf(x):\n"
"        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf\n"
"    else:\n"
"        return hash_fraction(*x.as_integer_ratio())\n"
"\n"
"def hash_complex(z):\n"
"    \"\"\"Compute the hash of a complex number z.\"\"\"\n"
"\n"
"    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z."
"imag)\n"
"    # do a signed reduction modulo 2**sys.hash_info.width\n"
"    M = 2**(sys.hash_info.width - 1)\n"
"    hash_value = (hash_value & (M - 1)) - (hash_value & M)\n"
"    if hash_value == -1:\n"
"        hash_value = -2\n"
"    return hash_value"

#: library/stdtypes.rst:854
msgid "Boolean Type - :class:`bool`"
msgstr "Τύπος Boolean - :class`bool`"

#: library/stdtypes.rst:856
msgid ""
"Booleans represent truth values. The :class:`bool` type has exactly two "
"constant instances: ``True`` and ``False``."
msgstr ""
"Οι λογικές τιμές (Booleans) αντιπροσωπεύουν τιμές αλήθειας. Ο τύπος :class:"
"`bool` έχει ακριβώς δύο σταθερές τιμές: ``True`` και ``False``."

#: library/stdtypes.rst:864
msgid ""
"The built-in function :func:`bool`  converts any value to a boolean, if the "
"value can be interpreted as a truth value (see section :ref:`truth` above)."
msgstr ""
"Η ενσωματωμένη συνάρτηση :func:`bool` μετατρέπει οποιαδήποτε τιμή σε λογική "
"(boolean), αν η τιμή μπορεί να ερμηνευτεί ως τιμή αλήθειας (βλέπε παραπάνω "
"ενότητα :ref:`truth`)."

#: library/stdtypes.rst:867
msgid ""
"For logical operations, use the :ref:`boolean operators <boolean>` ``and``, "
"``or`` and ``not``. When applying the bitwise operators ``&``, ``|``, ``^`` "
"to two booleans, they return a bool equivalent to the logical operations "
"\"and\", \"or\", \"xor\". However, the logical operators ``and``, ``or`` and "
"``!=`` should be preferred over ``&``, ``|`` and ``^``."
msgstr ""
"Για λογικές πράξεις, χρησιμοποιήστε τους τελεστές :ref:`boolean <boolean>` "
"``and``, ``or`` και ``not``. Κατά την εφαρμογή των bitwise τελεστών ``&``, "
"``|``, ``^`` σε δύο booleans, επιστρέφουν ένα bool ισοδύναμο με τις λογικές "
"πράξεις \"and\", \"or\", \"xor\". Ωστόσο, οι λογικοί τελεστές ``and``, "
"``or`` και ``!=`` θα πρέπει να προτιμώνται έναντι των ``&``, ``|`` και ``^``."

#: library/stdtypes.rst:876
msgid ""
"The use of the bitwise inversion operator ``~`` is deprecated and will raise "
"an error in Python 3.16."
msgstr ""
"Η χρήση του bitwise inversion τελεστή ``~`` είναι ξεπερασμένη και κάνει "
"raise ένα σφάλμα στην Python 3.16."

#: library/stdtypes.rst:879
msgid ""
":class:`bool` is a subclass of :class:`int` (see :ref:`typesnumeric`). In "
"many numeric contexts, ``False`` and ``True`` behave like the integers 0 and "
"1, respectively. However, relying on this is discouraged; explicitly convert "
"using :func:`int` instead."
msgstr ""
"Η :class:`bool` είναι υποκλάση της :class:`int` (βλέπε :ref:`typesnumeric`). "
"Σε πολλά αριθμητικά περιβάλλοντα, τα ``False`` και ``True`` συμπεριφέρονται "
"όπως οι ακέραιοι αριθμοί 0 και 1, αντίστοιχα. Ωστόσο, δεν συνιστάται να "
"βασίζεστε σε αυτό· πιο αναλυτικά κάντε μετατροπή χρησιμοποιώντας τη :func:"
"`int` αντ' αυτού."

#: library/stdtypes.rst:887
msgid "Iterator Types"
msgstr "Τύποι Iterator"

#: library/stdtypes.rst:895
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Η Python υποστηρίζει την έννοια της επανάληψης σε containers.  Αυτό "
"υλοποιείται χρησιμοποιώντας δύο διαφορετικές μεθόδους· αυτές "
"χρησιμοποιούνται για να επιτρέψουν σε κλάσεις που ορίζονται από το χρήστη να "
"να υποστηρίζουν την επανάληψη.  Οι ακολουθίες (sequences), που περιγράφονται "
"παρακάτω με περισσότερες λεπτομέρειες, πάντα υποστηρίζουν τις μεθόδους "
"επανάληψης."

#: library/stdtypes.rst:900
msgid ""
"One method needs to be defined for container objects to provide :term:"
"`iterable` support:"
msgstr ""
"Μια μέθοδος πρέπει να οριστεί για τα container αντικείμενα ώστε να παρέχει :"
"term:`iterable` υποστήριξη:"

#: library/stdtypes.rst:907
msgid ""
"Return an :term:`iterator` object.  The object is required to support the "
"iterator protocol described below.  If a container supports different types "
"of iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :c:"
"member:`~PyTypeObject.tp_iter` slot of the type structure for Python objects "
"in the Python/C API."
msgstr ""
"Επιστρέφει ένα αντικείμενο :term:`iterator`.  Το αντικείμενο απαιτείται να "
"υποστηρίζει το πρωτόκολλο επαναλήψεων που περιγράφεται παρακάτω.  Εάν ένας "
"container υποστηρίζει διαφορετικούς τύπους της επανάληψης, μπορούν να "
"παρασχεθούν πρόσθετες μέθοδοι για να ζητηθούν συγκεκριμένοι iterators για "
"αυτούς τους τύπους επανάληψης.  (Ένα παράδειγμα αντικειμένου που υποστηρίζει "
"πολλαπλές μορφές επανάληψης θα ήταν μια δενδρική δομή που υποστηρίζει και "
"αμφότερες τις breadth-first και depth-first μορφές).  Αυτή η μέθοδος "
"αντιστοιχεί στη μέθοδο :c:member:`~PyTypeObject.tp_iter` της δομής τύπου για "
"αντικείμενα Python στο API της Python/C."

#: library/stdtypes.rst:916
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Τα ίδια τα αντικείμενα επαναλήψεων απαιτείται να υποστηρίζουν τις ακόλουθες "
"δύο μεθόδους, οι οποίες από κοινού αποτελούν το :dfn:`iterator protocol`:"

#: library/stdtypes.rst:922
msgid ""
"Return the :term:`iterator` object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements.  This method corresponds to the :c:member:`~PyTypeObject."
"tp_iter` slot of the type structure for Python objects in the Python/C API."
msgstr ""
"Επιστρέφει το ίδιο το αντικείμενο :term:`iterator`.  Αυτό απαιτείται ώστε να "
"επιτραπεί η χρησιμοποίηση τόσο των containers, όσο και των iterators με τα "
"statements :keyword:`for` και :keyword:`in`.  Αυτή η μέθοδος αντιστοιχεί στη "
"δομή :c:member:`~PyTypeObject.tp_iter` των αντικειμένων της Python στο "
"Python/C API."

#: library/stdtypes.rst:931
msgid ""
"Return the next item from the :term:`iterator`.  If there are no further "
"items, raise the :exc:`StopIteration` exception.  This method corresponds to "
"the :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
"Επιστρέφει το επόμενο στοιχείο από τον :term:`iterator`.  Εάν δεν υπάρχουν "
"άλλα στοιχεία, κάνει raise την εξαίρεση :exc:`StopIteration`.  Αυτή η "
"μέθοδος αντιστοιχεί στην δομή :c:member:`~PyTypeObject.tp_iternext` των "
"αντικειμένων της Python στο API της Python/C."

#: library/stdtypes.rst:936
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""
"Η Python ορίζει διάφορα αντικείμενα iterator για την υποστήριξη της "
"επανάληψης πάνω σε γενικούς και συγκεκριμένους τύπους ακολουθιών "
"(sequences), λεξικά (dictionaries) και άλλες πιο εξειδικευμένες μορφές.  Οι "
"συγκεκριμένοι τύποι δεν είναι σημαντικοί πέρα από την υλοποίησή του iterator "
"πρωτοκόλλου."

#: library/stdtypes.rst:941
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"Μόλις η μέθοδος :meth:`~iterator.__next__` ενός iterator κάνει raise ένα :"
"exc:`StopIteration`, πρέπει να συνεχίσει να το κάνει σε επόμενες κλήσεις. "
"Υλοποιήσεις που δεν υπακούν σε αυτή την ιδιότητα θεωρούνται εσφαλμένες."

#: library/stdtypes.rst:949
msgid "Generator Types"
msgstr "Τύποι Generator"

#: library/stdtypes.rst:951
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`~object.__iter__` method "
"is implemented as a generator, it will automatically return an iterator "
"object (technically, a generator object) supplying the :meth:`~iterator."
"__iter__` and :meth:`~generator.__next__` methods. More information about "
"generators can be found in :ref:`the documentation for the yield expression "
"<yieldexpr>`."
msgstr ""
"Οι :term:`generator`\\s της Python παρέχουν έναν βολικό τρόπο για να "
"υλοποιήσετε το iterator πρωτόκολλο.  Εάν η μέθοδος :meth:`~object.__iter__` "
"ενός container αντικειμένου είναι υλοποιημένη ως generator, θα επιστρέψει "
"αυτόματα ένα αντικείμενο iterator (τεχνικά, ένα αντικείμενο generator) που "
"παρέχει τις :meth:`~iterator.__iter__` και :meth:`~generator.__next__` "
"μεθόδους. Περισσότερες πληροφορίες σχετικά με τους generators μπορείτε να "
"βρείτε στην :ref:`the documentation for the yield expression <yieldexpr>`."

#: library/stdtypes.rst:963
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr ""
"Τύποι Ακολουθίας (Sequence) --- :class:`list`, :class:`tuple`, :class:`range`"

#: library/stdtypes.rst:965
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated "
"sections."
msgstr ""
"Υπάρχουν τρεις βασικοί τύποι ακολουθιών: lists (λίστες), tuples (πλειάδες) "
"και range objects (αντικείμενα εύρους). Πρόσθετοι τύποι ακολουθίας "
"προσαρμοσμένοι για την επεξεργασία :ref:`binary data  <binaryseq>` και :ref:"
"`text strings <textseq>` περιγράφονται σε ειδικές ενότητες."

#: library/stdtypes.rst:974
msgid "Common Sequence Operations"
msgstr "Κοινές Λειτουργίες Ακολουθιών (Sequences)"

#: library/stdtypes.rst:978
msgid ""
"The operations in the following table are supported by most sequence types, "
"both mutable and immutable. The :class:`collections.abc.Sequence` ABC is "
"provided to make it easier to correctly implement these operations on custom "
"sequence types."
msgstr ""
"Οι λειτουργίες του παρακάτω πίνακα υποστηρίζονται από τους περισσότερους "
"τύπους ακολουθιών, τόσο μεταβλητών (mutable) όσο και αμετάβλητων "
"(immutable). Η :class:`collections.abc.Sequence` ABC παρέχεται για να "
"διευκολύνει τη σωστή υλοποίηση αυτών των πράξεων σε προσαρμοσμένους τύπους "
"ακολουθίας."

#: library/stdtypes.rst:983
msgid ""
"This table lists the sequence operations sorted in ascending priority.  In "
"the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* "
"are integers and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s*."
msgstr ""
"Αυτός ο πίνακας απαριθμεί τις λειτουργίες ακολουθίας ταξινομημένες κατά "
"αύξουσα προτεραιότητα.  Στον πίνακα, τα *s* και *t* είναι ακολουθίες του "
"ίδιου τύπου, τα *n*, *i*, *j* και *k* είναι ακέραιοι αριθμοί και το *x* "
"είναι ένα αυθαίρετο αντικείμενο που πληροί οποιονδήποτε τύπο και "
"περιορισμούς τιμής που επιβάλλονται από το *s*."

#: library/stdtypes.rst:988
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric operations. "
"[3]_"
msgstr ""
"Οι πράξεις ``in`` και ``not in`` έχουν τις ίδιες προτεραιότητες με τις "
"πράξεις σύγκρισης. Οι πράξεις ``+`` (συνένωση) και ``*`` (επανάληψη) έχουν "
"την ίδια προτεραιότητα με τις αντίστοιχες αριθμητικές πράξεις. [3]_"

#: library/stdtypes.rst:1009
msgid "``x in s``"
msgstr "``x in s``"

#: library/stdtypes.rst:1009
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "``True`` αν ένα στοιχείο του *s* είναι ίσο με το *x*, αλλιώς ``False``"

#: library/stdtypes.rst:1012
msgid "``x not in s``"
msgstr "``x not in s``"

#: library/stdtypes.rst:1012
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "``False`` αν ένα στοιχείο του *s* είναι ίσο με το *x*, αλλιώς ``True``"

#: library/stdtypes.rst:1015
msgid "``s + t``"
msgstr "``s + t``"

#: library/stdtypes.rst:1015
msgid "the concatenation of *s* and *t*"
msgstr "η συνένωση του *s* και *t*"

#: library/stdtypes.rst:1015
msgid "(6)(7)"
msgstr "(6)(7)"

#: library/stdtypes.rst:1018
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` ή ``n * s``"

#: library/stdtypes.rst:1018
msgid "equivalent to adding *s* to itself *n* times"
msgstr "ίσο με την πρόσθεση του *s* στον εαυτό του *n* φορές"

#: library/stdtypes.rst:1018
msgid "(2)(7)"
msgstr "(2)(7)"

#: library/stdtypes.rst:1021
msgid "``s[i]``"
msgstr "``s[i]``"

#: library/stdtypes.rst:1021
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*i*\\ ο στοιχείο του *s*, αρχή το 0"

#: library/stdtypes.rst:1023
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: library/stdtypes.rst:1023
msgid "slice of *s* from *i* to *j*"
msgstr "slice (υποσύνολο) του *s* από το *i* μέχρι το *j*"

#: library/stdtypes.rst:1023
msgid "(3)(4)"
msgstr "(3)(4)"

#: library/stdtypes.rst:1025
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: library/stdtypes.rst:1025
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "slice (υποσύνολο) του *s* από το *i* μέχρι το *j* με βήμα *k*"

#: library/stdtypes.rst:1025
msgid "(3)(5)"
msgstr "(3)(5)"

#: library/stdtypes.rst:1028
msgid "``len(s)``"
msgstr "``len(s)``"

#: library/stdtypes.rst:1028
msgid "length of *s*"
msgstr "μήκος του *s*"

#: library/stdtypes.rst:1030
msgid "``min(s)``"
msgstr "``min(s)``"

#: library/stdtypes.rst:1030
msgid "smallest item of *s*"
msgstr "μικρότερο αντικείμενο του *s*"

#: library/stdtypes.rst:1032
msgid "``max(s)``"
msgstr "``max(s)``"

#: library/stdtypes.rst:1032
msgid "largest item of *s*"
msgstr "μεγαλύτερο αντικείμενο του *s*"

#: library/stdtypes.rst:1034
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: library/stdtypes.rst:1034
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr ""
"δείκτης της πρώτης εμφάνισης του *x* στο *s* (μετά από τον ή στον δείκτη *i* "
"και πριν από το δείκτη *j*)"

#: library/stdtypes.rst:3981
msgid "\\(8)"
msgstr "\\(8)"

#: library/stdtypes.rst:1038
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: library/stdtypes.rst:1038
msgid "total number of occurrences of *x* in *s*"
msgstr "συνολικές εμφανίσεις του *x* στο *s*"

#: library/stdtypes.rst:1042
msgid ""
"Sequences of the same type also support comparisons.  In particular, tuples "
"and lists are compared lexicographically by comparing corresponding "
"elements. This means that to compare equal, every element must compare equal "
"and the two sequences must be of the same type and have the same length.  "
"(For full details see :ref:`comparisons` in the language reference.)"
msgstr ""
"Οι ακολουθίες (sequences) του ίδιου τύπου υποστηρίζουν επίσης συγκρίσεις.  "
"Ειδικότερα, τα tuples (πλειάδες) και οι λίστες συγκρίνονται λεξικογραφικά "
"συγκρίνοντας τα αντίστοιχα στοιχεία. Αυτό σημαίνει ότι για να συγκρίνουμε "
"ίσα, κάθε στοιχείο πρέπει να συγκρίνεται ως ίσο με το αντίστοιχό του, οι δύο "
"ακολουθίες πρέπει να είναι του ίδιου τύπου και να έχουν το ίδιο μήκος.  (Για "
"πλήρεις λεπτομέρειες δείτε την αναφορά :ref:`comparisons`.)"

#: library/stdtypes.rst:1052
msgid ""
"Forward and reversed iterators over mutable sequences access values using an "
"index.  That index will continue to march forward (or backward) even if the "
"underlying sequence is mutated.  The iterator terminates only when an :exc:"
"`IndexError` or a :exc:`StopIteration` is encountered (or when the index "
"drops below zero)."
msgstr ""
"Εμπρόσθιοι και αντίστροφοι iterators πάνω σε μεταβλητές ακολουθίες έχουν "
"πρόσβαση σε τιμές χρησιμοποιώντας ένα δείκτη.  Αυτός ο δείκτης θα συνεχίσει "
"να βαδίζει προς τα εμπρός (ή προς τα πίσω) ακόμα και αν η υποκείμενη "
"ακολουθία μεταλλάσσεται.  Ο iterator τερματίζει μόνο όταν ένα :exc:"
"`IndexError` ή ένα :exc:`StopIteration` γίνει raise (ή όταν ο δείκτης πέσει "
"κάτω από το μηδέν)."

#: library/stdtypes.rst:1061
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such "
"as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them for "
"subsequence testing::"
msgstr ""
"Ενώ οι πράξεις ``in`` και ``not in`` χρησιμοποιούνται γενικά μόνο για απλό "
"έλεγχο containment (αν στοιχείο περιέχεται σε μια δομή), ορισμένες "
"εξειδικευμένες ακολουθίες (όπως όπως οι :class:`str`, :class:`bytes` και :"
"class:`bytearray`) τις χρησιμοποιούν επίσης για subsequence testing (έλεγχο "
"υποακολουθίας)::"

#: library/stdtypes.rst:1066
msgid ""
">>> \"gg\" in \"eggs\"\n"
"True"
msgstr ""
">>> \"gg\" in \"eggs\"\n"
"True"

#: library/stdtypes.rst:1070
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider::"
msgstr ""
"Τιμές του *n* μικρότερες από το ``0`` αντιμετωπίζονται ως ``0`` (που δίνει "
"μια κενή ακολουθία του ίδιου τύπου με *s*).  Σημειώστε ότι τα στοιχεία της "
"ακολουθίας *s* δεν αντιγράφονται· αναφέρονται πολλές φορές.  Αυτό συχνά "
"στοιχειώνει τα άτομα που ξεκινούν με Python- σκεφτείτε::"

#: library/stdtypes.rst:1075
msgid ""
">>> lists = [[]] * 3\n"
">>> lists\n"
"[[], [], []]\n"
">>> lists[0].append(3)\n"
">>> lists\n"
"[[3], [3], [3]]"
msgstr ""
">>> lists = [[]] * 3\n"
">>> lists\n"
"[[], [], []]\n"
">>> lists[0].append(3)\n"
">>> lists\n"
"[[3], [3], [3]]"

#: library/stdtypes.rst:1082
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way::"
msgstr ""
"Αυτό που συνέβη είναι ότι το ``[[]]`` είναι μια λίστα ενός στοιχείου που "
"περιέχει μία κενή λίστα, οπότε και τα τρία στοιχεία της ``[[]] * 3`` είναι "
"αναφορές σε αυτή τη μία κενή λίστα.  Η τροποποίηση οποιουδήποτε από τα "
"στοιχεία της ``lists`` τροποποιεί αυτή τη μοναδική λίστα. Μπορείτε να "
"δημιουργήσετε μια λίστα από διαφορετικές λίστες με αυτόν τον τρόπο::"

#: library/stdtypes.rst:1087
msgid ""
">>> lists = [[] for i in range(3)]\n"
">>> lists[0].append(3)\n"
">>> lists[1].append(5)\n"
">>> lists[2].append(7)\n"
">>> lists\n"
"[[3], [5], [7]]"
msgstr ""
">>> lists = [[] for i in range(3)]\n"
">>> lists[0].append(3)\n"
">>> lists[1].append(5)\n"
">>> lists[2].append(7)\n"
">>> lists\n"
"[[3], [5], [7]]"

#: library/stdtypes.rst:1094
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-multidimensional-"
"list`."
msgstr ""
"Περαιτέρω επεξήγηση είναι διαθέσιμη στο λήμμα FAQ :ref:`faq-multidimensional-"
"list`."

#: library/stdtypes.rst:1098
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"Εάν το *i* ή το *j* είναι αρνητικό, ο δείκτης είναι σχετικός με το τέλος της "
"ακολουθίας *s*: το ``len(s) + i`` ή το ``len(s) + j`` αντικαθίσταται.  "
"Σημειώστε όμως ότι το ``-0`` εξακολουθεί να είναι ``0``."

#: library/stdtypes.rst:1103
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""
"Το υποσύνολο (slice) του *s* από το *i* έως το *j* ορίζεται ως η ακολουθία "
"στοιχείων με δείκτη *k* τέτοια ώστε ``i <= k < j```.  Εάν το *i* ή το *j* "
"είναι μεγαλύτερο από το ``len(s)``, χρησιμοποιήστε το ``len(s)``.  Αν το *i* "
"παραλείπεται ή είναι ``None``, χρησιμοποιήστε ``0``.  Αν το *j* παραλείπεται "
"ή είναι ``μηδέν``, χρησιμοποιήστε το ``len(s)``.  Εάν το *i* είναι "
"μεγαλύτερο από ή ίσο με το *j*, το υποσύνολο (slice) είναι κενό."

#: library/stdtypes.rst:1110
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is "
"``None``, it is treated like ``1``."
msgstr ""
"Το υποσύνολο (slice) του *s* από *i* έως *j* με βήμα *k* ορίζεται ως η "
"ακολουθία των στοιχείων με δείκτη ``x = i + n*k`` τέτοια ώστε ``0 <= n < (j-"
"i)/k``.  Με άλλα λόγια, οι δείκτες είναι ``i``, ``i+k``, ``i+2*k``, "
"``i+3*k`` και ούτω καθεξής, σταματώντας όταν φτάσουμε στο *j* (αλλά ποτέ δεν "
"περιλαμβάνει το *j*).  Όταν το *k* είναι θετικό, τα *i* και *j* μειώνονται "
"σε ``len(s)`` αν είναι μεγαλύτερα. Όταν το *k* είναι αρνητικό, τα *i* και "
"*j* μειώνονται σε ``len(s) - 1`` αν είναι μεγαλύτερα.  Εάν τα *i* ή *j* "
"παραλείπονται ή είναι ``None``, γίνονται τιμές \"end\" (το τέλος εξαρτάται "
"από το πρόσημο του *k*).  Σημειώστε ότι το *k* δεν μπορεί να είναι μηδέν. "
"Εάν το *k* είναι ``None``, αντιμετωπίζεται όπως το ``1``."

#: library/stdtypes.rst:1121
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"Η συνένωση αμετάβλητων ακολουθιών (immutable sequences) οδηγεί πάντα σε ένα "
"νέο αντικείμενο.  Αυτό σημαίνει ότι η δημιουργία μιας ακολουθίας με "
"επαναλαμβανόμενη συνένωση θα έχει τετραγωνικό κόστος χρόνου εκτέλεσης "
"(runtime cost) στο συνολικό μήκος της ακολουθίας.  Για να πάρετε ένα "
"γραμμικό κόστος χρόνου εκτέλεσης (runtime cost), πρέπει να μεταβείτε σε μία "
"από τις παρακάτω εναλλακτικές λύσεις::"

#: library/stdtypes.rst:1126
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end or else write to an :class:`io.StringIO` instance and "
"retrieve its value when complete"
msgstr ""
"αν συνενώνεται αντικείμενα :class:`str`, μπορείτε να δημιουργήσετε μια λίστα "
"και να χρησιμοποιήσετε την :meth:`str.join` στο τέλος ή αλλιώς να γράψετε σε "
"ένα :class:`io.StringIO` instance και ανακτήσετε την τιμή της όταν "
"ολοκληρωθεί"

#: library/stdtypes.rst:1130
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join` or :class:`io.BytesIO`, or you can do in-place concatenation with a :"
"class:`bytearray` object.  :class:`bytearray` objects are mutable and have "
"an efficient overallocation mechanism"
msgstr ""
"αν συνενώνεται αντικείμενα :class:`bytes`, μπορείτε να χρησιμοποιήσετε "
"παρόμοια τη μέθοδο :meth:`bytes.join` ή :class:`io.BytesIO`, ή μπορείτε να "
"κάνετε in-place συνένωση (concatenation) με ένα :class:`bytearray` "
"αντικείμενο. Τα αντικείμενα :class:`bytearray` είναι μεταβλητά και έχουν "
"έναν αποτελεσματικό μηχανισμό συνολικής κατανομής (overallocation)"

#: library/stdtypes.rst:1135
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ""
"αν συνενώνεται αντικείμενα :class:`tuple`, επεκτείνετε μια :class:`list` "
"αντ' αυτού"

#: library/stdtypes.rst:1137
msgid "for other types, investigate the relevant class documentation"
msgstr "για άλλους τύπους, ερευνήστε τη σχετική τεκμηρίωση των κλάσεων"

#: library/stdtypes.rst:1141
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"Ορισμένοι τύποι ακολουθιών (όπως :class:`range`) υποστηρίζουν μόνο "
"ακολουθίες στοιχείων που ακολουθούν συγκεκριμένα μοτίβα, και ως εκ τούτου "
"δεν υποστηρίζουν ακολουθία συνένωση ή επανάληψη."

#: library/stdtypes.rst:1146
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. These "
"arguments allow efficient searching of subsections of the sequence. Passing "
"the extra arguments is roughly equivalent to using ``s[i:j].index(x)``, only "
"without copying any data and with the returned index being relative to the "
"start of the sequence rather than the start of the slice."
msgstr ""
"Το ``index`` κάνει raise :exc:`ValueError` όταν το *x* δεν βρίσκεται στο "
"*s*. Όχι όλες οι υλοποιήσεις υποστηρίζουν τη διαβίβαση των πρόσθετων ορίων "
"*i* και *j*. Αυτές οι παράμετροι επιτρέπουν την αποτελεσματική αναζήτηση "
"υποτμημάτων της ακολουθίας. Η διαβίβαση των πρόσθετων ορίων είναι περίπου "
"ισοδύναμη με τη χρήση του ``s[i:j].index(x)``, μόνο χωρίς να αντιγράφονται "
"δεδομένα και με τον επιστρεφόμενο δείκτη να είναι σχετικός με την αρχή της "
"ακολουθίας και όχι στην αρχή του υποσυνόλου (slice)."

#: library/stdtypes.rst:1157
msgid "Immutable Sequence Types"
msgstr "Τύποι Αμετάβλητων Ακολουθιών (Sequences)"

#: library/stdtypes.rst:1164
msgid ""
"The only operation that immutable sequence types generally implement that is "
"not also implemented by mutable sequence types is support for the :func:"
"`hash` built-in."
msgstr ""
"Η μόνη λειτουργία που υλοποιούν οι αμετάβλητοι γενικοί τύποι ακολουθίας που "
"δεν είναι υλοποιημένοι από μεταβλητούς τύπους ακολουθίας, είναι η υποστήριξη "
"της :func:`hash` built-in."

#: library/stdtypes.rst:1168
msgid ""
"This support allows immutable sequences, such as :class:`tuple` instances, "
"to be used as :class:`dict` keys and stored in :class:`set` and :class:"
"`frozenset` instances."
msgstr ""
"Αυτή η υποστήριξη επιτρέπει αμετάβλητες ακολουθίες, όπως οι περιπτώσεις των :"
"class:`tuple`, να χρησιμοποιούνται ως κλειδιά :class:`dict` και να "
"αποθηκεύονται σε :class:`set` και :class:`frozenset` instances."

#: library/stdtypes.rst:1172
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr ""
"Η προσπάθεια κατακερματισμού μιας αμετάβλητης ακολουθίας που περιέχει μη "
"κατακερματιστέες (unhashable) τιμές θα οδηγήσει σε :exc:`TypeError`."

#: library/stdtypes.rst:1179
msgid "Mutable Sequence Types"
msgstr "Τύποι Μεταβλητών Ακολουθιών (Sequences)"

#: library/stdtypes.rst:1186
msgid ""
"The operations in the following table are defined on mutable sequence types. "
"The :class:`collections.abc.MutableSequence` ABC is provided to make it "
"easier to correctly implement these operations on custom sequence types."
msgstr ""
"Οι λειτουργίες του ακόλουθου πίνακα ορίζονται σε μεταβλητούς τύπους "
"ακολουθίας. Η :class:`collections.abc.MutableSequence` ABC παρέχεται για να "
"κάνει ευκολότερη την σωστή υλοποίηση αυτών των λειτουργιών σε "
"προσαρμοσμένους τύπους ακολουθιών."

#: library/stdtypes.rst:1190
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and value "
"restrictions imposed by *s* (for example, :class:`bytearray` only accepts "
"integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"Στον πίνακα το *s* είναι ένα instance ενός μεταβλητού τύπου ακολουθίας, το "
"*t* είναι οποιοδήποτε iterable αντικείμενο και το *x* είναι ένα αυθαίρετο "
"αντικείμενο που πληροί οποιονδήποτε τύπο και περιορισμούς τιμής που "
"επιβάλλονται από το *s* (για παράδειγμα, το :class:`bytearray` δέχεται μόνο "
"ακέραιους που πληρούν τον περιορισμό ``0 <= x <= 255``)."

#: library/stdtypes.rst:1214
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: library/stdtypes.rst:1214
msgid "item *i* of *s* is replaced by *x*"
msgstr "το στοιχείο *i* του *s* αντικαθίσταται από το *x*"

#: library/stdtypes.rst:1217
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: library/stdtypes.rst:1217
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""
"το υποσύνολο (slice) του *s* από το *i* έως το *j* αντικαθίσταται από τα "
"περιεχόμενα του iterable *t*"

#: library/stdtypes.rst:1221
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: library/stdtypes.rst:1221
msgid "same as ``s[i:j] = []``"
msgstr "ίδιο με το ``s[i:j] = []``"

#: library/stdtypes.rst:1223
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: library/stdtypes.rst:1223
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "τα στοιχεία του ``s[i:j:k]`` αντικαθίστανται από εκείνα του *t*"

#: library/stdtypes.rst:1226
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: library/stdtypes.rst:1226
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "αφαιρεί τα στοιχεία του ``s[i:j:k]`` από τη λίστα"

#: library/stdtypes.rst:1229
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: library/stdtypes.rst:1229
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = [x]``)"
msgstr ""
"εισάγει το *x* στο τέλος της ακολουθίας (ίδιο με ``s[len(s):len(s)] = [x]``)"

#: library/stdtypes.rst:1233
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: library/stdtypes.rst:1233
msgid "removes all items from *s* (same as ``del s[:]``)"
msgstr "αφαιρεί όλα τα στοιχεία από το *s* (ίδιο με το ``del s[:]``)"

#: library/stdtypes.rst:1236
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: library/stdtypes.rst:1236
msgid "creates a shallow copy of *s* (same as ``s[:]``)"
msgstr "δημιουργεί ένα shallow αντίγραφο του *s* (ίδιο με το ``s[:]``)"

#: library/stdtypes.rst:1239
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` ή ``s += t``"

#: library/stdtypes.rst:1239
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr ""
"επεκτείνει το *s* με τα περιεχόμενα του *t* (ως επί το πλείστον το ίδιο με "
"το ``s[len(s):len(s)] = t``)"

#: library/stdtypes.rst:1244
msgid "``s *= n``"
msgstr "``s *= n``"

#: library/stdtypes.rst:1244
msgid "updates *s* with its contents repeated *n* times"
msgstr "ενημερώνει το *s* με το περιεχόμενό του επαναλαμβανόμενο *n* φορές"

#: library/stdtypes.rst:1247
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: library/stdtypes.rst:1247
msgid ""
"inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr ""
"εισάγει το *x* στο *s* στο δείκτη που δίνεται από το *i* (το ίδιο με το "
"``s[i:i] = [x]``)"

#: library/stdtypes.rst:1251
msgid "``s.pop()`` or ``s.pop(i)``"
msgstr "``s.pop()`` ή ``s.pop(i)``"

#: library/stdtypes.rst:1251
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "ανακτά το στοιχείο στο *i* και το αφαιρεί επίσης από το *s*"

#: library/stdtypes.rst:1254
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: library/stdtypes.rst:1254
msgid "removes the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "αφαιρεί το πρώτο στοιχείο από το *s* όπου ``s[i]`` είναι ίσο με *x*"

#: library/stdtypes.rst:1258
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: library/stdtypes.rst:1258
msgid "reverses the items of *s* in place"
msgstr "αντιστρέφει τα στοιχεία του *s*"

#: library/stdtypes.rst:1266
msgid ""
"If *k* is not equal to ``1``, *t* must have the same length as the slice it "
"is replacing."
msgstr ""
"Αν το *k* δεν είναι ίσο με ``1``, το *t* πρέπει να έχει το ίδιο μήκος με το "
"τμήμα που αντικαθιστά."

#: library/stdtypes.rst:1269
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""
"Το προαιρετικό όρισμα *i* έχει προεπιλεγμένη τιμή ``-1``, έτσι ώστε από "
"default το τελευταίο στοιχείο αφαιρείται και επιστρέφεται."

#: library/stdtypes.rst:1273
msgid ":meth:`remove` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr ""
"η :meth:`remove` κάνει raise :exc:`ValueError` όταν το *x* δεν βρίσκεται στο "
"*s*."

#: library/stdtypes.rst:1276
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates by "
"side effect, it does not return the reversed sequence."
msgstr ""
"Η μέθοδος :meth:`reverse` τροποποιεί την ακολουθία στη θέση της για "
"οικονομία χώρου όταν αντιστρέφεται μια μεγάλη ακολουθία.  Να υπενθυμίσουμε "
"στους χρήστες ότι λειτουργεί με παρενέργεια, δεν επιστρέφει την "
"αντιστραμμένη ακολουθία."

#: library/stdtypes.rst:1281
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations (such "
"as :class:`dict` and :class:`set`). :meth:`!copy` is not part of the :class:"
"`collections.abc.MutableSequence` ABC, but most concrete mutable sequence "
"classes provide it."
msgstr ""
"η :meth:`clear` και η :meth:`!copy` περιλαμβάνονται για λόγους συνέπειας με "
"τα interfaces των μεταβλητών container που δεν υποστηρίζουν λειτουργίες "
"τμηματοποίησης (όπως τα :class:`dict` και :class:`set`). Η :meth:`!copy` δεν "
"αποτελεί μέρος της :class:`collections.abc.MutableSequence` ABC, αλλά οι "
"περισσότερες κλάσεις μεταβλητών ακολουθιών την παρέχουν."

#: library/stdtypes.rst:1287
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr "μέθοδοι :meth:`clear` και :meth:`!copy`."

#: library/stdtypes.rst:1291
msgid ""
"The value *n* is an integer, or an object implementing :meth:`~object."
"__index__`.  Zero and negative values of *n* clear the sequence.  Items in "
"the sequence are not copied; they are referenced multiple times, as "
"explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"Η τιμή *n* είναι ένας ακέραιος αριθμός ή ένα αντικείμενο που υλοποιεί την :"
"meth:`~object.__index__`.  Οι μηδενικές και αρνητικές τιμές του *n* "
"καθαρίζουν την ακολουθία.  Τα στοιχεία της ακολουθίας δεν αντιγράφονται· "
"αναφέρονται πολλές φορές, όπως εξηγείται για το ``s * n``` στο :ref:"
"`typesseq-common`."

#: library/stdtypes.rst:1300
msgid "Lists"
msgstr "Λίστες"

#: library/stdtypes.rst:1304
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"Οι λίστες είναι μεταβλητές ακολουθίες, που συνήθως χρησιμοποιούνται για την "
"αποθήκευση συλλογών ομοιογενών στοιχείων (όπου ο ακριβής βαθμός ομοιότητας "
"ποικίλλει ανάλογα με εφαρμογή)."

#: library/stdtypes.rst:1310
msgid "Lists may be constructed in several ways:"
msgstr "Οι λίστες μπορούν να κατασκευαστούν με διάφορους τρόπους:"

#: library/stdtypes.rst:1312
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""
"Χρησιμοποιείστε ένα ζεύγος αγκυλών για να δηλώσετε την κενή λίστα: ``[]``"

#: library/stdtypes.rst:1313
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"Χρησιμοποιώντας αγκύλες, διαχωρίζοντας τα στοιχεία με κόμματα: ``[a]``, "
"``[a, b, c]``"

#: library/stdtypes.rst:1314
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "Χρήση ενός list comprehension: ``[x for x in iterable]``"

#: library/stdtypes.rst:1315
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr ""
"Χρήση του κατασκευαστή τύπου (type constructor): ``list()`` ή "
"``list(iterable)``"

#: library/stdtypes.rst:1317
msgid ""
"The constructor builds a list whose items are the same and in the same order "
"as *iterable*'s items.  *iterable* may be either a sequence, a container "
"that supports iteration, or an iterator object.  If *iterable* is already a "
"list, a copy is made and returned, similar to ``iterable[:]``. For example, "
"``list('abc')`` returns ``['a', 'b', 'c']`` and ``list( (1, 2, 3) )`` "
"returns ``[1, 2, 3]``. If no argument is given, the constructor creates a "
"new empty list, ``[]``."
msgstr ""
"Ο κατασκευαστής (constructor) δημιουργεί μια λίστα της οποίας τα στοιχεία "
"είναι τα ίδια και με την ίδια σειρά όπως τα στοιχεία του *iterable*.  Το "
"*iterable* μπορεί να είναι είτε μια ακολουθία, είτε ένας container που "
"υποστηρίζει την επανάληψη, ή ένα αντικείμενο iterator.  Εάν το *iterable* "
"είναι ήδη μια λίστα, δημιουργείται ένα αντίγραφο και επιστρέφεται, παρόμοια "
"με την ``iterable[:]``. Για παράδειγμα, η ``list('abc')`` επιστρέφει ``['a', "
"'b', 'c']`` και η ``list( (1, 2, 3) )`` επιστρέφει ``[1, 2, 3]``. Αν δεν "
"δοθεί κανένα όρισμα, ο κατασκευαστής δημιουργεί μία νέα κενή λίστα, ``[]``."

#: library/stdtypes.rst:1326
msgid ""
"Many other operations also produce lists, including the :func:`sorted` built-"
"in."
msgstr ""
"Πολλές άλλες λειτουργίες παράγουν επίσης λίστες, συμπεριλαμβανομένης της "
"built-in :func:`sorted`."

#: library/stdtypes.rst:1329
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and :ref:`mutable "
"<typesseq-mutable>` sequence operations. Lists also provide the following "
"additional method:"
msgstr ""
"Οι λίστες υλοποιούν όλες τις :ref:`common <typesseq-common>` και :ref:"
"`mutable <typesseq-mutable>` λειτουργίες ακολουθίας. Οι λίστες παρέχουν "
"επίσης την ακόλουθη πρόσθετη μέθοδο:"

#: library/stdtypes.rst:1335
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between "
"items. Exceptions are not suppressed - if any comparison operations fail, "
"the entire sort operation will fail (and the list will likely be left in a "
"partially modified state)."
msgstr ""
"Αυτή η μέθοδος ταξινομεί τη λίστα, χρησιμοποιώντας μόνο συγκρίσεις ``<`` "
"μεταξύ στοιχείων. Οι εξαιρέσεις δεν καταστέλλονται - αν αποτύχει κάποια "
"πράξη σύγκρισης, ολόκληρη η λειτουργία ταξινόμησης θα αποτύχει (και η λίστα "
"θα παραμείνει πιθανότατα σε μια μερικώς τροποποιημένη κατάσταση)."

#: library/stdtypes.rst:1340
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword (:ref:"
"`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
"η :meth:`sort` δέχεται δύο ορίσματα που μπορούν να περάσουν μόνο με τη λέξη-"
"κλειδί (:ref:`keyword-only arguments <keyword-only_parameter>`):"

#: library/stdtypes.rst:1343
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). The "
"key corresponding to each item in the list is calculated once and then used "
"for the entire sorting process. The default value of ``None`` means that "
"list items are sorted directly without calculating a separate key value."
msgstr ""
"το *key* καθορίζει μια συνάρτηση ενός ορίσματος που χρησιμοποιείται για την "
"εξαγωγή ενός κλειδιού σύγκρισης (comparison key) από κάθε στοιχείο της "
"λίστας (για παράδειγμα, ``key=str.lower``). Το κλειδί που αντιστοιχεί σε "
"κάθε στοιχείο της λίστας υπολογίζεται μία φορά και στη συνέχεια "
"χρησιμοποιείται για ολόκληρη τη διαδικασία ταξινόμησης. Η προεπιλεγμένη τιμή "
"(default) ``None`` σημαίνει ότι τα στοιχεία της λίστας ταξινομούνται "
"απευθείας χωρίς να υπολογίζεται ξεχωριστή τιμή κλειδιού."

#: library/stdtypes.rst:1350
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x style "
"*cmp* function to a *key* function."
msgstr ""
"Το utility :func:`functools.cmp_to_key` είναι διαθέσιμο για τη μετατροπή μια "
"συνάρτηση *cmp* στυλ 2.x σε συνάρτηση *key*."

#: library/stdtypes.rst:1353
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"η *reverse* είναι μια λογική (boolean) τιμή.  Αν τεθεί σε ``True``, τότε τα "
"στοιχεία της λίστας ταξινομούνται σαν να ήταν αντίστροφη κάθε σύγκριση."

#: library/stdtypes.rst:1356
msgid ""
"This method modifies the sequence in place for economy of space when sorting "
"a large sequence.  To remind users that it operates by side effect, it does "
"not return the sorted sequence (use :func:`sorted` to explicitly request a "
"new sorted list instance)."
msgstr ""
"Αυτή η μέθοδος τροποποιεί την ακολουθία για εξοικονόμηση χώρου κατά την "
"ταξινόμηση μιας μεγάλης ακολουθίας.  Nα υπενθυμίσουμε στους χρήστες ότι "
"λειτουργεί με παρενέργεια, δεν επιστρέφει την ταξινομημένη ακολουθία "
"(χρησιμοποιήστε την :func:`sorted` για να ζητήσετε μια νέα περίπτωση "
"ταξινομημένης λίστας)."

#: library/stdtypes.rst:1361
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""
"Η μέθοδος :meth:`sort` είναι εγγυημένα σταθερή.  Μια ταξινόμηση είναι "
"σταθερή αν εγγυάται ότι δεν θα αλλάξει τη σχετική σειρά των στοιχείων που "
"συγκρίνουν ίσα --- αυτό είναι χρήσιμο για την ταξινόμηση σε πολλαπλά "
"περάσματα (για παράδειγμα, ταξινόμηση κατά τμήμα, στη συνέχεια με βάση το "
"μισθολογικό κλιμάκιο κτλ)."

#: library/stdtypes.rst:1366
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Για παραδείγματα ταξινόμησης και ένα σύντομο tutorial, δείτε :ref:"
"`sortinghowto`."

#: library/stdtypes.rst:1370
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""
"Ενώ μια λίστα ταξινομείται, το αποτέλεσμα της προσπάθειας μετάλλαξης, ή "
"ακόμα και η επιθεώρηση, της λίστας είναι απροσδιόριστη.  Η υλοποίηση της "
"Python στη C κάνει την λίστα να εμφανίζεται κενή για όλη τη διάρκεια, και "
"κάνει raise :exc:`ValueError` αν ανιχνεύσει ότι η λίστα έχει μεταλλαχθεί "
"κατά τη διάρκεια μιας ταξινόμησης."

#: library/stdtypes.rst:1379
msgid "Tuples"
msgstr "Πλειάδες (Tuples)"

#: library/stdtypes.rst:1383
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the :func:`enumerate` "
"built-in). Tuples are also used for cases where an immutable sequence of "
"homogeneous data is needed (such as allowing storage in a :class:`set` or :"
"class:`dict` instance)."
msgstr ""
"Οι πλειάδες (tuples) είναι αμετάβλητες ακολουθίες, που συνήθως "
"χρησιμοποιούνται για την αποθήκευση συλλογών ετερογενών δεδομένων (όπως οι 2-"
"tuples που παράγονται από την built-in :func:`enumerate`). Τα tuples "
"χρησιμοποιούνται επίσης για περιπτώσεις όπου μια αμετάβλητη ακολουθία "
"ομοιογενών δεδομένων (όπως για παράδειγμα για να επιτρέπεται η αποθήκευση σε "
"ένα :class:`set` ή σε ένα :class:`dict` instance)."

#: library/stdtypes.rst:1391
msgid "Tuples may be constructed in a number of ways:"
msgstr "Οι πλειάδες (tuples) μπορούν να κατασκευαστούν με διάφορους τρόπους:"

#: library/stdtypes.rst:1393
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""
"Χρήση ενός ζεύγους παρενθέσεων για να δηλωθεί το κενό tuple (πλειάδα): ``()``"

#: library/stdtypes.rst:1394
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr ""
"Χρήση ενός κόμματος στο τέλος για ένα μοναδικό tuple (πλειάδα): ``a,`` ή "
"``(a,)``"

#: library/stdtypes.rst:1395
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "Διαχωρισμός στοιχείων με κόμμα: ``a, b, c`` ή ``(a, b, c)``"

#: library/stdtypes.rst:1396
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr ""
"Χρήση του ενσωματωμένου :func:`tuple`: ``tuple()`` ή ``tuple(iterable)``"

#: library/stdtypes.rst:1398
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* is "
"already a tuple, it is returned unchanged. For example, ``tuple('abc')`` "
"returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, "
"3)``. If no argument is given, the constructor creates a new empty tuple, "
"``()``."
msgstr ""
"Ο κατασκευαστής (constructor) δημιουργεί μια πλειάδα (tuple) του οποίου τα "
"στοιχεία είναι τα ίδια και στην ίδια σειρά με τα στοιχεία του *iterable*.  Η "
"*iterable* μπορεί να είναι είτε μια ακολουθία, είτε έναν container που "
"υποστηρίζει την επανάληψη, ή ένα αντικείμενο iterator.  Εάν το *iterable* "
"είναι ήδη ένα tuple, επιστρέφεται αμετάβλητο. Για παράδειγμα, το "
"``tuple('abc')`` επιστρέφει ``('a', 'b', 'c')`` και το ``tuple( [1, 2, "
"3] )`` επιστρέφει ``(1, 2, 3)``. Αν δεν δοθεί κανένα όρισμα, ο κατασκευαστής "
"δημιουργεί μια ένα κενό tuple, ``()``."

#: library/stdtypes.rst:1406
msgid ""
"Note that it is actually the comma which makes a tuple, not the parentheses. "
"The parentheses are optional, except in the empty tuple case, or when they "
"are needed to avoid syntactic ambiguity. For example, ``f(a, b, c)`` is a "
"function call with three arguments, while ``f((a, b, c))`` is a function "
"call with a 3-tuple as the sole argument."
msgstr ""
"Σημειώστε ότι στην πραγματικότητα το κόμμα είναι αυτό που κάνει ένα tuple "
"(πλειάδα), όχι οι παρενθέσεις. Οι παρενθέσεις είναι προαιρετικές, εκτός από "
"την περίπτωση κενού tuple ή όταν χρειάζονται για την αποφυγή συντακτικής "
"ασάφειας. Για παράδειγμα, η ``f(a, b, c)`` είναι μια κλήση συνάρτησης με "
"τρία ορίσματα, ενώ η ``f((a, b, c))`` είναι μια συνάρτηση κλήση συνάρτησης "
"με ένα 3-tuple ως μοναδικό όρισμα."

#: library/stdtypes.rst:1412
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr ""
"Τα Tuples υλοποιούν όλες τις πράξεις ακολουθιών :ref:`common <typesseq-"
"common>`."

#: library/stdtypes.rst:1415
msgid ""
"For heterogeneous collections of data where access by name is clearer than "
"access by index, :func:`collections.namedtuple` may be a more appropriate "
"choice than a simple tuple object."
msgstr ""
"Για ετερογενείς συλλογές δεδομένων όπου η πρόσβαση με βάση το όνομα είναι "
"σαφέστερη από την πρόσβαση με βάση το δείκτη, το :func:`collections."
"namedtuple` μπορεί να είναι μια πιο κατάλληλη επιλογή από ένα απλό "
"αντικείμενο tuple (πλειάδα)."

#: library/stdtypes.rst:1423
msgid "Ranges"
msgstr "Εύρη (Ranges)"

#: library/stdtypes.rst:1427
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and is "
"commonly used for looping a specific number of times in :keyword:`for` loops."
msgstr ""
"Ο τύπος :class:`range` αναπαριστά μια αμετάβλητη ακολουθία αριθμών και "
"συνήθως χρησιμοποιείται για την επανάληψη ενός συγκεκριμένου αριθμού "
"επαναλήψεων σε βρόχους :keyword:`for`."

#: library/stdtypes.rst:1434
msgid ""
"The arguments to the range constructor must be integers (either built-in :"
"class:`int` or any object that implements the :meth:`~object.__index__` "
"special method).  If the *step* argument is omitted, it defaults to ``1``. "
"If the *start* argument is omitted, it defaults to ``0``. If *step* is "
"zero, :exc:`ValueError` is raised."
msgstr ""
"Τα ορίσματα του  κατασκευαστή εύρους (range constructor) πρέπει να είναι "
"ακέραιοι αριθμοί (είτε της built-in :class:`int` ή οποιοδήποτε αντικείμενο "
"που υλοποιεί την ειδική μέθοδο :meth:`~object.__index__`). Εάν το όρισμα "
"*step* παραλείπεται, το προεπιλογή (default) είναι ``1``. Εάν το όρισμα "
"*start* παραλείπεται, το προεπιλογή (default) είναι ``0``. Εάν το *step* "
"είναι μηδέν, γίνεται raise ένα :exc:`ValueError`."

#: library/stdtypes.rst:1440
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by the "
"formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < stop``."
msgstr ""
"Για ένα θετικό *βήμα*, τα περιεχόμενα του range (εύρους) ``r`` καθορίζονται "
"από τον τύπο ``r[i] = start + step*i`` όπου ``i >= 0`` και ``r[i] < stop``."

#: library/stdtypes.rst:1444
msgid ""
"For a negative *step*, the contents of the range are still determined by the "
"formula ``r[i] = start + step*i``, but the constraints are ``i >= 0`` and "
"``r[i] > stop``."
msgstr ""
"Για ένα αρνητικό *βήμα*, τα περιεχόμενα του εύρους (range) εξακολουθούν να "
"καθορίζονται από τον τύπο ``r[i] = start + step*i``, αλλά οι περιορισμοί "
"είναι ``i >= 0`` και ``r[i] > stop``."

#: library/stdtypes.rst:1448
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value constraint. "
"Ranges do support negative indices, but these are interpreted as indexing "
"from the end of the sequence determined by the positive indices."
msgstr ""
"Ένα αντικείμενο range θα είναι άδειο εάν το ``r[0]`` δεν πληροί τον "
"περιορισμό τιμής. Τα ranges υποστηρίζουν αρνητικούς δείκτες, αλλά αυτοί "
"ερμηνεύονται ως δείκτες από το τέλος της ακολουθίας που καθορίζεται από τους "
"θετικούς δείκτες."

#: library/stdtypes.rst:1453
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise :exc:"
"`OverflowError`."
msgstr ""
"Τα ranges που περιέχουν απόλυτες τιμές μεγαλύτερες από :data:`sys.maxsize` "
"είναι επιτρεπτά, αλλά ορισμένα χαρακτηριστικά (όπως :func:`len`) μπορεί να "
"κάνουν raise :exc:`OverflowError`."

#: library/stdtypes.rst:1457
msgid "Range examples::"
msgstr "Παραδείγματα Range::"

#: library/stdtypes.rst:1459
msgid ""
">>> list(range(10))\n"
"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> list(range(1, 11))\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"
">>> list(range(0, 30, 5))\n"
"[0, 5, 10, 15, 20, 25]\n"
">>> list(range(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
">>> list(range(0, -10, -1))\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n"
">>> list(range(0))\n"
"[]\n"
">>> list(range(1, 0))\n"
"[]"
msgstr ""
">>> list(range(10))\n"
"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
">>> list(range(1, 11))\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"
">>> list(range(0, 30, 5))\n"
"[0, 5, 10, 15, 20, 25]\n"
">>> list(range(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
">>> list(range(0, -10, -1))\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n"
">>> list(range(0))\n"
"[]\n"
">>> list(range(1, 0))\n"
"[]"

#: library/stdtypes.rst:1474
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that range "
"objects can only represent sequences that follow a strict pattern and "
"repetition and concatenation will usually violate that pattern)."
msgstr ""
"Τα ranges υλοποιούν όλες τις ακολουθίες :ref:`common <typesseq-common>` "
"εκτός από τη συνένωση και την επανάληψη (λόγω του γεγονότος ότι τα range "
"αντικείμενα μπορούν να αναπαριστούν μόνο ακολουθίες που ακολουθούν ένα "
"αυστηρό μοτίβο και η επανάληψη και η συνένωση συνήθως παραβιάζουν αυτό το "
"πρότυπο)."

#: library/stdtypes.rst:1481
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr "Η τιμή της παραμέτρου *start* (ή ``0`` αν η παράμετρος δεν παρέχεται)"

#: library/stdtypes.rst:1486
msgid "The value of the *stop* parameter"
msgstr "Η τιμή της παραμέτρου *stop*"

#: library/stdtypes.rst:1490
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr "Η τιμή της παραμέτρου *step* (ή ``1`` αν η παράμετρος δεν παρέχεται)"

#: library/stdtypes.rst:1493
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or :"
"class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents (as "
"it only stores the ``start``, ``stop`` and ``step`` values, calculating "
"individual items and subranges as needed)."
msgstr ""
"Το πλεονέκτημα του τύπου :class:`range` έναντι ενός κανονικού τύπου :class:"
"`list` ή :class:`tuple` είναι ότι ένα αντικείμενο :class:`range` θα παίρνει "
"πάντα το ίδιο (μικρό) ποσό μνήμης, ανεξάρτητα από το μέγεθος του range που "
"αντιπροσωπεύει (μιας και αποθηκεύει μόνο τις τιμές ``start``, ``stop`` και "
"``step``, υπολογίζοντας τα μεμονωμένα στοιχεία και τις υποπεριοχές όπως "
"απαιτείται)."

#: library/stdtypes.rst:1499
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing "
"and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"Τα αντικείμενα range υλοποιούν την :class:`collections.abc.Sequence` ABC, "
"και παρέχουν χαρακτηριστικά όπως δοκιμές περιορισμού, αναζήτηση δείκτη "
"στοιχείου, τεμαχισμό και υποστήριξη αρνητικών δεικτών (βλ. :ref:`typesseq`):"

#: library/stdtypes.rst:1519
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them as "
"sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that "
"compare equal might have different :attr:`~range.start`, :attr:`~range.stop` "
"and :attr:`~range.step` attributes, for example ``range(0) == range(2, 1, "
"3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"Ο έλεγχος των αντικειμένων range για ισότητα με ``==`` και ``!=`` τα "
"συγκρίνει ως ακολουθίες.  Δηλαδή, δύο αντικείμενα range θεωρούνται ίσα αν "
"αντιπροσωπεύουν την ίδια ακολουθία τιμών.  (Σημειώστε ότι δύο αντικείμενα "
"range που συγκρίνονται ως ίσα μπορεί να έχουν διαφορετικά :attr:`~range."
"start`, :attr:`~range.stop` και :attr:`~range.step` χαρακτηριστικά, για "
"παράδειγμα ``range(0) == range(2, 1, 3)`` ή ``range(0, 3, 2) == range(0, 4, "
"2)``.)"

#: library/stdtypes.rst:1526
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test :"
"class:`int` objects for membership in constant time instead of iterating "
"through all items."
msgstr ""
"Υλοποιείστε την ακολουθία ABC. Υποστηρίξτε την τμηματοποίηση και τους "
"αρνητικούς δείκτες. Δοκιμάστε τα :class:`int` αντικείμενα για συμμετοχή σε "
"σταθερό χρόνο αντί της επανάληψης σε όλα τα αντικείμενα."

#: library/stdtypes.rst:1532
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"Ορίστε τα '==' και '!=' για να συγκρίνετε αντικείμενα range με βάση την "
"ακολουθία των τιμών που ορίζουν (αντί να συγκρίνουν με βάση την ταυτότητα "
"του αντικειμένου)."

#: library/stdtypes.rst:1537
msgid ""
"Added the :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ""
"Προστέθηκαν τα :attr:`~range.start`, :attr:`~range.stop` και :attr:`~range."
"step` attributes."

#: library/stdtypes.rst:1542
msgid ""
"The `linspace recipe <https://code.activestate.com/recipes/579000-equally-"
"spaced-numbers-linspace/>`_ shows how to implement a lazy version of range "
"suitable for floating-point applications."
msgstr ""
"Η συνταγή `linspace <https://code.activestate.com/recipes/579000-equally-"
"spaced-numbers-linspace/>`_ δείχνει πώς να υλοποιήσετε μια lazy έκδοση του "
"range κατάλληλη για εφαρμογές κινητής υποδιαστολής."

#: library/stdtypes.rst:1554
msgid "Text and Binary Sequence Type Methods Summary"
msgstr "Σύνοψη μεθόδων τύπου κειμένου και δυαδική ακολουθίας"

#: library/stdtypes.rst:1555
msgid ""
"The following table summarizes the text and binary sequence types methods by "
"category."
msgstr ""
"Ο παρακάτω πίνακας συνοψίζει τις μεθόδους τύπων κειμένου και δυαδική "
"ακολουθίας ανά κατηγορία."

#: library/stdtypes.rst:1560
msgid "Category"
msgstr "Κατηγορία"

#: library/stdtypes.rst:1560
msgid ":class:`str` methods"
msgstr ":class:`str` methods"

#: library/stdtypes.rst:1560
msgid ":class:`bytes` and :class:`bytearray` methods"
msgstr "οι μέθοδοι :class:`bytes` και :class:`bytearray`"

#: library/stdtypes.rst:1562
msgid "Formatting"
msgstr "Μορφοποίηση"

#: library/stdtypes.rst:1562
msgid ":meth:`str.format`"
msgstr ":meth:`str.format`"

#: library/stdtypes.rst:1564
msgid ":meth:`str.format_map`"
msgstr ":meth:`str.format_map`"

#: library/stdtypes.rst:1566
msgid ":ref:`f-strings`"
msgstr ":ref:`f-strings`"

#: library/stdtypes.rst:1568
msgid ":ref:`old-string-formatting`"
msgstr ":ref:`old-string-formatting`"

#: library/stdtypes.rst:1568
msgid ":ref:`bytes-formatting`"
msgstr ":ref:`bytes-formatting`"

#: library/stdtypes.rst:1570
msgid "Searching and Replacing"
msgstr "Αναζήτηση και Αντικατάσταση"

#: library/stdtypes.rst:1570
msgid ":meth:`str.find`"
msgstr ":meth:`str.find`"

#: library/stdtypes.rst:1570
msgid ":meth:`str.rfind`"
msgstr ":meth:`str.rfind`"

#: library/stdtypes.rst:1570
msgid ":meth:`bytes.find`"
msgstr ":meth:`bytes.find`"

#: library/stdtypes.rst:1570
msgid ":meth:`bytes.rfind`"
msgstr ":meth:`bytes.rfind`"

#: library/stdtypes.rst:1572
msgid ":meth:`str.index`"
msgstr ":meth:`str.index`"

#: library/stdtypes.rst:1572
msgid ":meth:`str.rindex`"
msgstr ":meth:`str.rindex`"

#: library/stdtypes.rst:1572
msgid ":meth:`bytes.index`"
msgstr ":meth:`bytes.index`"

#: library/stdtypes.rst:1572
msgid ":meth:`bytes.rindex`"
msgstr ":meth:`bytes.rindex`"

#: library/stdtypes.rst:1574
msgid ":meth:`str.startswith`"
msgstr ":meth:`str.startswith`"

#: library/stdtypes.rst:1574
msgid ":meth:`bytes.startswith`"
msgstr ":meth:`bytes.startswith`"

#: library/stdtypes.rst:1576
msgid ":meth:`str.endswith`"
msgstr ":meth:`str.endswith`"

#: library/stdtypes.rst:1576
msgid ":meth:`bytes.endswith`"
msgstr ":meth:`bytes.endswith`"

#: library/stdtypes.rst:1578
msgid ":meth:`str.count`"
msgstr ":meth:`str.count`"

#: library/stdtypes.rst:1578
msgid ":meth:`bytes.count`"
msgstr ":meth:`bytes.count`"

#: library/stdtypes.rst:1580
msgid ":meth:`str.replace`"
msgstr ":meth:`str.replace`"

#: library/stdtypes.rst:1580
msgid ":meth:`bytes.replace`"
msgstr ":meth:`bytes.replace`"

#: library/stdtypes.rst:1582
msgid "Splitting and Joining"
msgstr "Διαχωρισμός και Ένωση"

#: library/stdtypes.rst:1582
msgid ":meth:`str.split`"
msgstr ":meth:`str.split`"

#: library/stdtypes.rst:1582
msgid ":meth:`str.rsplit`"
msgstr ":meth:`str.rsplit`"

#: library/stdtypes.rst:1582
msgid ":meth:`bytes.split`"
msgstr ":meth:`bytes.split`"

#: library/stdtypes.rst:1582
msgid ":meth:`bytes.rsplit`"
msgstr ":meth:`bytes.rsplit`"

#: library/stdtypes.rst:1584
msgid ":meth:`str.splitlines`"
msgstr ":meth:`str.splitlines`"

#: library/stdtypes.rst:1584
msgid ":meth:`bytes.splitlines`"
msgstr ":meth:`bytes.splitlines`"

#: library/stdtypes.rst:1586
msgid ":meth:`str.partition`"
msgstr ":meth:`str.partition`"

#: library/stdtypes.rst:1586
msgid ":meth:`bytes.partition`"
msgstr ":meth:`bytes.partition`"

#: library/stdtypes.rst:1588
msgid ":meth:`str.rpartition`"
msgstr ":meth:`str.rpartition`"

#: library/stdtypes.rst:1588
msgid ":meth:`bytes.rpartition`"
msgstr ":meth:`bytes.rpartition`"

#: library/stdtypes.rst:1590
msgid ":meth:`str.join`"
msgstr ":meth:`str.join`"

#: library/stdtypes.rst:1590
msgid ":meth:`bytes.join`"
msgstr ":meth:`bytes.join`"

#: library/stdtypes.rst:1592
msgid "String Classification"
msgstr "Ταξινόμηση Συμβολοσειρών"

#: library/stdtypes.rst:1592
msgid ":meth:`str.isalpha`"
msgstr ":meth:`str.isalpha`"

#: library/stdtypes.rst:1592
msgid ":meth:`bytes.isalpha`"
msgstr ":meth:`bytes.isalpha`"

#: library/stdtypes.rst:1594
msgid ":meth:`str.isdecimal`"
msgstr ":meth:`str.isdecimal`"

#: library/stdtypes.rst:1596
msgid ":meth:`str.isdigit`"
msgstr ":meth:`str.isdigit`"

#: library/stdtypes.rst:1596
msgid ":meth:`bytes.isdigit`"
msgstr ":meth:`bytes.isdigit`"

#: library/stdtypes.rst:1598
msgid ":meth:`str.isnumeric`"
msgstr ":meth:`str.isnumeric`"

#: library/stdtypes.rst:1600
msgid ":meth:`str.isalnum`"
msgstr ":meth:`str.isalnum`"

#: library/stdtypes.rst:1600
msgid ":meth:`bytes.isalnum`"
msgstr ":meth:`bytes.isalnum`"

#: library/stdtypes.rst:1602
msgid ":meth:`str.isidentifier`"
msgstr ":meth:`str.isidentifier`"

#: library/stdtypes.rst:1604
msgid ":meth:`str.islower`"
msgstr ":meth:`str.islower`"

#: library/stdtypes.rst:1604
msgid ":meth:`bytes.islower`"
msgstr ":meth:`bytes.islower`"

#: library/stdtypes.rst:1606
msgid ":meth:`str.isupper`"
msgstr ":meth:`str.isupper`"

#: library/stdtypes.rst:1606
msgid ":meth:`bytes.isupper`"
msgstr ":meth:`bytes.isupper`"

#: library/stdtypes.rst:1608
msgid ":meth:`str.istitle`"
msgstr ":meth:`str.istitle`"

#: library/stdtypes.rst:1608
msgid ":meth:`bytes.istitle`"
msgstr ":meth:`bytes.istitle`"

#: library/stdtypes.rst:1610
msgid ":meth:`str.isspace`"
msgstr ":meth:`str.isspace`"

#: library/stdtypes.rst:1610
msgid ":meth:`bytes.isspace`"
msgstr ":meth:`bytes.isspace`"

#: library/stdtypes.rst:1612
msgid ":meth:`str.isprintable`"
msgstr ":meth:`str.isprintable`"

#: library/stdtypes.rst:1614
msgid "Case Manipulation"
msgstr "Χειρισμός υποθέσεων"

#: library/stdtypes.rst:1614
msgid ":meth:`str.lower`"
msgstr ":meth:`str.lower`"

#: library/stdtypes.rst:1614
msgid ":meth:`bytes.lower`"
msgstr ":meth:`bytes.lower`"

#: library/stdtypes.rst:1616
msgid ":meth:`str.upper`"
msgstr ":meth:`str.upper`"

#: library/stdtypes.rst:1616
msgid ":meth:`bytes.upper`"
msgstr ":meth:`bytes.upper`"

#: library/stdtypes.rst:1618
msgid ":meth:`str.casefold`"
msgstr ":meth:`str.casefold`"

#: library/stdtypes.rst:1620
msgid ":meth:`str.capitalize`"
msgstr ":meth:`str.capitalize`"

#: library/stdtypes.rst:1620
msgid ":meth:`bytes.capitalize`"
msgstr ":meth:`bytes.capitalize`"

#: library/stdtypes.rst:1622
msgid ":meth:`str.title`"
msgstr ":meth:`str.title`"

#: library/stdtypes.rst:1622
msgid ":meth:`bytes.title`"
msgstr ":meth:`bytes.title`"

#: library/stdtypes.rst:1624
msgid ":meth:`str.swapcase`"
msgstr ":meth:`str.swapcase`"

#: library/stdtypes.rst:1624
msgid ":meth:`bytes.swapcase`"
msgstr ":meth:`bytes.swapcase`"

#: library/stdtypes.rst:1626
msgid "Padding and Stripping"
msgstr "Συμπλήρωση και Αφαίρεση"

#: library/stdtypes.rst:1626
msgid ":meth:`str.ljust`"
msgstr ":meth:`str.ljust`"

#: library/stdtypes.rst:1626
msgid ":meth:`str.rjust`"
msgstr ":meth:`str.rjust`"

#: library/stdtypes.rst:1626
msgid ":meth:`bytes.ljust`"
msgstr ":meth:`bytes.ljust`"

#: library/stdtypes.rst:1626
msgid ":meth:`bytes.rjust`"
msgstr ":meth:`bytes.rjust`"

#: library/stdtypes.rst:1628
msgid ":meth:`str.center`"
msgstr ":meth:`str.center`"

#: library/stdtypes.rst:1628
msgid ":meth:`bytes.center`"
msgstr ":meth:`bytes.center`"

#: library/stdtypes.rst:1630
msgid ":meth:`str.expandtabs`"
msgstr ":meth:`str.expandtabs`"

#: library/stdtypes.rst:1630
msgid ":meth:`bytes.expandtabs`"
msgstr ":meth:`bytes.expandtabs`"

#: library/stdtypes.rst:1632
msgid ":meth:`str.strip`"
msgstr ":meth:`str.strip`"

#: library/stdtypes.rst:1632
msgid ":meth:`bytes.strip`"
msgstr ":meth:`bytes.strip`"

#: library/stdtypes.rst:1634
msgid ":meth:`str.lstrip`"
msgstr ":meth:`str.lstrip`"

#: library/stdtypes.rst:1634
msgid ":meth:`str.rstrip`"
msgstr ":meth:`str.rstrip`"

#: library/stdtypes.rst:1634
msgid ":meth:`bytes.lstrip`"
msgstr ":meth:`bytes.lstrip`"

#: library/stdtypes.rst:1634
msgid ":meth:`bytes.rstrip`"
msgstr ":meth:`bytes.rstrip`"

#: library/stdtypes.rst:1636
msgid "Translation and Encoding"
msgstr "Μετάφραση και Κωδικοποίηση"

#: library/stdtypes.rst:1636
msgid ":meth:`str.translate`"
msgstr ":meth:`str.translate`"

#: library/stdtypes.rst:1636
msgid ":meth:`bytes.translate`"
msgstr ":meth:`bytes.translate`"

#: library/stdtypes.rst:1638
msgid ":meth:`str.maketrans`"
msgstr ":meth:`str.maketrans`"

#: library/stdtypes.rst:1638
msgid ":meth:`bytes.maketrans`"
msgstr ":meth:`bytes.maketrans`"

#: library/stdtypes.rst:1640
msgid ":meth:`str.encode`"
msgstr ":meth:`str.encode`"

#: library/stdtypes.rst:1642
msgid ":meth:`bytes.decode`"
msgstr ":meth:`bytes.decode`"

#: library/stdtypes.rst:1648
msgid "Text Sequence Type --- :class:`str`"
msgstr "Τύπος Ακολουθίας (Sequence) Κειμένου --- :class:`str`"

#: library/stdtypes.rst:1650
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points.  String literals are written in a variety of ways:"
msgstr ""
"Τα δεδομένα κειμένου στην Python αντιμετωπίζονται με αντικείμενα :class:"
"`str` ή :dfn:`strings`. Τα αλφαριθμητικά (strings) είναι αμετάβλητες :ref:"
"`sequences <typesseq>` των Unicode points.  Τα αλφαριθμητικά γράφονται με "
"διάφορους τρόπους:"

#: library/stdtypes.rst:1655
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "Απλά εισαγωγικά: ``'allows embedded \"double\" quotes'``"

#: library/stdtypes.rst:1656
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``"
msgstr "Διπλά εισαγωγικά: ``'allows embedded \"double\" quotes'``"

#: library/stdtypes.rst:1657
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"
msgstr ""
"Τριπλά εισαγωγικά: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"

#: library/stdtypes.rst:1659
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace "
"will be included in the string literal."
msgstr ""
"Τα αλφαριθμητικά σε τριπλά εισαγωγικά μπορούν να καλύπτουν πολλές γραμμές - "
"όλα τα σχετικά κενά θα συμπεριληφθούν στο αλφαριθμητικό."

#: library/stdtypes.rst:1662
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"Τα Αλφαριθμητικά (strings) που αποτελούν μέρος μιας ενιαίας έκφρασης και "
"έχουν μόνο κενά μεταξύ τους, θα μετατραπούν σιωπηρά σε ένα ενιαίο "
"αλφαριθμητικό literal. Δηλαδή, ``(\"spam \" \"eggs\") == \"spam eggs\"``."

#: library/stdtypes.rst:1666
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported :ref:`escape sequences <escape-sequences>`, and the "
"``r`` (\"raw\") prefix that disables most escape sequence processing."
msgstr ""
"Δείτε τα :ref:`strings` για περισσότερες πληροφορίες σχετικά με τις διάφορες "
"μορφές των αλφαριθμητικών, συμπεριλαμβανομένων των υποστηριζόμενων "
"ακολουθιών :ref:`escape sequences <escape-sequences>`, και του ``r`` "
"(\"raw\") πρόθεμα που απενεργοποιεί την επεξεργασία των περισσότερων "
"ακολουθιών διαφυγής."

#: library/stdtypes.rst:1670
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr ""
"Τα αλφαριθμητικά (strings) μπορούν επίσης να δημιουργηθούν από άλλα "
"αντικείμενα χρησιμοποιώντας τον constructor :class:`str`."

#: library/stdtypes.rst:1673
msgid ""
"Since there is no separate \"character\" type, indexing a string produces "
"strings of length 1. That is, for a non-empty string *s*, ``s[0] == s[0:1]``."
msgstr ""
"Εφόσον δεν υπάρχει ξεχωριστός τύπος \"character\", το indexing μιας "
"συμβολοσειράς (string) παράγει συμβολοσειρές μήκους 1. Δηλαδή, για μια μη "
"κενή συμβολοσειρά *s*, ``s[0] == s[0:1]``."

#: library/stdtypes.rst:1679
msgid ""
"There is also no mutable string type, but :meth:`str.join` or :class:`io."
"StringIO` can be used to efficiently construct strings from multiple "
"fragments."
msgstr ""
"Δεν υπάρχει επίσης μεταβλητός τύπος συμβολοσειράς (string), αλλά το :meth:"
"`str.join` ή το :class:`io.StringIO` μπορεί να χρησιμοποιηθεί για την "
"αποτελεσματική κατασκευή συμβολοσειρών από πολλαπλά μέρη."

#: library/stdtypes.rst:1683
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is "
"once again permitted on string literals. It has no effect on the meaning of "
"string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"Για συμβατότητα προς τα πίσω (backwards compatibility) με τη σειρά Python 2, "
"το πρόθεμα ``u`` είναι επιτρεπτό και πάλι σε αλφαριθμητικά. Δεν έχει καμία "
"επίδραση στη σημασία των αλφαριθμητικών και δεν μπορεί να συνδυαστεί με το "
"πρόθεμα ``r``."

#: library/stdtypes.rst:1695
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not "
"provided, returns the empty string.  Otherwise, the behavior of ``str()`` "
"depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"Επιστρέφει μια έκδοση :ref:`string <textseq>` του *object*.  Αν το *object* "
"δεν παρέχεται, επιστρέφει κενό αλφαριθμητικό.  Διαφορετικά, η συμπεριφορά "
"της ``str()`` εξαρτάται από το αν δίνεται *encoding* ή *errors*, ως εξής."

#: library/stdtypes.rst:1699
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns :meth:"
"`type(object).__str__(object) <object.__str__>`, which is the \"informal\" "
"or nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a :meth:`~object."
"__str__` method, then :func:`str` falls back to returning :func:"
"`repr(object) <repr>`."
msgstr ""
"Αν δεν έχει δοθεί ούτε *encoding* ούτε *errors*, το ``str(object)`` "
"επιστρέφει :meth:`type(object).__str__(object) <object.__str__>`, το οποίο "
"είναι το \"informal\" ή ωραία εκτυπώσιμη αναπαράσταση συμβολοσειράς (string) "
"του *object*.  Για αντικείμενα συμβολοσειράς, είναι η ίδια η συμβολοσειρά.  "
"Εάν το *object* δεν έχει την :meth:`~object.__str__`, τότε η :func:`str` "
"επιστρέφει τη μέθοδο :func:`repr(object) <repr>`."

#: library/stdtypes.rst:1711
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a :"
"term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  In "
"this case, if *object* is a :class:`bytes` (or :class:`bytearray`) object, "
"then ``str(bytes, encoding, errors)`` is equivalent to :meth:`bytes."
"decode(encoding, errors) <bytes.decode>`.  Otherwise, the bytes object "
"underlying the buffer object is obtained before calling :meth:`bytes."
"decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for information on "
"buffer objects."
msgstr ""
"Εάν δίνεται τουλάχιστον ένα από τα *encoding* ή *errors*, το *object* θα "
"πρέπει να είναι ένα :term:`bytes-like object` (π.χ. :class:`bytes` ή :class:"
"`bytearray`).  Σε αυτή την περίπτωση, αν το *object* είναι ένα αντικείμενο :"
"class:`bytes` (ή :class:`bytearray`), τότε το ``str(bytes, encoding, "
"errors)`` είναι ισοδύναμο με το :meth:`bytes.decode(encoding, errors) <bytes."
"decode>`.  Διαφορετικά, το αντικείμενο bytes που υποκρύπτει το αντικείμενο "
"buffer λαμβάνεται πριν από την κλήση του :meth:`bytes.decode`.  Δείτε :ref:"
"`binaryseq` και :ref:`bufferobjects` για πληροφορίες σχετικά με τα "
"αντικείμενα buffer."

#: library/stdtypes.rst:1720
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"Πέρασμα ενός αντικειμένου :class:`bytes` στο :func:`str` χωρίς το *encoding* "
"ή το *errors* ορίσματα εμπίπτει στην πρώτη περίπτωση επιστροφής της άτυπης "
"αναπαράστασης συμβολοσειράς (string) (δείτε επίσης την επιλογή :option:`-b` "
"της γραμμής εντολών για Python).  Για παράδειγμα::"

#: library/stdtypes.rst:1725
msgid ""
">>> str(b'Zoot!')\n"
"\"b'Zoot!'\""
msgstr ""
">>> str(b'Zoot!')\n"
"\"b'Zoot!'\""

#: library/stdtypes.rst:1728
msgid ""
"For more information on the ``str`` class and its methods, see :ref:"
"`textseq` and the :ref:`string-methods` section below.  To output formatted "
"strings, see the :ref:`f-strings` and :ref:`formatstrings` sections.  In "
"addition, see the :ref:`stringservices` section."
msgstr ""
"Για περισσότερες πληροφορίες σχετικά με την κλάση ``str`` και τις μεθόδους "
"της, δείτε :ref:`textseq` και την ενότητα :ref:`string-methods` παρακάτω.  "
"Για την παραγωγή μορφοποιημένων συμβολοσειρών (string), ανατρέξτε στις "
"ενότητες :ref:`f-strings` και :ref:`formatstrings`.  Επιπλέον, δείτε την "
"ενότητα :ref:`stringservices`."

#: library/stdtypes.rst:1740
msgid "String Methods"
msgstr "Μέθοδοι Συμβολοσειράς (String)"

#: library/stdtypes.rst:1745
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"Οι συμβολοσειρές (string) υλοποιούν όλες τις λειτουργίες των :ref:`common "
"<typesseq-common>` ακολουθιών, μαζί με τις πρόσθετες μεθόδους που "
"περιγράφονται παρακάτω."

#: library/stdtypes.rst:1748
msgid ""
"Strings also support two styles of string formatting, one providing a large "
"degree of flexibility and customization (see :meth:`str.format`, :ref:"
"`formatstrings` and :ref:`string-formatting`) and the other based on C "
"``printf`` style formatting that handles a narrower range of types and is "
"slightly harder to use correctly, but is often faster for the cases it can "
"handle (:ref:`old-string-formatting`)."
msgstr ""
"Οι συμβολοσειρές (string) υποστηρίζουν επίσης δύο στυλ μορφοποίησης "
"συμβολοσειρών, το ένα παρέχει ένα μεγάλο βαθμό ευελιξίας και προσαρμογής "
"(βλέπε :meth:`str.format`, :ref:`formatstrings` και :ref:`string-"
"formatting`) και το άλλο βασίζεται στο στυλ μορφοποίησης ``printf`` της C "
"που χειρίζεται ένα στενότερο εύρος τύπων και είναι λίγο πιο δύσκολο να "
"χρησιμοποιηθεί σωστά, αλλά είναι συχνά ταχύτερο για τις περιπτώσεις που "
"μπορεί να χειριστεί (:ref:`old-string-formatting`)."

#: library/stdtypes.rst:1755
msgid ""
"The :ref:`textservices` section of the standard library covers a number of "
"other modules that provide various text related utilities (including regular "
"expression support in the :mod:`re` module)."
msgstr ""
"Το τμήμα :ref:`textservices` της πρότυπης βιβλιοθήκης καλύπτει έναν αριθμό "
"από άλλες ενότητες που παρέχουν διάφορες βοηθητικές υπηρεσίες που "
"σχετίζονται με το κείμενο (συμπεριλαμβανομένης της υποστήριξης των κανονικών "
"εκφράσεων στην ενότητα :mod:`re`)."

#: library/stdtypes.rst:1761
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""
"Επιστρέφει ένα αντίγραφο της συμβολοσειράς (string) με τον πρώτο χαρακτήρα "
"κεφαλαίο και τα υπόλοιπα με πεζά γράμματα."

#: library/stdtypes.rst:1764
msgid ""
"The first character is now put into titlecase rather than uppercase. This "
"means that characters like digraphs will only have their first letter "
"capitalized, instead of the full character."
msgstr ""
"Ο πρώτος χαρακτήρας τίθεται τώρα σε titlecase αντί για uppercase. Αυτό "
"σημαίνει ότι χαρακτήρες όπως οι διγράφοι (digraphs) θα έχουν μόνο το πρώτο "
"γράμμα τους με κεφαλαίο, αντί για όλους τους χαρακτήρες."

#: library/stdtypes.rst:1771
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used for "
"caseless matching."
msgstr ""
"Επιστρέφει ένα αντίγραφο της συμβολοσειράς (string) σε casefolded μορφή. Οι "
"casefolded συμβολοσειρές μπορούν να χρησιμοποιηθούν για caseless matching."

#: library/stdtypes.rst:1774
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; :meth:"
"`casefold` converts it to ``\"ss\"``."
msgstr ""
"Το casefolding είναι παρόμοιο με το lowercasing αλλά πιο επιθετικό επειδή "
"έχει ως στόχο να αφαιρέσει όλες τις διακρίσεις της πεζότητας σε μια "
"συμβολοσειρά (string). Για παράδειγμα, το γερμανικό πεζό γράμμα ``'ß'`` "
"ισοδυναμεί με ``\"ss\"``. Αφού είναι ήδη πεζό, η :meth:`lower` δεν θα έκανε "
"τίποτα στο ``'ß'``· η :meth:`casefold` το μετατρέπει σε ``\"ss\"``."

#: library/stdtypes.rst:1780
msgid ""
"The casefolding algorithm is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode16.0.0/core-spec/chapter-3/#G33992>`__."
msgstr ""
"Ο αλγόριθμος casefolding `περιγράφεται στην ενότητα 3.13 'Default Case "
"Folding' του προτύπου Unicode <https://www.unicode.org/versions/"
"Unicode16.0.0/core-spec/chapter-3/#G33992>`__."

#: library/stdtypes.rst:1789
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Επιστρέφει ένα κεντραρισμένο σε μια συμβολοσειρά (string) μήκους *πλάτος*. "
"Το padding γίνεται με τη χρήση του καθορισμένου *fillchar* (το default είναι "
"ένα κενό ASCII). Η αρχική συμβολοσειρά επιστρέφεται εάν το *width* είναι "
"μικρότερο ή ίσο με το ``len(s)``."

#: library/stdtypes.rst:1797
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Επιστρέφει τον αριθμό των μη επικαλυπτόμενων (non-overalpping) εμφανίσεων "
"της υποομάδας *sub* στο εύρος [*start*, *end*].  Τα προαιρετικά ορίσματα "
"*start* και *end* ερμηνεύονται όπως στο slice notation."

#: library/stdtypes.rst:1801
msgid ""
"If *sub* is empty, returns the number of empty strings between characters "
"which is the length of the string plus one."
msgstr ""
"Αν το *sub* είναι κενό, επιστρέφει τον αριθμό των κενών συμβολοσειρών "
"(strings) μεταξύ των χαρακτήρων που είναι το μήκος της συμβολοσειράς συν ένα."

#: library/stdtypes.rst:1807
msgid "Return the string encoded to :class:`bytes`."
msgstr "Επιστρέφει την συμβολοσειρά (string) κωδικοποιημένη σε :class:`bytes`."

#: library/stdtypes.rst:3146
msgid ""
"*encoding* defaults to ``'utf-8'``; see :ref:`standard-encodings` for "
"possible values."
msgstr ""
"το *encoding* έχει default σε ``'utf-8'``- δείτε :ref:`standard-encodings` "
"για πιθανές τιμές."

#: library/stdtypes.rst:1812
msgid ""
"*errors* controls how encoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` and any other name registered via :func:`codecs."
"register_error`. See :ref:`error-handlers` for details."
msgstr ""
"το *errors* ελέγχει τον τρόπο χειρισμού των σφαλμάτων κωδικοποίησης. Εάν "
"είναι ``'strict'`` (το default), τότε γίνεται raise μια εξαίρεση :exc:"
"`UnicodeError`. Άλλες πιθανές τιμές είναι τα ``'ignore'``, ``'replace'``, "
"``'xmlcharrefreplace'``, ``'backslashreplace'`` και οποιοδήποτε άλλο όνομα "
"που έχει καταχωρηθεί μέσω του :func:`codecs.register_error`. Δείτε το :ref:"
"`error-handlers` για λεπτομέρειες."

#: library/stdtypes.rst:1819
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless an encoding error actually occurs, :ref:`devmode` is enabled or a :"
"ref:`debug build <debug-build>` is used."
msgstr ""
"Για λόγους απόδοσης, η τιμή των *errors* δεν ελέγχεται ως προς την "
"εγκυρότητα εκτός αν όντως προκύψει σφάλμα κωδικοποίησης, αν το :ref:"
"`devmode` είναι ενεργοποιημένο ή αν ένα :ref:`debug build <debug-build>` "
"χρησιμοποιείται."

#: library/stdtypes.rst:3165
msgid "Added support for keyword arguments."
msgstr "Επιπρόσθετη υποστήριξη για keyword ορίσματα."

#: library/stdtypes.rst:3168
msgid ""
"The value of the *errors* argument is now checked in :ref:`devmode` and in :"
"ref:`debug mode <debug-build>`."
msgstr ""
"Η τιμή του όρου *errors* ελέγχεται τώρα στο :ref:`devmode` και στο :ref:"
"`debug mode <debug-build>`."

#: library/stdtypes.rst:1834
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"Επιστρέφει ``True`` αν η συμβολοσειρά (string) τελειώνει με το καθορισμένο "
"*suffix*, αλλιώς επιστρέφει ``False``.  Το *suffix* μπορεί επίσης να είναι "
"ένα tuple (πλειάδα) από επιθέματα που πρέπει να αναζητηθούν.  Με το "
"προαιρετικό *start*, το τεστ αρχίζει από αυτή τη θέση.  Με το προαιρετικό "
"*end*, η σύγκριση σταματά σε αυτή τη θέση."

#: library/stdtypes.rst:1842
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current "
"column is set to zero and the string is examined character by character.  If "
"the character is a tab (``\\t``), one or more space characters are inserted "
"in the result until the current column is equal to the next tab position. "
"(The tab character itself is not copied.)  If the character is a newline "
"(``\\n``) or return (``\\r``), it is copied and the current column is reset "
"to zero.  Any other character is copied unchanged and the current column is "
"incremented by one regardless of how the character is represented when "
"printed."
msgstr ""
"Επιστρέφει ένα αντίγραφο της συμβολοσειράς (string) όπου όλοι οι χαρακτήρες "
"tab αντικαθίστανται από έναν ή περισσότερα κενά, ανάλογα με την τρέχουσα "
"στήλη και το δεδομένο μέγεθος των tabs.  Οι θέσεις tab εμφανίζονται κάθε "
"*tabsize* χαρακτήρες (το default είναι 8, δίνοντας tab θέσεις στις στήλες 0, "
"8, 16 κ.ο.κ.).  Για την επέκταση της συμβολοσειράς, η τρέχουσα στήλη "
"μηδενίζεται και η συμβολοσειρά εξετάζεται χαρακτήρας προς χαρακτήρα.  Εάν ο "
"χαρακτήρας είναι tab (``\\t``), εισάγονται ένας ή περισσότεροι χαρακτήρες "
"κενών στο αποτέλεσμα μέχρι η τρέχουσα στήλη να είναι ίση με την επόμενη θέση "
"tab. (Ο ίδιος ο χαρακτήρας tab δεν αντιγράφεται.) Εάν ο χαρακτήρας είναι νέα "
"γραμμή (``\\n``) ή return (``\\r``), αντιγράφεται και η τρέχουσα στήλη "
"επαναφέρεται στο μηδέν.  Οποιοσδήποτε άλλος χαρακτήρας αντιγράφεται "
"αμετάβλητος και η τρέχουσα στήλη αυξάνεται κατά ένα, ανεξάρτητα από τον "
"τρόπο αναπαράστασης του χαρακτήρα όταν τυπώνεται."

#: library/stdtypes.rst:1863
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"Επιστρέφει τον χαμηλότερο δείκτη στη συμβολοσειρά (string) όπου η υπό-"
"συμβολοσειρά *sub* βρίσκεται μέσα στο υποσύνολο (slice) ``s[start:end]``.  "
"Τα προαιρετικά ορίσματα *start* και *end* ερμηνεύονται όπως στο notation του "
"υποσυνόλου.  Επιστρέφει ``-1`` αν δεν βρεθεί το *sub*."

#: library/stdtypes.rst:1869
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"Η μέθοδος :meth:`~str.find` θα πρέπει να χρησιμοποιείται μόνο αν πρέπει να "
"γνωρίζετε τη θέση του *sub*.  Για να ελέγξετε αν το *sub* είναι υποσύνολο ή "
"όχι, χρησιμοποιήστε τον τελεστή :keyword:`in`::"

#: library/stdtypes.rst:1873
msgid ""
">>> 'Py' in 'Python'\n"
"True"
msgstr ""
">>> 'Py' in 'Python'\n"
"True"

#: library/stdtypes.rst:1879
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""
"Εκτέλεση μιας λειτουργίας μορφοποίησης συμβολοσειράς (string formatting).  Η "
"συμβολοσειρά στην οποία αυτή η μέθοδος καλείται μπορεί να περιέχει "
"κυριολεκτικό κείμενο ή πεδία αντικατάστασης που οριοθετούνται από αγκύλες "
"``{}``.  Κάθε πεδίο αντικατάστασης περιέχει είτε τον αριθμητικό δείκτη ενός "
"ορίσματος θέσης, είτε το όνομα ενός keyword ορίσματος.  Επιστρέφει ένα "
"αντίγραφο της συμβολοσειράς όπου κάθε πεδίο αντικατάστασης αντικαθίσταται με "
"την τιμή της συμβολοσειράς του αντίστοιχου ορίσματος."

#: library/stdtypes.rst:1889
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""
"Δείτε το :ref:`formatstrings` για μια περιγραφή των διαφόρων επιλογών "
"μορφοποίησης που μπορούν να καθοριστούν στην μορφοποίηση συμβολοσειρών "
"(format strings)."

#: library/stdtypes.rst:1893
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`complex`, :"
"class:`decimal.Decimal` and subclasses) with the ``n`` type (ex: ``'{:n}'."
"format(1234)``), the function temporarily sets the ``LC_CTYPE`` locale to "
"the ``LC_NUMERIC`` locale to decode ``decimal_point`` and ``thousands_sep`` "
"fields of :c:func:`localeconv` if they are non-ASCII or longer than 1 byte, "
"and the ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale.  "
"This temporary change affects other threads."
msgstr ""
"Κατά τη μορφοποίηση ενός αριθμού (:class:`int`, :class:`float`, :class:"
"`complex`, :class:`decimal.Decimal` και υποκλάσεις) με τον τύπο ``n`` (π.χ.: "
"``'{:n}'.format(1234)``, η συνάρτηση θέτει προσωρινά την τοποθεσία "
"``LC_CTYPE`` στην τοποθεσία ``LC_NUMERIC`` για την αποκωδικοποίηση των "
"``decimal_point`` και ``thousands_sep`` πεδίων του :c:func:`localeconv` αν "
"είναι μη ASCII ή μεγαλύτερα από 1 byte, και το locale ``LC_NUMERIC`` είναι "
"διαφορετικό από το locale ``LC_CTYPE``.  Αυτή η προσωρινή αλλαγή επηρεάζει "
"και άλλα νήματα (threads)."

#: library/stdtypes.rst:1902
msgid ""
"When formatting a number with the ``n`` type, the function sets temporarily "
"the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some cases."
msgstr ""
"Κατά τη μορφοποίηση ενός αριθμού με τον τύπο ``n``, η συνάρτηση θέτει "
"προσωρινά το locale ``LC_CTYPE`` στο locale ``LC_NUMERIC`` σε κάποιες "
"περιπτώσεις."

#: library/stdtypes.rst:1910
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""
"Παρόμοιο με το ``str.format(**mapping)``, εκτός από το ότι χρησιμοποιείται "
"το ``mapping`` απευθείας και δεν αντιγράφεται σε μια :class:`dict`.  Αυτό "
"είναι χρήσιμο αν για παράδειγμα το ``mapping`` είναι μια υποκλάση του dict:"

#: library/stdtypes.rst:1926
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is "
"not found."
msgstr ""
"Όπως η :meth:`~str.find`, αλλά κάνει raise :exc:`ValueError` όταν η υπό-"
"συμβολοσειρά (substring) δεν έχει βρεθεί."

#: library/stdtypes.rst:1932
msgid ""
"Return ``True`` if all characters in the string are alphanumeric and there "
"is at least one character, ``False`` otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, ``c."
"isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"Επιστρέφει ``True`` αν όλοι οι χαρακτήρες στη συμβολοσειρά (string) είναι "
"αλφαριθμητικοί και υπάρχει τουλάχιστον ένας χαρακτήρας, διαφορετικά "
"``False``.  Ένας χαρακτήρας ``c`` είναι αλφαριθμητικό εάν ένα από τα "
"ακόλουθα επιστρέφει ``True``: ``c.isalpha()``, ``c.isdecimal()``, ``c."
"isdigit()``, ή ``c.isnumeric()``."

#: library/stdtypes.rst:1940
msgid ""
"Return ``True`` if all characters in the string are alphabetic and there is "
"at least one character, ``False`` otherwise.  Alphabetic characters are "
"those characters defined in the Unicode character database as \"Letter\", i."
"e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the `Alphabetic "
"property defined in the section 4.10 'Letters, Alphabetic, and Ideographic' "
"of the Unicode Standard <https://www.unicode.org/versions/Unicode16.0.0/core-"
"spec/chapter-4/#G91002>`_."
msgstr ""
"Επιστρέφει ``True`` αν όλοι οι χαρακτήρες στη συμβολοσειρά (string) είναι "
"αλφαβητικοί και υπάρχει τουλάχιστον ένας χαρακτήρας, διαφορετικά ``False``.  "
"Οι αλφαβητικοί χαρακτήρες είναι χαρακτήρες που ορίζονται στη βάση δεδομένων "
"χαρακτήρων Unicode ως \"Letter\", δηλαδή, εκείνοι με General Category "
"ιδιότητα μία από τα \"Lm\", \"Lt\", \"Lu\", \"Ll\", ή \"Lo\".  Σημειώστε ότι "
"αυτό είναι διαφορετικό από το `Αλφαβητικό που ορίζεται στην ενότητα 4.10 "
"'Letters, Alphabetic, and Ideographic' του προτύπου Unicode <https://www."
"unicode.org/versions/Unicode16.0.0/core-spec/chapter-4/#G91002>`_."

#: library/stdtypes.rst:1951
msgid ""
"Return ``True`` if the string is empty or all characters in the string are "
"ASCII, ``False`` otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""
"Επιστρέφει ``True`` εάν η συμβολοσειρά (string) είναι κενή ή όλοι οι "
"χαρακτήρες της συμβολοσειράς είναι ASCII, αλλιώς ``False``. Οι χαρακτήρες "
"ASCII έχουν σημεία κωδικοποίησης στην περιοχή U+0000-U+007F."

#: library/stdtypes.rst:1960
msgid ""
"Return ``True`` if all characters in the string are decimal characters and "
"there is at least one character, ``False`` otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO.  Formally a decimal character is a character in the Unicode "
"General Category \"Nd\"."
msgstr ""
"Επιστρέφει ``True`` αν όλοι οι χαρακτήρες στη συμβολοσειρά (string) είναι "
"δεκαδικοί χαρακτήρες και υπάρχει τουλάχιστον ένας χαρακτήρας, διαφορετικά "
"``False``. Οι δεκαδικοί χαρακτήρες είναι αυτοί που μπορούν να "
"χρησιμοποιηθούν για το σχηματισμό αριθμών στη βάση 10, π.χ. U+0660, ARABIC-"
"INDIC DIGIT ZERO.  Επίσημα ένας δεκαδικός χαρακτήρας είναι ένας χαρακτήρας "
"του Unicode General Category \"Nd\"."

#: library/stdtypes.rst:1970
msgid ""
"Return ``True`` if all characters in the string are digits and there is at "
"least one character, ``False`` otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility superscript "
"digits. This covers digits which cannot be used to form numbers in base 10, "
"like the Kharosthi numbers.  Formally, a digit is a character that has the "
"property value Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""
"Επιστρέφει ``True`` αν όλοι οι χαρακτήρες στη συμβολοσειρά είναι ψηφία και "
"υπάρχει τουλάχιστον ένας χαρακτήρας, διαφορετικά ``False``.  Τα ψηφία "
"περιλαμβάνουν δεκαδικούς χαρακτήρες και ψηφία που χρειάζονται ειδικό "
"χειρισμό, όπως τα compatibility superscript ψηφία. Αυτό καλύπτει τα ψηφία "
"που δεν μπορούν να χρησιμοποιηθούν για το σχηματισμό αριθμών στη βάση 10, "
"όπως οι αριθμοί Kharosthi.  Τυπικά, ένα ψηφίο είναι ένας χαρακτήρας που έχει "
"την τιμή της ιδιότητας Numeric_Type=Digit ή Numeric_Type=Decimal."

#: library/stdtypes.rst:1980
msgid ""
"Return ``True`` if the string is a valid identifier according to the "
"language definition, section :ref:`identifiers`."
msgstr ""
"Επιστρέφει ``True`` αν η συμβολοσειρά είναι έγκυρο αναγνωριστικό σύμφωνα με "
"το ορισμό της γλώσσας, ενότητα :ref:`identifiers`."

#: library/stdtypes.rst:1983
msgid ""
":func:`keyword.iskeyword` can be used to test whether string ``s`` is a "
"reserved identifier, such as :keyword:`def` and :keyword:`class`."
msgstr ""
"το :func:`keyword.iskeyword` μπορεί να χρησιμοποιηθεί για να ελέγξει αν η "
"συμβολοσειρά ``s`` είναι ένα δεσμευμένο αναγνωριστικό, όπως τα :keyword:"
"`def` και :keyword:`class`."

#: library/stdtypes.rst:1986
msgid "Example: ::"
msgstr "Παράδειγμα ::"

#: library/stdtypes.rst:1989
msgid ""
">>> from keyword import iskeyword\n"
"\n"
">>> 'hello'.isidentifier(), iskeyword('hello')\n"
"(True, False)\n"
">>> 'def'.isidentifier(), iskeyword('def')\n"
"(True, True)"
msgstr ""
">>> from keyword import iskeyword\n"
"\n"
">>> 'hello'.isidentifier(), iskeyword('hello')\n"
"(True, False)\n"
">>> 'def'.isidentifier(), iskeyword('def')\n"
"(True, True)"

#: library/stdtypes.rst:1999
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Επιστρέφει ``True`` αν όλοι οι χαρακτήρες [4]_ στο αλφαριθμητικό (string) "
"είναι πεζοί και υπάρχει τουλάχιστον ένας cased χαρακτήρας, αλλιώς ``False``."

#: library/stdtypes.rst:2005
msgid ""
"Return ``True`` if all characters in the string are numeric characters, and "
"there is at least one character, ``False`` otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode numeric "
"value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"Επιστρέφει ``True`` αν όλοι οι χαρακτήρες στη συμβολοσειρά είναι αριθμητικοί "
"(numeric) χαρακτήρες, και υπάρχει τουλάχιστον ένας χαρακτήρας, διαφορετικά "
"``False``. Οι αριθμητικοί χαρακτήρες περιλαμβάνουν ψηφιακούς χαρακτήρες και "
"όλους τους χαρακτήρες που έχουν την αριθμητική τιμή, π.χ. U+2155, VULGAR "
"FRACTION ONE FIFTH.  Τυπικά, οι αριθμητικοί χαρακτήρες είναι εκείνοι με την "
"τιμή της ιδιότητας Numeric_Type=Digit, Numeric_Type=Decimal ή "
"Numeric_Type=Numeric."

#: library/stdtypes.rst:2015
msgid ""
"Return ``True`` if all characters in the string are printable, ``False`` if "
"it contains at least one non-printable character."
msgstr ""
"Επιστρέφει ``True`` αν όλοι οι χαρακτήρες στη συμβολοσειρά μπορούν να "
"εκτυπωθούν, ``False`` εάν περιέχει τουλάχιστον έναν μη εκτυπώσιμο χαρακτήρα."

#: library/stdtypes.rst:2018
msgid ""
"Here \"printable\" means the character is suitable for :func:`repr` to use "
"in its output; \"non-printable\" means that :func:`repr` on built-in types "
"will hex-escape the character.  It has no bearing on the handling of strings "
"written to :data:`sys.stdout` or :data:`sys.stderr`."
msgstr ""
"Εδώ \"εκτυπώσιμος\" σημαίνει ότι ο χαρακτήρας είναι κατάλληλος για την :func:"
"`repr` για χρήση στην έξοδο του∙ το \"μη εκτυπώσιμος\" σημαίνει ότι ο "
"χαρακτήρας στη :func:`repr` στους ενσωματωμένους τύπους θα διαφεύγει "
"εξαγωνικά από τον χαρακτήρα. Δεν έχει καμία σχέση με τον χειρισμό "
"συμβολοσειρών που γράφονται σε :data:`sys.stdout` ή :data:`sys.stderr`."

#: library/stdtypes.rst:2023
msgid ""
"The printable characters are those which in the Unicode character database "
"(see :mod:`unicodedata`) have a general category in group Letter, Mark, "
"Number, Punctuation, or Symbol (L, M, N, P, or S); plus the ASCII space "
"0x20. Nonprintable characters are those in group Separator or Other (Z or "
"C), except the ASCII space."
msgstr ""
"Οι εκτυπώσιμοι χαρακτήρες είναι αυτοί που στη βάση δεδομένων χαρακτήρων "
"Unicode (βλ. :mod:`unicodedata`) έχουν μια γενική κατηγορία στην ομάδα "
"Γράμμα, Σήμα, Αριθμός, Σημεία στίξης ή Σύμβολο (L, M, N, P ή S), συν το "
"διάστημα ASCII 0x20. Οι μη εκτυπώσιμοι χαρακτήρες είναι αυτοί που βρίσκονται "
"στο χώρο Διαχωρισμού ομάδας ή Άλλο (Z ή CII)."

#: library/stdtypes.rst:2032
msgid ""
"Return ``True`` if there are only whitespace characters in the string and "
"there is at least one character, ``False`` otherwise."
msgstr ""
"Επιστρέφει ``True`` αν υπάρχουν μόνο χαρακτήρες κενού (whitespace) στο "
"αλφαριθμητικό (string) και υπάρχει τουλάχιστον ένας χαρακτήρας, διαφορετικά "
"``False``."

#: library/stdtypes.rst:2035
msgid ""
"A character is *whitespace* if in the Unicode character database (see :mod:"
"`unicodedata`), either its general category is ``Zs`` (\"Separator, "
"space\"), or its bidirectional class is one of ``WS``, ``B``, or ``S``."
msgstr ""
"Ένας χαρακτήρας είναι *whitespace* εάν στη βάση δεδομένων χαρακτήρων Unicode "
"(βλέπε :mod:`unicodedata`), είτε η γενική κατηγορία του είναι ``Zs`` "
"(\"Separator, space\"), είτε η αμφίδρομη κατηγορία του είναι μία από τις "
"κατηγορίες ``WS``, ``B``, ή ``S``."

#: library/stdtypes.rst:2043
msgid ""
"Return ``True`` if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return ``False`` "
"otherwise."
msgstr ""
"Επιστρέφει ``True`` αν η συμβολοσειρά (string) είναι μια titlecased "
"συμβολοσειρά και υπάρχει τουλάχιστον ένας χαρακτήρας, για παράδειγμα, οι "
"κεφαλαίοι χαρακτήρες μπορούν να ακολουθούν μόνο τους uncased χαρακτήρες και "
"οι πεζοί χαρακτήρες μόνο cased χαρακτήρες.  Διαφορετικά, επιστρέφει "
"``False``."

#: library/stdtypes.rst:2050
msgid ""
"Return ``True`` if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, ``False`` otherwise."
msgstr ""
"Επιστρέφει ``True`` αν όλοι οι χαρακτήρες [4]_ στο αλφαριθμητικό είναι "
"κεφαλαίοι και υπάρχει τουλάχιστον ένας cased χαρακτήρας, διαφορετικά "
"``False``."

#: library/stdtypes.rst:2068
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. A :"
"exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"Επιστρέφει μια συμβολοσειρά (string) που είναι η συνένωση των συμβολοσειρών "
"στο *iterable*. Ένα :exc:`TypeError` θα γίνει raise αν υπάρχουν τιμές μη "
"συμβολοσειράς (non-string) στο *iterable*, συμπεριλαμβανομένων των "
"αντικειμένων :class:`bytes`.  Το διαχωριστικό μεταξύ των στοιχείων είναι η "
"συμβολοσειρά που παρέχει αυτή η μέθοδος."

#: library/stdtypes.rst:2076
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Επιστρέφει τη συμβολοσειρά (string) με αριστερή ευθυγράμμιση σε μια "
"συμβολοσειρά μήκους *width*. Το padding γίνεται με τη χρήση του καθορισμένου "
"*fillchar* (το default είναι ένα κενό ASCII). Η αρχική συμβολοσειρά "
"επιστρέφεται εάν το *width* είναι μικρότερο ή ίσο με το ``len(s)``."

#: library/stdtypes.rst:2083
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Επιστρέφει ένα αντίγραφο της συμβολοσειράς (string) με όλους τους cased "
"χαρακτήρες [4]_ να έχουν μετατραπεί σε πεζούς."

#: library/stdtypes.rst:2086
msgid ""
"The lowercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode16.0.0/core-spec/chapter-3/#G33992>`__."
msgstr ""
"Ο αλγόριθμος που χρησιμοποιείται για την πεζογράμμιση `περιγράφεται στην "
"ενότητα 3.13 'Default Case Folding' του προτύπου Unicode <https://www."
"unicode.org/versions/Unicode16.0.0/core-spec/chapter-3/#G33992>`__."

#: library/stdtypes.rst:2093
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Επιστρέφει ένα αντίγραφο της συμβολοσειράς (string) με την αφαίρεση των "
"αρχικών χαρακτήρων.  Τα *chars* είναι μια συμβολοσειρά  που καθορίζει το "
"σύνολο των χαρακτήρων που πρέπει να αφαιρεθούν.  Εάν παραλειφθεί ή είναι "
"``None``, το όρισμα *chars* έχει ως default την αφαίρεση των κενών "
"χαρακτήρων.  Το όρισμα *chars* δεν είναι ένα πρόθεμα· οπότε, όλοι οι "
"συνδυασμοί των τιμών του αφαιρούνται::"

#: library/stdtypes.rst:2098
msgid ""
">>> '   spacious   '.lstrip()\n"
"'spacious   '\n"
">>> 'www.example.com'.lstrip('cmowz.')\n"
"'example.com'"
msgstr ""
">>> '   spacious   '.lstrip()\n"
"'spacious   '\n"
">>> 'www.example.com'.lstrip('cmowz.')\n"
"'example.com'"

#: library/stdtypes.rst:2103
msgid ""
"See :meth:`str.removeprefix` for a method that will remove a single prefix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Δείτε την :meth:`str.removeprefix` για μια μέθοδο που θα αφαιρέσει ένα μόνο "
"πρόθεμα συμβολοσειράς (string) αντί για όλο το σύνολο των χαρακτήρων.  Για "
"παράδειγμα::"

#: library/stdtypes.rst:2106
msgid ""
">>> 'Arthur: three!'.lstrip('Arthur: ')\n"
"'ee!'\n"
">>> 'Arthur: three!'.removeprefix('Arthur: ')\n"
"'three!'"
msgstr ""
">>> 'Arthur: three!'.lstrip('Arthur: ')\n"
"'ee!'\n"
">>> 'Arthur: three!'.removeprefix('Arthur: ')\n"
"'three!'"

#: library/stdtypes.rst:2114
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""
"Αυτή η στατική μέθοδος επιστρέφει έναν πίνακα μεταφράσεων που μπορεί να "
"χρησιμοποιηθεί για το :meth:`str.translate`."

#: library/stdtypes.rst:2116
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or ``None``.  Character keys will then be "
"converted to ordinals."
msgstr ""
"Εάν υπάρχει μόνο ένα όρισμα, πρέπει να είναι ένα λεξικό αντιστοίχισης "
"Unicode ordinals (ακέραιοι αριθμοί) ή χαρακτήρες (συμβολοσειρές - strings "
"μήκους 1) σε ordinals Unicode, συμβολοσειρές (αυθαίρετου μήκους) ή "
"``None``.  Τα κλειδιά χαρακτήρων τότε θα μετατραπούν σε κανονικούς αριθμούς."

#: library/stdtypes.rst:2121
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to ``None`` in the result."
msgstr ""
"Εάν υπάρχουν δύο ορίσματα, πρέπει να είναι συμβολοσειρές (strings) ίσου "
"μήκους και στο λεξικό (dictionary) που θα προκύψει, κάθε χαρακτήρας στο x θα "
"αντιστοιχιστεί στο χαρακτήρα στην ίδια θέση στο y. Αν υπάρχει τρίτο όρισμα, "
"πρέπει να είναι συμβολοσειρά, του οποίου οι χαρακτήρες θα αντιστοιχιστούν "
"στο αποτέλεσμα σε ``None``."

#: library/stdtypes.rst:2129
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Διαχωρίστε τη συμβολοσειρά (string) στην πρώτη εμφάνιση του *sep*, και "
"επιστρέφει ένα 3-tuple που περιέχει το μέρος πριν από το διαχωριστικό, το "
"ίδιο το διαχωριστικό και το μέρος μετά το διαχωριστικό.  Αν ο διαχωριστής "
"δεν βρεθεί, επιστρέφει ένα 3-σύνολο που περιέχει την ίδια τη συμβολοσειρά, "
"ακολουθούμενη από δύο κενές συμβολοσειρές."

#: library/stdtypes.rst:2137
msgid ""
"If the string starts with the *prefix* string, return "
"``string[len(prefix):]``. Otherwise, return a copy of the original string::"
msgstr ""
"Εάν η συμβολοσειρά (string) ξεκινά με το *prefix*, επιστρέφει "
"``string[len(prefix):]``. Διαφορετικά, επιστρέφει ένα αντίγραφο της αρχικής "
"συμβολοσειράς::"

#: library/stdtypes.rst:2141
msgid ""
">>> 'TestHook'.removeprefix('Test')\n"
"'Hook'\n"
">>> 'BaseTestCase'.removeprefix('Test')\n"
"'BaseTestCase'"
msgstr ""
">>> 'TestHook'.removeprefix('Test')\n"
"'Hook'\n"
">>> 'BaseTestCase'.removeprefix('Test')\n"
"'BaseTestCase'"

#: library/stdtypes.rst:2151
msgid ""
"If the string ends with the *suffix* string and that *suffix* is not empty, "
"return ``string[:-len(suffix)]``. Otherwise, return a copy of the original "
"string::"
msgstr ""
"Αν η συμβολοσειρά τελειώνει με το *suffix* και το *suffix* δεν είναι κενό, "
"επιστρέφει ``string[:-len(suffix)]``. Διαφορετικά, επιστρέφει ένα αντίγραφο "
"της αρχικής συμβολοσειράς::"

#: library/stdtypes.rst:2155
msgid ""
">>> 'MiscTests'.removesuffix('Tests')\n"
"'Misc'\n"
">>> 'TmpDirMixin'.removesuffix('Tests')\n"
"'TmpDirMixin'"
msgstr ""
">>> 'MiscTests'.removesuffix('Tests')\n"
"'Misc'\n"
">>> 'TmpDirMixin'.removesuffix('Tests')\n"
"'TmpDirMixin'"

#: library/stdtypes.rst:2165
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If *count* is given, only the first *count* occurrences are "
"replaced. If *count* is not specified or ``-1``, then all occurrences are "
"replaced."
msgstr ""
"Επιστρέφει ένα αντίγραφο της συμβολοσειράς (string) με όλες τις εμφανίσεις "
"της υπό-συμβολοσειράς *old* αντικατεστημένες από την *new*.  Εάν δοθεί η "
"παράμετρος *count*, μόνο οι πρώτες *count* εμφανίσεις. Αν δεν έχει οριστεί ή "
"είναι -1, τότε αντικαθίστανται όλες οι εμφανίσεις."

#: library/stdtypes.rst:2169
msgid "*count* is now supported as a keyword argument."
msgstr "Το *count* υποστηρίζεται πλέον ως όρισμα λέξης-κλειδιού."

#: library/stdtypes.rst:2175
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Επιστρέφει το υψηλότερο index στη συμβολοσειρά (string) όπου βρίσκεται η υπό-"
"συμβολοσειρά *sub*, έτσι ώστε το *sub* περιέχεται στο ``s[start:end]``.  Τα "
"προαιρετικά ορίσματα *start* και *end* ερμηνεύονται ως slice notation.  "
"Επιστρέφει ``-1`` σε περίπτωση αποτυχίας."

#: library/stdtypes.rst:2182
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
"Όπως η :meth:`rfind`, αλλά κάνει raise :exc:`ValueError` όταν η υπό-"
"συμβολοσειρά (sub-string) *sub* δεν βρέθηκε."

#: library/stdtypes.rst:2188
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Επιστρέφει τη συμβολοσειρά (string) με δεξιό προσανατολισμό σε μια "
"συμβολοσειρά μήκους *width*. Το padding γίνεται χρησιμοποιώντας το "
"καθορισμένο *fillchar* (η προεπιλογή είναι ένα διάστημα ASCII). Η αρχική "
"συμβολοσειρά επιστρέφεται εάν το *width* είναι μικρότερο ή ίσο με ``len(s)``."

#: library/stdtypes.rst:2195
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Διαχωρίζει τη συμβολοσειρά (string) στην τελευταία εμφάνιση του *sep* και "
"επιστρέφει ένα 3-tuple που περιέχει το τμήμα πριν από το διαχωριστικό, το "
"ίδιο το διαχωριστικό και το μέρος μετά το διαχωριστικό.  Εάν το διαχωριστικό "
"δεν βρεθεί, επιστρέφει ένα 3-tuple που περιέχει δύο κενές συμβολοσειρές, "
"ακολουθούμενες από την ίδια τη συμβολοσειρά."

#: library/stdtypes.rst:2203
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Επιστρέφει μια λίστα με τις λέξεις στη συμβολοσειρά (string), "
"χρησιμοποιώντας το *sep* ως οριοθέτη. Εάν δοθεί το *maxsplit*, θα γίνουν το "
"πολύ *maxsplit* διαχωρισμοί, ξεκινώντας από τα δεξιά.  Εάν το *sep* δεν έχει "
"καθοριστεί ή είναι ``None``, οποιοδήποτε κενό διάστημα γίνεται διαχωριστικό. "
"Εκτός από το διαχωρισμό από τα δεξιά, η :meth:`rsplit` συμπεριφέρεται όπως "
"η :meth:`split` που περιγράφεται λεπτομερώς παρακάτω."

#: library/stdtypes.rst:2212
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped::"
msgstr ""
"Επιστρέφει ένα αντίγραφο της συμβολοσειράς (string) με τους χαρακτήρες που "
"έχουν αφαιρεθεί.  Τα όρισμα *chars* είναι μια συμβολοσειρά που καθορίζει το "
"σύνολο των χαρακτήρων που πρέπει να αφαιρεθούν.  Εάν παραληφθεί ή είναι "
"``None``, το όρισμα *chars* έχει ως προεπιλογή την αφαίρεση των κενών "
"διαστημάτων.  Το όρισμα *chars* δεν είναι suffix, αλλά όλοι οι συνδυασμοί "
"των τιμών του αφαιρούνται::"

#: library/stdtypes.rst:2217
msgid ""
">>> '   spacious   '.rstrip()\n"
"'   spacious'\n"
">>> 'mississippi'.rstrip('ipz')\n"
"'mississ'"
msgstr ""
">>> '   spacious   '.rstrip()\n"
"'   spacious'\n"
">>> 'mississippi'.rstrip('ipz')\n"
"'mississ'"

#: library/stdtypes.rst:2222
msgid ""
"See :meth:`str.removesuffix` for a method that will remove a single suffix "
"string rather than all of a set of characters.  For example::"
msgstr ""
"Δείτε τη :meth:`str.removesuffix` για μια μέθοδο που θα αφαιρέσει ένα απλό "
"suffix αντί για όλο το σύνολο των χαρακτήρων.  Για παράδειγμα::"

#: library/stdtypes.rst:2225
msgid ""
">>> 'Monty Python'.rstrip(' Python')\n"
"'M'\n"
">>> 'Monty Python'.removesuffix(' Python')\n"
"'Monty'"
msgstr ""
">>> 'Monty Python'.rstrip(' Python')\n"
"'M'\n"
">>> 'Monty Python'.removesuffix(' Python')\n"
"'Monty'"

#: library/stdtypes.rst:2232
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Επιστρέφει μια λίστα με τις λέξεις της συμβολοσειράς (string), "
"χρησιμοποιώντας το *sep* ως διαχωριστικό.  Αν δοθεί το *maxsplit*, γίνονται "
"το πολύ *maxsplit* διαχωρισμοί (έτσι, η λίστα θα έχει το πολύ ``maxsplit+1`` "
"στοιχεία).  Εάν το *maxsplit* δεν καθοριστεί ή είναι ``-1``, τότε δεν "
"υπάρχει όριο στον αριθμό των διαχωρισμών (γίνονται όλες οι πιθανές "
"διασπάσεις)."

#: library/stdtypes.rst:2238
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"as a single delimiter (to split with multiple delimiters, use :func:`re."
"split`). Splitting an empty string with a specified separator returns "
"``['']``."
msgstr ""
"Αν δοθεί το *sep*, οι διαδοχικά οριοθέτες δεν ομαδοποιούνται μαζί και "
"θεωρείται ότι οριοθετούν κενές συμβολοσειρές (strings) (για παράδειγμα, το "
"``'1,,2'.split(',')`` επιστρέφει ``['1', '', '2']``).  Το όρισμα *sep* "
"μπορεί να αποτελείται από πολλούς χαρακτήρες ως μεμονωμένο οριοθέτη (για "
"διαχωρισμό με πολλαπλούς οριοθέτες, χρησιμοποιήστε την :func:`re.split`). Ο "
"διαχωρισμός μιας κενής συμβολοσειράς με ένα καθορισμένο διαχωριστικό "
"επιστρέφει το ``['']``."

#: library/stdtypes.rst:2263 library/stdtypes.rst:2383
#: library/stdtypes.rst:3483 library/stdtypes.rst:3592
#: library/stdtypes.rst:3633 library/stdtypes.rst:3675
#: library/stdtypes.rst:3707 library/stdtypes.rst:3757
#: library/stdtypes.rst:3826 library/stdtypes.rst:3850
msgid "For example::"
msgstr "Για παράδειγμα::"

#: library/stdtypes.rst:2247
msgid ""
">>> '1,2,3'.split(',')\n"
"['1', '2', '3']\n"
">>> '1,2,3'.split(',', maxsplit=1)\n"
"['1', '2,3']\n"
">>> '1,2,,3,'.split(',')\n"
"['1', '2', '', '3', '']\n"
">>> '1<>2<>3<4'.split('<>')\n"
"['1', '2', '3<4']"
msgstr ""
">>> '1,2,3'.split(',')\n"
"['1', '2', '3']\n"
">>> '1,2,3'.split(',', maxsplit=1)\n"
"['1', '2,3']\n"
">>> '1,2,,3,'.split(',')\n"
"['1', '2', '', '3', '']\n"
">>> '1<>2<>3<4'.split('<>')\n"
"['1', '2', '3<4']"

#: library/stdtypes.rst:2256
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Αν το *sep* καθοριστεί ή είναι ``None``, εφαρμόζεται ένας διαφορετικός "
"αλγόριθμος διαχωρισμού: οι εμφανίσεις διαδοχικών κενών θεωρούνται ως ένα "
"ενιαίο διαχωριστικό, και το αποτέλεσμα δεν θα περιέχει κενές συμβολοσειρές "
"(strings) στην αρχή ή στο τέλος, αν η συμβολοσειρά έχει κενό διάστημα στην "
"αρχή ή στο τέλος.  Κατά συνέπεια, η διάσπαση μιας κενής συμβολοσειράς ή μιας "
"συμβολοσειράς που αποτελείται μόνο από κενά διαστήματα με ένα ``None`` ως "
"διαχωριστικό επιστρέφει ``[]``."

#: library/stdtypes.rst:2265
msgid ""
">>> '1 2 3'.split()\n"
"['1', '2', '3']\n"
">>> '1 2 3'.split(maxsplit=1)\n"
"['1', '2 3']\n"
">>> '   1   2   3   '.split()\n"
"['1', '2', '3']"
msgstr ""
">>> '1 2 3'.split()\n"
"['1', '2', '3']\n"
">>> '1 2 3'.split(maxsplit=1)\n"
"['1', '2 3']\n"
">>> '   1   2   3   '.split()\n"
"['1', '2', '3']"

#: library/stdtypes.rst:2278
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""
"Επιστρέφει μια λίστα με τις γραμμές της συμβολοσειράς (string), "
"διαχωρίζοντας στα όρια των γραμμών.  Τα διαχωριστικά των γραμμών δεν "
"περιλαμβάνονται στην νέα λίστα, εκτός αν δοθεί το *keepends* και είναι true."

#: library/stdtypes.rst:2282
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"Αυτή η μέθοδος διαχωρίζει στα ακόλουθα όρια γραμμών.  Πιο συγκεκριμένα, τα "
"όρια είναι ένα υπερσύνολο του :term:`universal newlines`."

#: library/stdtypes.rst:2286
msgid "Representation"
msgstr "Αναπαράσταση"

#: library/stdtypes.rst:2286
msgid "Description"
msgstr "Περιγραφή"

#: library/stdtypes.rst:2288
msgid "``\\n``"
msgstr "``\\n``"

#: library/stdtypes.rst:2288
msgid "Line Feed"
msgstr "Line Feed"

#: library/stdtypes.rst:2290
msgid "``\\r``"
msgstr "``\\r``"

#: library/stdtypes.rst:2290
msgid "Carriage Return"
msgstr "Carriage Return"

#: library/stdtypes.rst:2292
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: library/stdtypes.rst:2292
msgid "Carriage Return + Line Feed"
msgstr "Carriage Return + Line Feed"

#: library/stdtypes.rst:2294
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` or ``\\x0b``"

#: library/stdtypes.rst:2294
msgid "Line Tabulation"
msgstr "Line Tabulation"

#: library/stdtypes.rst:2296
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` or ``\\x0c``"

#: library/stdtypes.rst:2296
msgid "Form Feed"
msgstr "Form Feed"

#: library/stdtypes.rst:2298
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: library/stdtypes.rst:2298
msgid "File Separator"
msgstr "Διαχωριστής Αρχείου"

#: library/stdtypes.rst:2300
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: library/stdtypes.rst:2300
msgid "Group Separator"
msgstr "Διαχωριστής Group"

#: library/stdtypes.rst:2302
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: library/stdtypes.rst:2302
msgid "Record Separator"
msgstr "Διαχωριστής Εγγραφών"

#: library/stdtypes.rst:2304
msgid "``\\x85``"
msgstr "``\\x85``"

#: library/stdtypes.rst:2304
msgid "Next Line (C1 Control Code)"
msgstr "Επόμενη Γραμμή (C1 Control Code)"

#: library/stdtypes.rst:2306
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: library/stdtypes.rst:2306
msgid "Line Separator"
msgstr "Διαχωριστής Γραμμής"

#: library/stdtypes.rst:2308
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: library/stdtypes.rst:2308
msgid "Paragraph Separator"
msgstr "Διαχωριστής Παραγράφου"

#: library/stdtypes.rst:2313
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "Τα ``\\v`` και ``\\f`` προστίθενται στην λίστα ορίων των γραμμών."

#: library/stdtypes.rst:2317
msgid ""
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"['ab c', '', 'de fg', 'kl']\n"
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']"
msgstr ""
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"['ab c', '', 'de fg', 'kl']\n"
">>> 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']"

#: library/stdtypes.rst:2322
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Σε αντίθεση με την :meth:`~str.split` όταν δίνεται μια συμβολοσειρά (string) "
"οριοθέτησης *sep*, αυτή η μέθοδος επιστρέφει μια κενή λίστα για το κενό "
"αλφαριθμητικό, και μια τερματικό break γραμμής δεν οδηγεί σε μια επιπλέον "
"γραμμή::"

#: library/stdtypes.rst:2326
msgid ""
">>> \"\".splitlines()\n"
"[]\n"
">>> \"One line\\n\".splitlines()\n"
"['One line']"
msgstr ""
">>> \"\".splitlines()\n"
"[]\n"
">>> \"One line\\n\".splitlines()\n"
"['One line']"

#: library/stdtypes.rst:2331
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "Συγκριτικά, η ``split('\\n')`` δίνει::"

#: library/stdtypes.rst:2333
msgid ""
">>> ''.split('\\n')\n"
"['']\n"
">>> 'Two lines\\n'.split('\\n')\n"
"['Two lines', '']"
msgstr ""
">>> ''.split('\\n')\n"
"['']\n"
">>> 'Two lines\\n'.split('\\n')\n"
"['Two lines', '']"

#: library/stdtypes.rst:2341
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Επιστρέφει ``True`` αν η συμβολοσειρά (string) αρχίζει με το *prefix*, "
"αλλιώς επιστρέφει ``False``. Το *prefix* μπορεί επίσης να είναι μια πλειάδα "
"(tuple) prefix προς αναζήτηση.  Με το προαιρετικό *start*, ελέγχεται το "
"αλφαριθμητικό που αρχίζει από τη συγκεκριμένη θέση.  Με το προαιρετικό "
"*end*, σταματά η σύγκριση της συμβολοσειράς σε αυτή τη θέση."

#: library/stdtypes.rst:2349
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Επιστρέφει ένα αντίγραφο της συμβολοσειράς (string) με τους πρώτους και τους "
"τελευταίους χαρακτήρες να έχουν αφαιρεθεί. Το όρισμα *chars* είναι μια "
"συμβολοσειρά που καθορίζει το σύνολο των χαρακτήρων που πρέπει να "
"αφαιρεθούν. Εάν παραλειφθεί ή είναι ``None``, το όρισμα *chars* έχει ως "
"default την αφαίρεση των κενών διαστημάτων. Το όρισμα *chars* δεν είναι "
"prefix ή suffix· μάλλον, όλοι οι συνδυασμοί των τιμών του αφαιρούνται::"

#: library/stdtypes.rst:2355
msgid ""
">>> '   spacious   '.strip()\n"
"'spacious'\n"
">>> 'www.example.com'.strip('cmowz.')\n"
"'example'"
msgstr ""
">>> '   spacious   '.strip()\n"
"'spacious'\n"
">>> 'www.example.com'.strip('cmowz.')\n"
"'example'"

#: library/stdtypes.rst:2360
msgid ""
"The outermost leading and trailing *chars* argument values are stripped from "
"the string. Characters are removed from the leading end until reaching a "
"string character that is not contained in the set of characters in *chars*. "
"A similar action takes place on the trailing end. For example::"
msgstr ""
"Οι ακραίες αρχικές και τελικές τιμές του ορίσματος *chars* αφαιρούνται από "
"τη συμβολοσειρά (string). Οι χαρακτήρες αφαιρούνται από το μπροστινό άκρο "
"μέχρι να φτάσουν στο χαρακτήρα της συμβολοσειράς (string) που δεν περιέχεται "
"στο σύνολο χαρακτήρων του *chars*. Μια παρόμοια ενέργεια λαμβάνει χώρα στο "
"τέλος της ουράς. Για παράδειγμα:"

#: library/stdtypes.rst:2366
msgid ""
">>> comment_string = '#....... Section 3.2.1 Issue #32 .......'\n"
">>> comment_string.strip('.#! ')\n"
"'Section 3.2.1 Issue #32'"
msgstr ""
">>> comment_string = '#....... Section 3.2.1 Issue #32 .......'\n"
">>> comment_string.strip('.#! ')\n"
"'Section 3.2.1 Issue #32'"

#: library/stdtypes.rst:2373
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa. Note that it is not necessarily true that ``s.swapcase()."
"swapcase() == s``."
msgstr ""
"Επιστρέφει ένα αντίγραφο της συμβολοσειράς (string) με κεφαλαίους χαρακτήρες "
"που έχουν μετατραπεί σε πεζούς και αντίστροφα. Σημειώστε ότι δεν είναι "
"απαραίτητα αληθές ότι ``s.swapcase().swapcase() == s``."

#: library/stdtypes.rst:2380
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Επιστρέφει μια titlecased έκδοση της συμβολοσειράς, όπου οι λέξεις ξεκινούν "
"με ένα κεφαλαίο χαρακτήρα και οι υπόλοιποι χαρακτήρες είναι πεζοί."

#: library/stdtypes.rst:2385
msgid ""
">>> 'Hello world'.title()\n"
"'Hello World'"
msgstr ""
">>> 'Hello world'.title()\n"
"'Hello World'"

#: library/stdtypes.rst:3794
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""
"Ο αλγόριθμος χρησιμοποιεί έναν απλό, ανεξάρτητο από τη γλώσσα, ορισμό μιας "
"λέξης ως group διαδοχικών γραμμάτων.  Ο ορισμός λειτουργεί σε πολλά "
"contexts, αλλά σημαίνει ότι οι απόστροφοι σε συναιρέσεις και κτητικές λέξεις "
"αποτελούν όρια λέξεων, που μπορεί να μην είναι το επιθυμητό αποτέλεσμα::"

#: library/stdtypes.rst:2393
msgid ""
">>> \"they're bill's friends from the UK\".title()\n"
"\"They'Re Bill'S Friends From The Uk\""
msgstr ""
">>> \"they're bill's friends from the UK\".title()\n"
"\"They'Re Bill'S Friends From The Uk\""

#: library/stdtypes.rst:2396
msgid ""
"The :func:`string.capwords` function does not have this problem, as it "
"splits words on spaces only."
msgstr ""
"Η συνάρτηση :func:`string.capwords` δεν έχει αυτό το πρόβλημα, καθώς χωρίζει "
"τις λέξεις μόνο σε κενά."

#: library/stdtypes.rst:2399
msgid ""
"Alternatively, a workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr ""
"Εναλλακτικά, μπορεί να κατασκευαστεί μια λύση για τις αποστρόφους "
"χρησιμοποιώντας κανονικές εκφράσεις::"

#: library/stdtypes.rst:2402
msgid ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0).capitalize(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(\"they're bill's friends.\")\n"
"\"They're Bill's Friends.\""
msgstr ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0).capitalize(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(\"they're bill's friends.\")\n"
"\"They're Bill's Friends.\""

#: library/stdtypes.rst:2414
msgid ""
"Return a copy of the string in which each character has been mapped through "
"the given translation table.  The table must be an object that implements "
"indexing via :meth:`~object.__getitem__`, typically a :term:`mapping` or :"
"term:`sequence`.  When indexed by a Unicode ordinal (an integer), the table "
"object can do any of the following: return a Unicode ordinal or a string, to "
"map the character to one or more other characters; return ``None``, to "
"delete the character from the return string; or raise a :exc:`LookupError` "
"exception, to map the character to itself."
msgstr ""
"Επιστρέφει ένα αντίγραφο της συμβολοσειράς (string) στο οποίο κάθε "
"χαρακτήρας έχει αντιστοιχιστεί μέσω του πίνακα μετάφρασης.  Ο πίνακας πρέπει "
"να είναι ένα αντικείμενο που υλοποιεί ευρετηριοποίηση μέσω της :meth:"
"`~object.__getitem__`, συνήθως ένα :term:`mapping` ή ένα :term:`sequence`.  "
"Όταν το indexing γίνεται με ένα Unicode ordinal (ένας ακέραιος), το "
"αντικείμενο του πίνακα μπορεί να κάνει οποιοδήποτε από τα ακόλουθα: να "
"επιστρέψει ένα Unicode ordinal ή μια συμβολοσειρά (string), να αντιστοιχίσει "
"τον χαρακτήρα σε έναν ή περισσότερους άλλους χαρακτήρες· να επιστρέψει "
"``None``, για να διαγράψει τον χαρακτήρα από τη συμβολοσειρά που "
"επιστρέφεται· ή να κάνει raise ένα :exc:`LookupError`, για να αντιστοιχίσει "
"τον χαρακτήρα στον εαυτό του."

#: library/stdtypes.rst:2423
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""
"Μπορείτε να χρησιμοποιήσετε το :meth:`str.maketrans` για να δημιουργήσετε "
"ένα χάρτη μετάφρασης αντιστοίχισης από χαρακτήρα-σε-χαρακτήρα σε "
"διαφορετικές μορφές."

#: library/stdtypes.rst:2426
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr ""
"Δείτε επίσης την ενότητα :mod:`codecs` για μια πιο ευέλικτη προσέγγιση σε "
"προσαρμοσμένα mappings χαρακτήρων."

#: library/stdtypes.rst:2432
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Επιστρέφει ένα αντίγραφο της συμβολοσειράς (string) με όλους τους χαρακτήρες "
"[4]_ που έχουν μετατραπεί σε κεφαλαία.  Σημειώστε ότι το ``s.upper()."
"isupper()`` μπορεί να είναι ``False`` αν το ``s`` περιέχει χαρακτήρες χωρίς "
"πεζά γράμματα ή αν η κατηγορία Unicode του προκύπτοντος χαρακτήρα(ων) δεν "
"είναι  \"Lu\" (Γράμμα, κεφαλαίο), αλλά π.χ. \"Lt\" (Γράμμα, titlecase)."

#: library/stdtypes.rst:2438
msgid ""
"The uppercasing algorithm used is `described in section 3.13 'Default Case "
"Folding' of the Unicode Standard <https://www.unicode.org/versions/"
"Unicode16.0.0/core-spec/chapter-3/#G33992>`__."
msgstr ""
"Ο αλγόριθμος που κάνει τα γράμματα κεφαλαία που χρησιμοποιείται "
"`περιγράφεται στην ενότητα 3.13 'Default Case Folding' του προτύπου Unicode "
"<https://www.unicode.org/versions/Unicode16.0.0/core-spec/chapter-3/"
"#G33992>`__."

#: library/stdtypes.rst:2445
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make a "
"string of length *width*. A leading sign prefix (``'+'``/``'-'``) is handled "
"by inserting the padding *after* the sign character rather than before. The "
"original string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"Επιστρέφει ένα αντίγραφο της συμβολοσειράς (string) που έμεινε γεμάτη με "
"ψηφία ASCII ``'0'``` για να δημιουργήσει μία συμβολοσειρά μήκους *width*. "
"Χειρίζεται ένα leading sign prefix (``'+'``/``'-'``) εισάγοντας την "
"συμπλήρωση *μετά* τον χαρακτήρα sign αντί για πριν. Η αρχική συμβολοσειρά "
"επιστρέφεται εάν το *width* είναι μικρότερο ή ίσο με ``len(s)``."

#: library/stdtypes.rst:2453
msgid ""
">>> \"42\".zfill(5)\n"
"'00042'\n"
">>> \"-42\".zfill(5)\n"
"'-0042'"
msgstr ""
">>> \"42\".zfill(5)\n"
"'00042'\n"
">>> \"-42\".zfill(5)\n"
"'-0042'"

#: library/stdtypes.rst:2474
msgid "Formatted String Literals (f-strings)"
msgstr "Διαμορφωμένες Κυριολεκτικές Συμβολοσειρές (f-strings)"

#: library/stdtypes.rst:2477
msgid ""
"The :keyword:`await` and :keyword:`async for` can be used in expressions "
"within f-strings."
msgstr ""
"Τα :keyword:`await` και :keyword:`async for` μπορούν να χρησιμοποιηθούν σε "
"εκφράσεις μέσα σε f-strings."

#: library/stdtypes.rst:2480
msgid "Added the debugging operator (``=``)"
msgstr "Προστέθηκε ο τελεστής αποσφαλμάτωσης (``=``)"

#: library/stdtypes.rst:2482
msgid ""
"Many restrictions on expressions within f-strings have been removed. "
"Notably, nested strings, comments, and backslashes are now permitted."
msgstr ""
"Πολλοί περιορισμοί στις εκφράσεις μέσα σε f-strings έχουν αφαιρεθεί. "
"Ιδιαίτερα, πλέον επιτρέπονται οι εμφωλευμένες συμβολοσειρές, τα σχόλια και "
"οι κάθετοι."

#: library/stdtypes.rst:2486
msgid ""
"An :dfn:`f-string` (formally a :dfn:`formatted string literal`) is a string "
"literal that is prefixed with ``f`` or ``F``. This type of string literal "
"allows embedding arbitrary Python expressions within *replacement fields*, "
"which are delimited by curly brackets (``{}``). These expressions are "
"evaluated at runtime, similarly to :meth:`str.format`, and are converted "
"into regular :class:`str` objects. For example:"
msgstr ""
"Ένα :dfn:`f-string` (επίσημα ένα :dfn:`formatted string literal`) είναι μια "
"κυριολεκτική συμβολοσειρά που προεξέχει με ``f`` ή ``F``. Αυτός ο τύπος "
"κυριολεκτικής συμβολοσειράς επιτρέπει την ενσωμάτωση αυθαίρετων εκφράσεων "
"Python μέσα σε *πεδία αντικατάστασης*, τα οποία περιβάλλονται από αγκύλες "
"(``{}``). Αυτές οι εκφράσεις αξιολογούνται κατά την εκτέλεση, με παρόμοιο "
"τρόπο όπως η μέθοδος :meth:`str.format`, και μετατρέπονται σε κανονικά "
"αντικείμενα τύπου :class:`str`. Για παράδειγμα:"

#: library/stdtypes.rst:2494
msgid ""
">>> who = 'nobody'\n"
">>> nationality = 'Spanish'\n"
">>> f'{who.title()} expects the {nationality} Inquisition!'\n"
"'Nobody expects the Spanish Inquisition!'"
msgstr ""
">>> who = 'nobody'\n"
">>> nationality = 'Spanish'\n"
">>> f'{who.title()} expects the {nationality} Inquisition!'\n"
"'Nobody expects the Spanish Inquisition!'"

#: library/stdtypes.rst:2501
msgid "It is also possible to use a multi line f-string:"
msgstr "Είναι επίσης δυνατό να χρησιμοποιηθεί μια f-string πολλών γραμμών:"

#: library/stdtypes.rst:2503
msgid ""
">>> f'''This is a string\n"
"... on two lines'''\n"
"'This is a string\\non two lines'"
msgstr ""
">>> f'''This is a string\n"
"... on two lines'''\n"
"'This is a string\\non two lines'"

#: library/stdtypes.rst:2509
msgid ""
"A single opening curly bracket, ``'{'``, marks a *replacement field* that "
"can contain any Python expression:"
msgstr ""
"Ένα μόνο άνοιγμα αγκύλης, ``'{'``, δηλώνει ένα *πεδίο αντικατάστασης* που "
"μπορεί να περιέχει οποιαδήποτε έκφραση Python:"

#: library/stdtypes.rst:2512
msgid ""
">>> nationality = 'Spanish'\n"
">>> f'The {nationality} Inquisition!'\n"
"'The Spanish Inquisition!'"
msgstr ""
">>> nationality = 'Spanish'\n"
">>> f'The {nationality} Inquisition!'\n"
"'The Spanish Inquisition!'"

#: library/stdtypes.rst:2518
msgid "To include a literal ``{`` or ``}``, use a double bracket:"
msgstr ""
"Για να συμπεριλάβετε μια κυριολεξία ``{`` ή ``}``, χρησιμοποιήστε διπλή "
"αγκύλη:"

#: library/stdtypes.rst:2520
msgid ""
">>> x = 42\n"
">>> f'{{x}} is {x}'\n"
"'{x} is 42'"
msgstr ""
">>> x = 42\n"
">>> f'{{x}} is {x}'\n"
"'{x} is 42'"

#: library/stdtypes.rst:2526
msgid ""
"Functions can also be used, and :ref:`format specifiers <formatstrings>`:"
msgstr ""
"Μπορούν επίσης να χρησιμοποιηθούν συναρτήσεις καθώς και :ref:`format "
"specifiers <formatstrings>`:"

#: library/stdtypes.rst:2528
msgid ""
">>> from math import sqrt\n"
">>> f'√2 \\N{ALMOST EQUAL TO} {sqrt(2):.5f}'\n"
"'√2 ≈ 1.41421'"
msgstr ""
">>> from math import sqrt\n"
">>> f'√2 \\N{ALMOST EQUAL TO} {sqrt(2):.5f}'\n"
"'√2 ≈ 1.41421'"

#: library/stdtypes.rst:2534
msgid "Any non-string expression is converted using :func:`str`, by default:"
msgstr ""
"Κάθε έκφραση μη-συμβολοσειράς μετατρέπεται χρησιμοποιώντας τη :func:`str`, "
"από προεπιλογή:"

#: library/stdtypes.rst:2536
msgid ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)}'\n"
"'1/3'"
msgstr ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)}'\n"
"'1/3'"

#: library/stdtypes.rst:2542
msgid ""
"To use an explicit conversion, use the ``!`` (exclamation mark) operator, "
"followed by any of the valid formats, which are:"
msgstr ""
"Για να χρησιμοποιήσετε ρητή μετατροπή, χρησιμοποιήστε τον τελεστή ``!`` "
"(θαυμαστικό), ακολουθούμενο από οποιεσδήποτε από τις έγκυρες μορφές, τα "
"οποία είναι:"

#: library/stdtypes.rst:2714 library/stdtypes.rst:3973
msgid "Conversion"
msgstr "Μετατροπή"

#: library/stdtypes.rst:2548
msgid "``!a``"
msgstr "``!a``"

#: library/stdtypes.rst:2548
msgid ":func:`ascii`"
msgstr ":func:`ascii`"

#: library/stdtypes.rst:2549
msgid "``!r``"
msgstr "``!r``"

#: library/stdtypes.rst:2549
msgid ":func:`repr`"
msgstr ":func:`repr`"

#: library/stdtypes.rst:2550
msgid "``!s``"
msgstr "``!s``"

#: library/stdtypes.rst:2550
msgid ":func:`str`"
msgstr ":func:`str`"

#: library/stdtypes.rst:2553
msgid "For example:"
msgstr "Για παράδειγμα:"

#: library/stdtypes.rst:2555
msgid ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)!s}'\n"
"'1/3'\n"
">>> f'{Fraction(1, 3)!r}'\n"
"'Fraction(1, 3)'\n"
">>> question = '¿Dónde está el Presidente?'\n"
">>> print(f'{question!a}')\n"
"'\\xbfD\\xf3nde est\\xe1 el Presidente?'"
msgstr ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 3)!s}'\n"
"'1/3'\n"
">>> f'{Fraction(1, 3)!r}'\n"
"'Fraction(1, 3)'\n"
">>> question = '¿Dónde está el Presidente?'\n"
">>> print(f'{question!a}')\n"
"'\\xbfD\\xf3nde est\\xe1 el Presidente?'"

#: library/stdtypes.rst:2566
msgid ""
"While debugging it may be helpful to see both the expression and its value, "
"by using the equals sign (``=``) after the expression. This preserves spaces "
"within the brackets, and can be used with a converter. By default, the "
"debugging operator uses the :func:`repr` (``!r``) conversion. For example:"
msgstr ""
"Κατά την αποσφαλμάτωση, μπορεί να είναι χρήσιμο να βλέπουμε τόσο την έκφραση "
"όσο και την τιμή της, χρησιμοποιώντας το σύμβολο του ίσου (``=``) μετά την "
"έκφραση. Αυτό διατηρεί τα κενά μέσα στις αγκύλες και μπορείς να "
"χρησιμοποιηθεί με έναν μετατροπέα. Από προεπιλογή, ο χειριστής "
"αποσφαλμάτωσης χρησιμοποιεί τη μετατροπή :func:`repr` (``!r``). Για "
"παράδειγμα:"

#: library/stdtypes.rst:2572
msgid ""
">>> from fractions import Fraction\n"
">>> calculation = Fraction(1, 3)\n"
">>> f'{calculation=}'\n"
"'calculation=Fraction(1, 3)'\n"
">>> f'{calculation = }'\n"
"'calculation = Fraction(1, 3)'\n"
">>> f'{calculation = !s}'\n"
"'calculation = 1/3'"
msgstr ""
">>> from fractions import Fraction\n"
">>> calculation = Fraction(1, 3)\n"
">>> f'{calculation=}'\n"
"'calculation=Fraction(1, 3)'\n"
">>> f'{calculation = }'\n"
"'calculation = Fraction(1, 3)'\n"
">>> f'{calculation = !s}'\n"
"'calculation = 1/3'"

#: library/stdtypes.rst:2583
msgid ""
"Once the output has been evaluated, it can be formatted using a :ref:`format "
"specifier <formatstrings>` following a colon (``':'``). After the expression "
"has been evaluated, and possibly converted to a string, the :meth:`!"
"__format__` method of the result is called with the format specifier, or the "
"empty string if no format specifier is given. The formatted result is then "
"used as the final value for the replacement field. For example:"
msgstr ""
"Μόλις η έξοδος έχει αξιολογηθεί, μπορεί να μορφοποιηθεί χρησιμοποιώντας ένα :"
"ref:`format specifier <formatstrings>` που ακολουθείται από άνω και κάτω "
"τελεία (``':'``). Αφού η έκφραση έχει αξιολογηθεί και, πιθανώς μετατραπεί σε "
"συμβολοσειρά, καλείται η μέθοδος :meth:`!__format__` του αποτελέσματος με "
"τον καθοριστή μορφοποίησης, ή η κενή συμβολοσειρά αν δεν έχει δοθεί "
"καθοριστής μορφοποίησης. Το μορφοποιημένο αποτέλεσμα χρησιμοποιείται στη "
"συνέχεια ως η τελική τιμή για το πεδίο αντικατάστασης. Για παράδειγμα:"

#: library/stdtypes.rst:2591
msgid ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 7):.6f}'\n"
"'0.142857'\n"
">>> f'{Fraction(1, 7):_^+10}'\n"
"'___+1/7___'"
msgstr ""
">>> from fractions import Fraction\n"
">>> f'{Fraction(1, 7):.6f}'\n"
"'0.142857'\n"
">>> f'{Fraction(1, 7):_^+10}'\n"
"'___+1/7___'"

#: library/stdtypes.rst:2603
msgid "``printf``-style String Formatting"
msgstr "``printf``-style String Formatting"

#: library/stdtypes.rst:2616
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  Using the newer :ref:`formatted string literals <f-"
"strings>`, the :meth:`str.format` interface, or :ref:`template strings "
"<template-strings>` may help avoid these errors.  Each of these alternatives "
"provides their own trade-offs and benefits of simplicity, flexibility, and/"
"or extensibility."
msgstr ""
"Οι λειτουργίες μορφοποίησης που περιγράφονται εδώ παρουσιάζουν μια ποικιλία "
"ιδιορρυθμιών που οδηγούν σε έναν αριθμό κοινών σφαλμάτων (όπως η αποτυχία "
"εμφάνισης tuple και σωστών λεξικών). Χρησιμοποιώντας τα νεότερα :ref:"
"`formatted string literals <f-strings>`, το :meth:`str.format` interface ή "
"το :ref:`template strings <template-strings>` μπορεί να βοηθήσει στην "
"αποφυγή αυτών των σφαλμάτων. Κάθε μία από αυτές τις εναλλακτικές παρέχει "
"τους δικούς τις συμβιβασμούς και τα οφέλη της απλότητας, ευελιξίας και/ή "
"επεκτασιμότητας."

#: library/stdtypes.rst:2624
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to using the :c:func:`sprintf` "
"function in the C language. For example:"
msgstr ""
"Τα αντικείμενα string έχουν μια μοναδική ενσωματωμένη λειτουργία: τον "
"τελεστή ``%`` (modulo). Αυτός είναι επίσης γνωστός ως τελεστής *formatting* "
"ή * interpolation*. Δεδομένων των ``format % values`` (όπου *format* είναι "
"μία συμβολοσειρά), ``%`` οι προδιαγραφές μετατροπής στο *format* "
"αντικαθίστανται από μηδέν ή περισσότερα στοιχεία των *values*. Το αποτέλεσμα "
"είναι παρόμοιο με τη χρήση του :c:func:`sprintf` στη γλώσσα C. Για "
"παράδειγμα:"

#: library/stdtypes.rst:2631
msgid ""
">>> print('%s has %d quote types.' % ('Python', 2))\n"
"Python has 2 quote types."
msgstr ""
">>> print('%s has %d quote types.' % ('Python', 2))\n"
"Python has 2 quote types."

#: library/stdtypes.rst:2636
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Εάν το *format* απαιτεί ένα μεμονωμένο όρισμα, το *values* μπορεί να είναι "
"ένα μεμονωμένο non-tuple αντικείμενο. [5]_ Διαφορετικά, τα *values* πρέπει "
"να είναι ένα tuple με ακριβώς τον ίδιο αριθμό των στοιχείων που καθορίζονται "
"από το format string ή ένα μεμονωμένο αντικείμενο αντιστοίχισης (για "
"παράδειγμα, ένα λεξικό)."

#: library/stdtypes.rst:3905
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""
"Ένας προσδιοριστής μετατροπής περιέχει δύο ή περισσότερους χαρακτήρες και "
"έχει τους εξής components, οι οποίοι πρέπει να εμφανίζονται με αυτή τη σειρά:"

#: library/stdtypes.rst:3908
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "Ο χαρακτήρας ```%''``, που σηματοδοτεί την αρχή του προσδιοριστή."

#: library/stdtypes.rst:3910
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""
"Κλειδί mapping (προαιρετικό), που αποτελείται από μια ακολουθία χαρακτήρων "
"σε παρένθεση (για παράδειγμα, ``(somename)``)."

#: library/stdtypes.rst:3913
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Δείκτες μετατροπής (προαιρετικό), που επηρεάζουν το αποτέλεσμα κάποιων τύπων "
"μετατροπής."

#: library/stdtypes.rst:3916
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""
"Ελάχιστο πλάτος πεδίου (προαιρετικό). Εάν ορίζεται ως ``'*'`` (αστερίσκος), "
"το πραγματικό πλάτος διαβάζεται από το επόμενο στοιχείο του tuple στα "
"*values*, και το αντικείμενο προς μετατροπή έρχεται μετά από το ελάχιστο "
"πλάτος πεδίου και το προαιρετικό precision."

#: library/stdtypes.rst:3920
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""
"Ακρίβεια (προαιρετικό), δίνεται ως ``'.'`` (τελεία) ακολουθούμενη από το "
"precision.Εάν ορίζεται ως ``'*'`` (αστερίσκος), το πραγματικό precision "
"διαβάζεται από το επόμενο στοιχείο του tuple στα *values*, και η τιμή προς "
"μετατροπή έρχεται μετά το precision."

#: library/stdtypes.rst:3925
msgid "Length modifier (optional)."
msgstr "Μετατροπέας του length (προαιρετικό)."

#: library/stdtypes.rst:3927
msgid "Conversion type."
msgstr "Τύπος conversion."

#: library/stdtypes.rst:2670
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Όταν το σωστό όρισμα είναι ένα λεξικό (ή άλλος τύπος αντιστοίχισης), τότε οι "
"μορφές στη συμβολοσειρά *πρέπει* να περιλαμβάνουν ένα κλειδί αντιστοίχισης "
"σε παρένθεση σε αυτό το λεξικό που εισήχθη αμέσως μετά τον χαρακτήρα "
"``'%'``. Το κλειδί αντιστοίχισης επιλέγει την τιμή που θα μορφοποιηθεί από "
"την αντιστοίχιση.  Για παράδειγμα:"

#: library/stdtypes.rst:3938
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""
"Σε αυτήν την περίπτωση δεν μπορεί να υπάρχουν προσδιοριστές ``*`` σε μια "
"μορφή (καθώς απαιτούν μια διαδοχική λίστα παραμέτρων)."

#: library/stdtypes.rst:3941
msgid "The conversion flag characters are:"
msgstr "Οι δείκτες μετατροπής είναι:"

#: library/stdtypes.rst:3950
msgid "Flag"
msgstr "Flag"

#: library/stdtypes.rst:3952
msgid "``'#'``"
msgstr "``'#'``"

#: library/stdtypes.rst:3952
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""
"Οι μετατροπή τιμής θα χρησιμοποιήσει την \"εναλλακτική φόρμα\" (όπου "
"ορίζεται παρακάτω)."

#: library/stdtypes.rst:3955
msgid "``'0'``"
msgstr "``'0'``"

#: library/stdtypes.rst:3955
msgid "The conversion will be zero padded for numeric values."
msgstr "Η μετατροπή θα έχει μηδενική συμπλήρωση για αριθμητικές τιμές."

#: library/stdtypes.rst:3957
msgid "``'-'``"
msgstr "``'-'``"

#: library/stdtypes.rst:3957
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"Η τιμή μετατροπής αφήνεται προσαρμοσμένη (παρακάμπτει τη μετατροπή ``'0'`` "
"εάν δίνονται και τα δύο)."

#: library/stdtypes.rst:3960
msgid "``' '``"
msgstr "``' '``"

#: library/stdtypes.rst:3960
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(ένα κενό) Πρέπει να προστεθεί ένα κενό πριν από έναν θετικό αριθμό (ή κενή "
"συμβολοσειρά) που παράγεται από μια υπογεγραμμένη μετατροπή."

#: library/stdtypes.rst:3963
msgid "``'+'``"
msgstr "``'+'``"

#: library/stdtypes.rst:3963
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""
"Ένα χαρακτήρας προσήμου (``'+'`` ή ``'-'``) θα προηγείται της μετατροπής "
"(παρακάμπτει ένα \"κενό\" δείκτη)."

#: library/stdtypes.rst:3967
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"Ένας τροποποιητής μήκους (``h``, ``l``, or ``L``) μπορεί να υπάρχει, αλλά "
"αγνοείται καθώς δεν είναι απαραίτητος για την Python -- οπότε π.χ. ``%ld`` "
"είναι πανομοιότυπο σε ``%d``."

#: library/stdtypes.rst:3970
msgid "The conversion types are:"
msgstr "Οι τύποι μετατροπής είναι:"

#: library/stdtypes.rst:3975
msgid "``'d'``"
msgstr "``'d'``"

#: library/stdtypes.rst:2718 library/stdtypes.rst:3977
msgid "Signed integer decimal."
msgstr "Υπογεγραμμένος δεκαδικός ακέραιος."

#: library/stdtypes.rst:3977
msgid "``'i'``"
msgstr "``'i'``"

#: library/stdtypes.rst:3979
msgid "``'o'``"
msgstr "``'o'``"

#: library/stdtypes.rst:3979
msgid "Signed octal value."
msgstr "Υπογεγραμμένη οκταδική τιμή."

#: library/stdtypes.rst:3981
msgid "``'u'``"
msgstr "``'u'``"

#: library/stdtypes.rst:3981
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Απαρχαιωμένος τύπος -- είναι πανομοιότυπος με το ``'d'``."

#: library/stdtypes.rst:3983
msgid "``'x'``"
msgstr "``'x'``"

#: library/stdtypes.rst:3983
msgid "Signed hexadecimal (lowercase)."
msgstr "Υπογεγραμμένο δεκαεξαδικό (πεζά)."

#: library/stdtypes.rst:3985
msgid "``'X'``"
msgstr "``'X'``"

#: library/stdtypes.rst:3985
msgid "Signed hexadecimal (uppercase)."
msgstr "Υπογεγραμμένο δεκαεξαδικό (κεφαλαίο)."

#: library/stdtypes.rst:3987
msgid "``'e'``"
msgstr "``'e'``"

#: library/stdtypes.rst:3987
msgid "Floating-point exponential format (lowercase)."
msgstr "Εκθετική μορφή κινητής υποδιαστολής (πεζά)"

#: library/stdtypes.rst:3989
msgid "``'E'``"
msgstr "``'E'``"

#: library/stdtypes.rst:3989
msgid "Floating-point exponential format (uppercase)."
msgstr "Εκθετική μορφή κινητής υποδιαστολής (κεφαλαία)"

#: library/stdtypes.rst:3991
msgid "``'f'``"
msgstr "``'f'``"

#: library/stdtypes.rst:2734 library/stdtypes.rst:3993
msgid "Floating-point decimal format."
msgstr "Δεκαδική μορφή κινητής υποδιαστολής."

#: library/stdtypes.rst:3993
msgid "``'F'``"
msgstr "``'F'``"

#: library/stdtypes.rst:3995
msgid "``'g'``"
msgstr "``'g'``"

#: library/stdtypes.rst:3995
msgid ""
"Floating-point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Μορφή κινητής υποδιαστολής. Χρησιμοποιεί εκθετική μορφή πεζών αν ο εκθέτης "
"είναι μικρότερος από -4 ή όχι μικρότερος από την ακρίβεια, διαφορετικά "
"χρησιμοποιεί δεκαδική μορφή."

#: library/stdtypes.rst:3999
msgid "``'G'``"
msgstr "``'G'``"

#: library/stdtypes.rst:3999
msgid ""
"Floating-point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Μορφή κινητής υποδιαστολής. Χρησιμοποιεί εκθετική μορφή κεφαλαίων εάν ο "
"εκθέτης είναι μικρότερος από -4 ή όχι μικρότερος από την ακρίβεια, "
"διαφορετικά χρησιμοποιεί δεκαδική μορφή."

#: library/stdtypes.rst:4003
msgid "``'c'``"
msgstr "``'c'``"

#: library/stdtypes.rst:2744
msgid "Single character (accepts integer or single character string)."
msgstr ""
"Μεμονωμένος χαρακτήρας (δέχεται ακέραιο ή μονό χαρακτήρα συμβολοσειράς)."

#: library/stdtypes.rst:4016
msgid "``'r'``"
msgstr "``'r'``"

#: library/stdtypes.rst:2747
msgid "String (converts any Python object using :func:`repr`)."
msgstr ""
"Συμβολοσειρά (μετατρέπει οποιοδήποτε αντικείμενο Python χρησιμοποιώντας :"
"func:`repr`)."

#: library/stdtypes.rst:4010
msgid "``'s'``"
msgstr "``'s'``"

#: library/stdtypes.rst:2750
msgid "String (converts any Python object using :func:`str`)."
msgstr ""
"Συμβολοσειρά (μετατρέπει οποιοδήποτε αντικείμενο Python χρησιμοποιώντας :"
"func:`str`)."

#: library/stdtypes.rst:4013
msgid "``'a'``"
msgstr "``'a'``"

#: library/stdtypes.rst:2753
msgid "String (converts any Python object using :func:`ascii`)."
msgstr ""
"Συμβολοσειρά (μετατρέπει οποιοδήποτε αντικείμενο Python χρησιμοποιώντας :"
"func:`ascii`)."

#: library/stdtypes.rst:4019
msgid "``'%'``"
msgstr "``'%'``"

#: library/stdtypes.rst:4019
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""
"Κανένα όρισμα δεν μετατρέπεται, έχει ως αποτέλεσμα έναν χαρακτήρα ``'%'`` το "
"αποτέλεσμα."

#: library/stdtypes.rst:4026
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr ""
"Η εναλλακτική μορφή προκαλεί την εισαγωγή ενός πρώτου οκταδικού προσδιοριστή "
"(``'0o'``) πριν από το πρώτο ψηφίο."

#: library/stdtypes.rst:4030
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"Η εναλλακτική φόρμα προκαλεί την εισαγωγή ενός αρχικού ``'0x'`` ή ``'0X'`` "
"(ανάλογα με το εάν χρησιμοποιήθηκε η μορφή ``'x'`` ή ``'X'``) πριν το πρώτο "
"ψηφίο."

#: library/stdtypes.rst:4034
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""
"Η εναλλακτική μορφή κάνει το αποτέλεσμα να περιέχει πάντα μια υποδιαστολή, "
"ακόμα κι αν δεν ακολουθούν ψηφία."

#: library/stdtypes.rst:4037
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"Η ακρίβεια καθορίζει τον αριθμό των ψηφίων μετά την υποδιαστολή και ορίζεται "
"από προεπιλογή ως 6."

#: library/stdtypes.rst:4041
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"Η εναλλακτική μορφή κάνει το αποτέλεσμα να περιέχει πάντα μια υποδιαστολή "
"και τα μηδενικά στο τέλος δεν αφαιρούνται όπως θα ήταν διαφορετικά."

#: library/stdtypes.rst:4044
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""
"Η ακρίβεια καθορίζει τον αριθμό των σημαντικών ψηφίων πριν και μετά την "
"υποδιαστολή και ορίζει το 6."

#: library/stdtypes.rst:4048
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "Εάν η ακρίβεια είναι``N``, η έξοδος περικόπτεται σε ``N`` χαρακτήρες."

#: library/stdtypes.rst:4057
msgid "See :pep:`237`."
msgstr "Βλέπε :pep:`237`."

#: library/stdtypes.rst:2790
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Δεδομένου ότι οι συμβολοσειρές Python έχουν ρητό μήκος, οι ``%s`` μετατροπές "
"δεν υποθέτουν ότι το ``'\\0'`` είναι το τέλος της συμβολοσειράς."

#: library/stdtypes.rst:2795
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"Οι μετατροπείς ``%f`` για αριθμούς των οποίων η απόλυτη τιμή είναι "
"μεγαλύτερη από 1e50 δεν αντικαθίστανται πλέον από μετατροπές ``%g``."

#: library/stdtypes.rst:2806
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"
msgstr ""
"Τύποι δυαδικής ακολουθίας --- :class:`bytes`, :class:`bytearray`, :class:"
"`memoryview`"

#: library/stdtypes.rst:2814
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` and :"
"class:`bytearray`. They are supported by :class:`memoryview` which uses the :"
"ref:`buffer protocol <bufferobjects>` to access the memory of other binary "
"objects without needing to make a copy."
msgstr ""
"Οι βασικοί ενσωματωμένοι (built-in) τύποι για τον χειρισμό δυαδικών "
"δεδομένων είναι :class:`bytes` και :class:`bytearray`. Υποστηρίζονται από "
"τη :class:`memoryview` που χρησιμοποιεί το πρωτόκολλο :ref:`buffer protocol "
"<bufferobjects>` για την πρόσβαση στη μνήμη άλλων δυαδικών αντικειμένων "
"χωρίς να χρειάζεται η δημιουργία αντιγράφου."

#: library/stdtypes.rst:2819
msgid ""
"The :mod:`array` module supports efficient storage of basic data types like "
"32-bit integers and IEEE754 double-precision floating values."
msgstr ""
"Το module :mod:`array` υποστηρίζει αποδοτική αποθήκευση για βασικούς τύπους "
"δεδομένων όπως 32-bit ακέραιους και IEEE754 διπλής ακρίβειας κινητής "
"υποδιαστολής τιμές."

#: library/stdtypes.rst:2825
msgid "Bytes Objects"
msgstr "Αντικείμενα Bytes"

#: library/stdtypes.rst:2829
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects offer "
"several methods that are only valid when working with ASCII compatible data "
"and are closely related to string objects in a variety of other ways."
msgstr ""
"Τα αντικείμενα bytes είναι αμετάβλητες ακολουθίες μεμονωμένων bytes. "
"Δεδομένου ότι πολλά κύρια δυαδικά πρωτόκολλα βασίζονται στην κωδικοποίηση "
"κειμένου ASCII, τα αντικείμενα bytes προσφέρουν διάφορες μεθόδους που "
"ισχύουν μόνο όταν εργάζονται με δεδομένα συμβατά με ASCII και σχετίζονται "
"στενά με αντικείμενα συμβολοσειρών σε μια ποικιλία διαφόρων τρόπων."

#: library/stdtypes.rst:2836
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr ""
"Πρώτον, η σύνταξη για τα bytes literals είναι σε μεγάλο βαθμό η ίδια με αυτή "
"για τα literals συμβολοσειρών, με τη διαφορά ότι προστίθεται ένα πρόθεμα "
"``b``::"

#: library/stdtypes.rst:2839
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr ""
"Μονά εισαγωγικά: ``b'ακόμα επιτρέπει ενσωματωμένα \"διπλά\" εισαγωγικά'``"

#: library/stdtypes.rst:2840
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``"
msgstr ""
"Διπλά εισαγωγικά: ``b\"εξακολουθεί να επιτρέπει ενσωματωμένα 'μονά' "
"εισαγωγικά\"``"

#: library/stdtypes.rst:2841
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"
msgstr ""
"Τριπλά εισαγωγικά: ``b'''3 μονά εισαγωγικά'''``, ``b\"\"\"3 διπλά "
"εισαγωγικά\"\"\"``"

#: library/stdtypes.rst:2843
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be entered "
"into bytes literals using the appropriate escape sequence."
msgstr ""
"Επιτρέπονται μόνο χαρακτήρες ASCII σε bytes literals (ανεξάρτητα από τη "
"δηλωμένη κωδικοποίηση του πηγαίου κώδικα). Τυχόν δυαδικές τιμές, πάνω από "
"127, πρέπει να εισαχθούν σε bytes literals χρησιμοποιώντας την κατάλληλη "
"ακολουθία διαφυγής χαρακτήρων."

#: library/stdtypes.rst:2847
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about "
"the various forms of bytes literal, including supported escape sequences."
msgstr ""
"Όπως και με τα literals συμβολοσειρών, τα bytes literals μπορούν επίσης να "
"χρησιμοποιήσουν ένα πρόθεμα ``r`` για να απενεργοποιήσουν την επεξεργασία "
"των ακολουθιών διαφυγής χαρακτήρων. Βλέπε :ref:`strings` για περισσότερες "
"πληροφορίες σχετικά με τις διάφορες μορφές bytes literal, "
"συμπεριλαμβανομένων των υποστηριζόμενων ακολουθιών διαφυγής χαρακτήρων."

#: library/stdtypes.rst:2851
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`). This is done "
"deliberately to emphasise that while many binary formats include ASCII based "
"elements and can be usefully manipulated with some text-oriented algorithms, "
"this is not generally the case for arbitrary binary data (blindly applying "
"text processing algorithms to binary data formats that are not ASCII "
"compatible will usually lead to data corruption)."
msgstr ""
"Ενώ τα bytes literals και οι αναπαραστάσεις βασίζονται σε κείμενο ASCII, τα "
"αντικείμενα bytes συμπεριφέρονται στην πραγματικότητα σαν αμετάβλητες "
"ακολουθίες ακεραίων με κάθε τιμή στην ακολουθία περιορισμένη έτσι ώστε ``0 "
"<= x < 256`` (προσπάθειες παραβίασης αυτού του περιορισμού θα κάνουν raise "
"την :exc:`ValueError`). Αυτό γίνεται σκόπιμα για να τονιστεί ότι, ενώ πολλές "
"δυαδικές μορφές περιλαμβάνουν στοιχεία που βασίζονται σε ASCII και μπορούν "
"να χρησιμοποιηθούν χρήσιμα με ορισμένους αλγορίθμους προσανατολισμένους στο "
"κείμενο, αυτό δεν ισχύει γενικά για αυθαίρετα δυαδικά δεδομένα (τυφλή "
"εφαρμογή αλγορίθμων επεξεργασίας κειμένου σε δυαδικές μορφές δεδομένων που "
"δεν είναι συμβατές με ASCII συνήθως οδηγεί σε καταστροφή δεδομένων)."

#: library/stdtypes.rst:2861
msgid ""
"In addition to the literal forms, bytes objects can be created in a number "
"of other ways:"
msgstr ""
"Εκτός από τις literal μορφές, τα αντικείμενα bytes μπορούν να δημιουργηθούν "
"με πολλούς άλλους τρόπους:"

#: library/stdtypes.rst:2864
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr "Ένα μηδενικό αντικείμενο bytes με καθορισμένο μήκος: ``bytes(10)``"

#: library/stdtypes.rst:2865
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "Από ένα iterable ακεραίων αριθμών: ``bytes(range(20))``"

#: library/stdtypes.rst:2866
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr ""
"Αντιγραφή υπαρχόντων δυαδικών δεδομένων μέσω του πρωτοκόλλου buffer:  "
"``bytes(obj)``"

#: library/stdtypes.rst:2868
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "Δείτε επίσης το ενσωματωμένο :ref:`bytes <func-bytes>`."

#: library/stdtypes.rst:2870
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytes type has an additional class method to read data in "
"that format:"
msgstr ""
"Δεδομένου ότι 2 δεκαεξαδικά ψηφία αντιστοιχούν ακριβώς σε ένα μόνο byte, οι "
"δεκαεξαδικοί αριθμοί είναι μια συνήθως χρησιμοποιούμενη μορφή για την "
"περιγραφή δυαδικών δεδομένων. Συνεπώς, ο τύπος bytes έχει μια πρόσθετη "
"μέθοδο κλάσης για την ανάγνωση δεδομένων σε αυτήν την μορφή:"

#: library/stdtypes.rst:2876
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the given "
"string object.  The string must contain two hexadecimal digits per byte, "
"with ASCII whitespace being ignored."
msgstr ""
"Αυτή η μέθοδος κλάσης :class:`bytes` επιστρέφει ένα αντικείμενο bytes, "
"αποκωδικοποιώντας το δεδομένο αντικείμενο συμβολοσειράς.  Η συμβολοσειρά "
"πρέπει να περιέχει δύο δεκαεξαδικά ψηφία ανά byte, με το κενό διάστημα ASCII "
"να αγνοείται."

#: library/stdtypes.rst:2883
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not just "
"spaces."
msgstr ""
"Το :meth:`bytes.fromhex` παρακάμπτει πλέον όλα τα κενά ASCII στη "
"συμβολοσειρά, όχι μόνο τα κενά."

#: library/stdtypes.rst:2887
msgid ""
":meth:`bytes.fromhex` now accepts ASCII :class:`bytes` and :term:`bytes-like "
"objects <bytes-like object>` as input."
msgstr ""
"Η :meth:`bytes.fromhex` δέχεται πλέον ASCII :class:`bytes` και :term:`bytes-"
"like objects <bytes-like object>` ως είσοδο."

#: library/stdtypes.rst:2891
msgid ""
"A reverse conversion function exists to transform a bytes object into its "
"hexadecimal representation."
msgstr ""
"Υπάρχει μια συνάρτηση αντίστροφης μετατροπής για τη μετατροπή ενός "
"αντικειμένου bytes στην δεκαεξαδική του αναπαράσταση."

#: library/stdtypes.rst:2985
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the instance."
msgstr ""
"Επιστρέφετε ένα αντικείμενο συμβολοσειράς που περιέχει δύο δεκαεξαδικά ψηφία "
"για κάθε byte στο στιγμιότυπο."

#: library/stdtypes.rst:2902
msgid ""
"If you want to make the hex string easier to read, you can specify a single "
"character separator *sep* parameter to include in the output. By default, "
"this separator will be included between each byte. A second optional "
"*bytes_per_sep* parameter controls the spacing. Positive values calculate "
"the separator position from the right, negative values from the left."
msgstr ""
"Εάν θέλετε να κάνετε τη δεκαεξαδική συμβολοσειρά πιο ευανάγνωστη, μπορείτε "
"να καθορίσετε μια παράμετρο διαχωρισμού χαρακτήρων *sep* που θα "
"συμπεριληφθεί στην έξοδο. Από προεπιλογή, αυτό το διαχωριστικό θα "
"περιλαμβάνεται μεταξύ κάθε byte. Μια δεύτερη προαιρετική παράμετρος "
"*bytes_per_sep* ελέγχει τα διαστήματα. Οι θετικές τιμές υπολογίζουν τη θέση "
"του διαχωριστή από τα δεξιά, οι αρνητικές τιμές από τα αριστερά."

#: library/stdtypes.rst:2919
msgid ""
":meth:`bytes.hex` now supports optional *sep* and *bytes_per_sep* parameters "
"to insert separators between bytes in the hex output."
msgstr ""
"Η :meth:`bytes.hex` υποστηρίζει πλέον προαιρετικές παραμέτρους *sep* και "
"*bytes_per_sep* για την εισαγωγή διαχωριστικών μεταξύ των byte στην έξοδο "
"δεκαεξαδικού."

#: library/stdtypes.rst:2923
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a bytes "
"object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a bytes "
"object of length 1.  (This contrasts with text strings, where both indexing "
"and slicing will produce a string of length 1)"
msgstr ""
"Δεδομένου ότι τα αντικείμενα bytes είναι ακολουθίες ακεραίων αριθμών (όμοια "
"με μια πλειάδα (tuple)), για ένα αντικείμενο bytes *b*, το ``b[0]`` θα είναι "
"ένας ακέραιος αριθμός, ενώ το ``b[0:1]`` θα είναι ένα αντικείμενο bytes "
"μήκους 1. (Αυτό έρχεται σε αντίθεση με τις συμβολοσειρές κειμένου, όπου τόσο "
"η λειτουργία πρόσβασης ως ευρετήριο όσο και η λειτουργία τμηματοποίησης θα "
"παράγουν μια συμβολοσειρά μήκους 1)"

#: library/stdtypes.rst:2928
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"Η αναπαράσταση αντικειμένων bytes χρησιμοποιεί την literal μορφή "
"(``b'...'``) , καθώς είναι συχνά πιο χρήσιμη από π.χ. ``bytes([46, 46, "
"46])``.  Μπορείτε πάντα να μετατρέψετε ένα αντικείμενο bytes σε μια λίστα "
"ακέραιων αριθμών που χρησιμοποιούν ``list(b)``."

#: library/stdtypes.rst:2936
msgid "Bytearray Objects"
msgstr "Αντικείμενα Bytearray"

#: library/stdtypes.rst:2940
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ""
"Τα αντικείμενα :class:`bytearray` είναι ένα μεταβλητό, αντίστοιχο, των "
"αντικειμένων :class:`bytes`."

#: library/stdtypes.rst:2945
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they are "
"always created by calling the constructor:"
msgstr ""
"Δεν υπάρχει αποκλειστική literal σύνταξη για αντικείμενα bytearray, αντίθετα "
"δημιουργούνται πάντα καλώντας τον constructor:"

#: library/stdtypes.rst:2948
msgid "Creating an empty instance: ``bytearray()``"
msgstr "Δημιουργία ενός κενού στιγμιοτύπου: ``bytearray()``"

#: library/stdtypes.rst:2949
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr "Δημιουργία μηδενικού στιγμιοτύπου με δεδομένο μήκος: ``bytearray(10)``"

#: library/stdtypes.rst:2950
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "Από έναν iterable αριθμό ακεραίων: ``bytearray(range(20))``"

#: library/stdtypes.rst:2951
msgid ""
"Copying existing binary data via the buffer protocol:  ``bytearray(b'Hi!')``"
msgstr ""
"Αντιγραφή υπαρχόντων δυαδικών δεδομένων μέσω του πρωτοκόλλου buffer:  "
"``bytearray(b'Hi!')``"

#: library/stdtypes.rst:2953
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable <typesseq-"
"mutable>` sequence operations in addition to the common bytes and bytearray "
"operations described in :ref:`bytes-methods`."
msgstr ""
"Καθώς τα αντικείμενα του bytearray είναι μεταβλητά, υποστηρίζουν τις "
"λειτουργίες της ακολουθίας :ref:`mutable <typesseq-mutable>` επιπλέον των "
"κοινών λειτουργιών bytes και bytearray που περιγράφονται στο :ref:`bytes-"
"methods`."

#: library/stdtypes.rst:2957
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr "Δείτε επίσης το ενσωματωμένο :ref:`bytearray <func-bytearray>`."

#: library/stdtypes.rst:2959
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary data. "
"Accordingly, the bytearray type has an additional class method to read data "
"in that format:"
msgstr ""
"Δεδομένου ότι 2 δεκαεξαδικά ψηφία αντιστοιχούν ακριβώς σε ένα μόνο byte, οι "
"δεκαεξαδικοί αριθμοί είναι συνήθως χρησιμοποιούμενη μορφή για την περιγραφή "
"δυαδικών δεδομένων. Συνεπώς, ο τύπος bytearray έχει μια πρόσθετη μέθοδο "
"κλάσης για την ανάγνωση δεδομένων σε αυτήν την μορφή:"

#: library/stdtypes.rst:2965
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"Αυτή η μέθοδος κλάσης :class:`bytearray` επιστρέφει αντικείμενο bytearray, "
"αποκωδικοποιώντας το δεδομένο αντικείμενο συμβολοσειράς.  Η συμβολοσειρά "
"πρέπει να περιέχει δύο δεκαεξαδικά ψηφία ανά byte, με το κενό διάστημα ASCII "
"να αγνοείται."

#: library/stdtypes.rst:2972
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""
"Το :meth:`bytearray.fromhex` παρακάμπτει τώρα όλα τα κενά ASCII στη "
"συμβολοσειρά, όχι μόνο τα κενά."

#: library/stdtypes.rst:2976
msgid ""
":meth:`bytearray.fromhex` now accepts ASCII :class:`bytes` and :term:`bytes-"
"like objects <bytes-like object>` as input."
msgstr ""
"Η :meth:`bytearray.fromhex` δέχεται πλέον το ASCII :class:`bytes` και :term:"
"`bytes-like objects <bytes-like object>` ως είσοδο."

#: library/stdtypes.rst:2980
msgid ""
"A reverse conversion function exists to transform a bytearray object into "
"its hexadecimal representation."
msgstr ""
"Υπάρχει μια συνάρτηση αντίστροφης μετατροπής για να μετατρέψει ένα "
"αντικείμενο bytearray στη δεκαεξαδική αναπαράσταση του."

#: library/stdtypes.rst:2993
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`bytearray.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"Παρόμοια με το :meth:`bytes.hex`, το :meth:`bytearray.hex` υποστηρίζει τώρα "
"προαιρετικές παραμέτρους *sep* και *bytes_per_sep* για την εισαγωγή "
"διαχωριστικών μεταξύ των byte στην δεκαεξαδική έξοδο."

#: library/stdtypes.rst:3000
msgid ""
"Resize the :class:`bytearray` to contain *size* bytes. *size* must be "
"greater than or equal to 0."
msgstr ""
"Αλλάζει το μέγεθος του :class:`bytearray` ώστε αν περιέχει *size* bytes. Το "
"*size* πρέπει να είναι μεγαλύτερο ή ίσο με το 0."

#: library/stdtypes.rst:3003
msgid ""
"If the :class:`bytearray` needs to shrink, bytes beyond *size* are truncated."
msgstr ""
"Εάν η :class:`bytearray` χρειάζεται να συρρικνωθεί, τα bytes πέραν του "
"*size* περικόπτονται."

#: library/stdtypes.rst:3005
msgid ""
"If the :class:`bytearray` needs to grow, all new bytes, those beyond *size*, "
"will be set to null bytes."
msgstr ""
"Εάν η :class:`bytearray` χρειάζεται να αυξηθεί, όλα τα νέα bytes, αυτά που "
"είναι πέρα από το *size*, θα οριστούν σε null bytes."

#: library/stdtypes.rst:3009
msgid "This is equivalent to:"
msgstr "Ισοδύναμο με:"

#: library/stdtypes.rst:3017
msgid "Examples:"
msgstr "Παραδείγματα:"

#: library/stdtypes.rst:3030
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a "
"bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be "
"a bytearray object of length 1.  (This contrasts with text strings, where "
"both indexing and slicing will produce a string of length 1)"
msgstr ""
"Δεδομένου ότι τα αντικείμενα bytearray είναι ακολουθίες ακεραίων αριθμών "
"(παρόμοια με μια λίστα), για ένα αντικείμενο bytearray *b*, το ``b[0]`` θα "
"είναι ένας ακέραιος αριθμός, ενώ το ``b[0:1]`` θα είναι ένα αντικείμενο "
"bytearray μήκους 1.  (Αυτό έρχεται σε αντίθεση με τις συμβολοσειρές "
"κειμένου, όπου τόσο το indexing και το slicing θα παράγουν μια συμβολοσειρά "
"μήκους 1)"

#: library/stdtypes.rst:3035
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object into "
"a list of integers using ``list(b)``."
msgstr ""
"Η αναπαράσταση αντικειμένων bytearray χρησιμοποιεί τη μορφή bytes literal "
"(``bytearray(b'...')``), καθώς είναι συχνά πιο χρήσιμη από π.χ. "
"``bytearray([46, 46, 46])``.  Μπορείτε πάντα να μετατρέψετε ένα αντικείμενο "
"bytearray σε λίστα ακεραίων χρησιμοποιώντας το ``list(b)``."

#: library/stdtypes.rst:3044
msgid "Bytes and Bytearray Operations"
msgstr "Λειτουργίες Bytes και Bytearray"

#: library/stdtypes.rst:3049
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-common>` "
"sequence operations. They interoperate not just with operands of the same "
"type, but with any :term:`bytes-like object`. Due to this flexibility, they "
"can be freely mixed in operations without causing errors. However, the "
"return type of the result may depend on the order of operands."
msgstr ""
"Τόσο τα byte όσο και τα αντικείμενα του πίνακα byte υποστηρίζουν τις "
"λειτουργίες της ακολουθίας :ref:`common <typesseq-common>`. Αλληλεπιδρούν "
"όχι μόνο με τελεστές του ίδιου τύπου, αλλά και με οποιοδήποτε αντικείμενο :"
"term:`bytes-like object`. Λόγω αυτής της ευελιξίας, μπορούν να αναμειχθούν "
"ελεύθερα σε λειτουργίες χωρίς να προκαλούνται σφάλματα. Ωστόσο, ο τύπος "
"επιστροφής του αποτελέσματος μπορεί να εξαρτάται από τη σειρά των τελεστών."

#: library/stdtypes.rst:3057
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"Οι μέθοδοι στα bytes και τα αντικείμενα bytearray δεν δέχονται συμβολοσειρές "
"ως ορίσματά τους, όπως και οι μέθοδοι σε συμβολοσειρές δεν δέχονται bytes ως "
"ορίσματα.  Για παράδειγμα, πρέπει να γράψετε::"

#: library/stdtypes.rst:3061
msgid ""
"a = \"abc\"\n"
"b = a.replace(\"a\", \"f\")"
msgstr ""
"a = \"abc\"\n"
"b = a.replace(\"a\", \"f\")"

#: library/stdtypes.rst:3064
msgid "and::"
msgstr "και::"

#: library/stdtypes.rst:3066
msgid ""
"a = b\"abc\"\n"
"b = a.replace(b\"a\", b\"f\")"
msgstr ""
"a = b\"abc\"\n"
"b = a.replace(b\"a\", b\"f\")"

#: library/stdtypes.rst:3069
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"Ορισμένες λειτουργίες byte και bytearray προϋποθέτουν τη χρήση δυαδικών "
"μορφών συμβατών με ASCII και, ως εκ τούτου, θα πρέπει να αποφεύγονται όταν "
"εργάζεστε με αυθαίρετα δυαδικά δεδομένα. Αυτοί οι περιορισμοί καλύπτονται "
"παρακάτω."

#: library/stdtypes.rst:3074
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"Η χρήση αυτών των λειτουργιών βασίζονται στο ASCII για τον χειρισμό δυαδικών "
"δεδομένων που δεν είναι αποθηκευμένα σε μορφή που βασίζεται σε ASCII μπορεί "
"να οδηγήσει σε καταστροφή δεδομένων."

#: library/stdtypes.rst:3077
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr ""
"Οι ακόλουθες μέθοδοι σε byte και αντικείμενα bytearray μπορούν να "
"χρησιμοποιηθούν με αυθαίρετα δυαδικά δεδομένα."

#: library/stdtypes.rst:3083
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Επιστρέφει τον αριθμό των μη επικαλυπτόμενων εμφανίσεων της δευτερεύουσας "
"ακολουθίας *sub* στο εύρος [*start*, *end*]. Τα προαιρετικά ορίσματα *start* "
"και *end* ερμηνεύονται όπως στη σημειογραφία τμηματοποίησης."

#: library/stdtypes.rst:3192 library/stdtypes.rst:3280
#: library/stdtypes.rst:3293
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr ""
"Η υποακολουθία για αναζήτηση μπορεί να είναι οποιοδήποτε :term:`bytes-like "
"object` ή ένας ακέραιος αριθμός στην περιοχή από 0 έως 255."

#: library/stdtypes.rst:3090
msgid ""
"If *sub* is empty, returns the number of empty slices between characters "
"which is the length of the bytes object plus one."
msgstr ""
"Εάν το *sub* είναι κενό, επιστρέφει τον αριθμό των κενών τμημάτων μεταξύ των "
"χαρακτήρων που είναι το μήκος του αντικειμένου bytes συν ένα."

#: library/stdtypes.rst:3204 library/stdtypes.rst:3283
#: library/stdtypes.rst:3296
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr ""
"Επίσης αποδέχεται έναν ακέραιο αριθμό στο εύρος 0 έως 255 ως υποακολουθία."

#: library/stdtypes.rst:3100
msgid ""
"If the binary data starts with the *prefix* string, return "
"``bytes[len(prefix):]``. Otherwise, return a copy of the original binary "
"data::"
msgstr ""
"Εάν τα δυαδικά δεδομένα ξεκινούν με τη συμβολοσειρά *prefix*, επιστρέφει "
"``bytes[len(prefix):]``. Διαφορετικά επιστρέψτε ένα αντίγραφο των αρχικών "
"δυαδικών δεδομένων::"

#: library/stdtypes.rst:3104
msgid ""
">>> b'TestHook'.removeprefix(b'Test')\n"
"b'Hook'\n"
">>> b'BaseTestCase'.removeprefix(b'Test')\n"
"b'BaseTestCase'"
msgstr ""
">>> b'TestHook'.removeprefix(b'Test')\n"
"b'Hook'\n"
">>> b'BaseTestCase'.removeprefix(b'Test')\n"
"b'BaseTestCase'"

#: library/stdtypes.rst:3109
msgid "The *prefix* may be any :term:`bytes-like object`."
msgstr "Το *prefix* μπορεί να είναι οποιοδήποτε :term:`bytes-like object`."

#: library/stdtypes.rst:3135 library/stdtypes.rst:3361
#: library/stdtypes.rst:3406 library/stdtypes.rst:3462
#: library/stdtypes.rst:3551 library/stdtypes.rst:3718
#: library/stdtypes.rst:3816 library/stdtypes.rst:3859
#: library/stdtypes.rst:4061
msgid ""
"The bytearray version of this method does *not* operate in place - it always "
"produces a new object, even if no changes were made."
msgstr ""
"Η έκδοση bytearray αυτής της μεθόδου *δεν* λειτουργεί στη θέση της - παράγει "
"πάντα ένα νέο αντικείμενο, ακόμα και αν δεν έγιναν αλλαγές."

#: library/stdtypes.rst:3122
msgid ""
"If the binary data ends with the *suffix* string and that *suffix* is not "
"empty, return ``bytes[:-len(suffix)]``.  Otherwise, return a copy of the "
"original binary data::"
msgstr ""
"Εάν τα δυαδικά δεδομένα τελειώνουν με τη συμβολοσειρά *suffix* και αυτό το "
"*suffix* δεν είναι κενό, επιστρέφει ``bytes[:-len(suffix)]``.  Διαφορετικά, "
"επιστρέφει ένα αντίγραφο των αρχικών δυαδικών δεδομένων::"

#: library/stdtypes.rst:3126
msgid ""
">>> b'MiscTests'.removesuffix(b'Tests')\n"
"b'Misc'\n"
">>> b'TmpDirMixin'.removesuffix(b'Tests')\n"
"b'TmpDirMixin'"
msgstr ""
">>> b'MiscTests'.removesuffix(b'Tests')\n"
"b'Misc'\n"
">>> b'TmpDirMixin'.removesuffix(b'Tests')\n"
"b'TmpDirMixin'"

#: library/stdtypes.rst:3131
msgid "The *suffix* may be any :term:`bytes-like object`."
msgstr "Το *suffix* μπορεί να είναι οποιοδήποτε :term:`bytes-like object`."

#: library/stdtypes.rst:3144
msgid "Return the bytes decoded to a :class:`str`."
msgstr "Επιστρέφει τα bytes που έχουν αποκωδικοποιηθεί σε μια :class:`str`."

#: library/stdtypes.rst:3149
msgid ""
"*errors* controls how decoding errors are handled. If ``'strict'`` (the "
"default), a :exc:`UnicodeError` exception is raised. Other possible values "
"are ``'ignore'``, ``'replace'``, and any other name registered via :func:"
"`codecs.register_error`. See :ref:`error-handlers` for details."
msgstr ""
"Το *errors* ελέγχει τον τρόπο χειρισμού των σφαλμάτων αποκωδικοποίησης. Εάν "
"``'strict'`` (η προεπιλογή), γίνεται raise μια εξαίρεση :exc:`UnicodeError`. "
"Άλλες πιθανές τιμές είναι το ``'ignore'``, ``'replace'``, και οποιοδήποτε "
"άλλο όνομα που έχει καταχωρηθεί από την :func:`codecs.register_error`. "
"Βλέπε :ref:`error-handlers` για λεπτομέρειες."

#: library/stdtypes.rst:3155
msgid ""
"For performance reasons, the value of *errors* is not checked for validity "
"unless a decoding error actually occurs, :ref:`devmode` is enabled or a :ref:"
"`debug build <debug-build>` is used."
msgstr ""
"Για λόγους απόδοσης, η τιμή του *errors* δεν ελέγχεται ως προς την "
"εγκυρότητα του, εκτός εάν παρουσιαστεί ένα σφάλμα αποκωδικοποίησης, είναι "
"ενεργοποιημένο το :ref:`devmode` ή χρησιμοποιείται ένα :ref:`debug build "
"<debug-build>`."

#: library/stdtypes.rst:3161
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term:"
"`bytes-like object` directly, without needing to make a temporary :class:`!"
"bytes` or :class:`!bytearray` object."
msgstr ""
"Η μετάδοση του ορίσματος *encoding* στην :class:`str` επιτρέπει την "
"αποκωδικοποίηση οποιουδήποτε :term:`bytes-like object` απευθείας, χωρίς να "
"χρειάζεται να δημιουργήσετε ένα προσωρινό αντικείμενο :class:`!bytes` ή :"
"class:`!bytearray`."

#: library/stdtypes.rst:3176
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Επιστρέφει ``True`` εάν τα δυαδικά δεδομένα τελειώνουν με το καθορισμένο "
"*suffix*, διαφορετικά επιστρέφει ``False``.  Το *suffix* μπορεί επίσης να "
"είναι μια πλειάδα από επιθέματα που πρέπει να αναζητήσετε.  Με το "
"προαιρετικό *start*, η δοκιμή ξεκινά από αυτή τη θέση.  Με το προαιρετικό "
"*end*, σταματήστε να συγκρίνετε σε αυτή τη θέση."

#: library/stdtypes.rst:3181
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"Το(α) επίθεμα(τα) για αναζήτηση μπορεί να είναι οποιοδήποτε :term:`bytes-"
"like object`."

#: library/stdtypes.rst:3187
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found, "
"such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return "
"``-1`` if *sub* is not found."
msgstr ""
"Επιστρέφει το χαμηλότερο index στα δεδομένα όπου βρίσκεται η υποακολουθία "
"*sub*, έτσι ώστε το *sub* να περιέχεται  στο slice ``s[start:end]``.  Τα "
"προαιρετικά ορίσματα *start* και *end* ερμηνεύονται ως συμβολισμό "
"τμηματοποίησης.  Επιστρέφει ``-1`` εάν το *sub* δεν βρεθεί."

#: library/stdtypes.rst:3197
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""
"Η μέθοδος :meth:`~bytes.find` θα πρέπει να χρησιμοποιείται μόνο εάν "
"χρειάζεται να γνωρίζετε τη θέση του *sub*.  Για να ελέγξετε εάν το *sub* "
"είναι υποσυμβολοσειρά ή όχι, χρησιμοποιήστε τον τελεστή :keyword:`in`::"

#: library/stdtypes.rst:3201
msgid ""
">>> b'Py' in b'Python'\n"
"True"
msgstr ""
">>> b'Py' in b'Python'\n"
"True"

#: library/stdtypes.rst:3211
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the subsequence "
"is not found."
msgstr ""
"Όπως η :meth:`~bytes.find`, αλλά κάνει raise μια :exc:`ValueError` όταν δεν "
"βρεθεί η δευτερεύουσα ακολουθία."

#: library/stdtypes.rst:3224
msgid ""
"Return a bytes or bytearray object which is the concatenation of the binary "
"data sequences in *iterable*.  A :exc:`TypeError` will be raised if there "
"are any values in *iterable* that are not :term:`bytes-like objects <bytes-"
"like object>`, including :class:`str` objects.  The separator between "
"elements is the contents of the bytes or bytearray object providing this "
"method."
msgstr ""
"Επιστρέφει ένα αντικείμενο bytes ή bytearray που είναι η συνένωση των "
"δυαδικών ακολουθιών δεδομένων στο *iterable*.  Μια :exc:`TypeError` θα γίνει "
"raise εάν υπάρχουν τιμές στο *iterable* που δεν είναι σαν :term:`bytes-like "
"objects <bytes-like object>`, συμπεριλαμβανομένων των αντικειμένων :class:"
"`str`.  Το διαχωριστικό μεταξύ των στοιχειών είναι τα περιεχόμενα των byte ή "
"του αντικειμένου bytearray που παρέχει αυτή τη μέθοδο."

#: library/stdtypes.rst:3235
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must both be :term:`bytes-like "
"objects <bytes-like object>` and have the same length."
msgstr ""
"Αυτή η στατική μέθοδος επιστρέφει έναν πίνακα μετάφρασης που μπορεί να "
"χρησιμοποιηθεί για την :meth:`bytes.translate` που θα αντιστοιχίσει κάθε "
"χαρακτήρα στο *from* στον χαρακτήρα στην ίδια θέση στο *to*· τα *from* και "
"*to* πρέπει να είναι και τα δύο :term:`bytes-like objects <bytes-like "
"object>` και να έχουν το ίδιο μήκος."

#: library/stdtypes.rst:3246
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing a copy of the original sequence, followed "
"by two empty bytes or bytearray objects."
msgstr ""
"Διαχωρίζει την ακολουθία κατά την πρώτη εμφάνιση του *sep*, και επιστρέφει "
"μια 3-πλειάδα που περιέχει το τμήμα πριν από το διαχωριστικό ή το αντίγραφο "
"του bytearray του και το τμήμα μετά το διαχωριστικό. Εάν δεν βρεθεί το "
"διαχωριστικό, επιστρέφει μια 3-πλειάδα που περιέχει ένα αντίγραφο της "
"αρχικής ακολουθίας, ακολουθούμενη από δύο κενά byte ή αντικείμενα bytearray."

#: library/stdtypes.rst:3310
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr ""
"Το διαχωριστικό για αναζήτηση μπορεί να είναι οποιοδήποτε :term:`bytes-like "
"object`."

#: library/stdtypes.rst:3259
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"Επιστρέφει ένα αντίγραφο της ακολουθίας με όλες τις εμφανίσεις της "
"δευτερεύουσας ακολουθίας *old* αντικαθιστούμενη από την *new*.  Εάν δοθεί το "
"προαιρετικό όρισμα *count*, αντικαθίστανται μόνο οι πρώτες εμφανίσεις "
"*count*."

#: library/stdtypes.rst:3263
msgid ""
"The subsequence to search for and its replacement may be any :term:`bytes-"
"like object`."
msgstr ""
"Η ακολουθία για αναζήτηση και αντικατάσταση της μπορεί να είναι οποιοδήποτε :"
"term:`bytes-like object`."

#: library/stdtypes.rst:3275
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"Επιστρέφει τον υψηλότερο δείκτη στην ακολουθία όπου βρίσκεται η υποακολουθία "
"*sub*, έτσι ώστε το *sub* να περιέχεται στο ``s[start:end]``.  Τα "
"προαιρετικά ορίσματα *start* και *end* ερμηνεύονται με συμβολισμό "
"τμηματοποίησης. Επιστρέφει ``-1`` σε περίπτωση αποτυχίας."

#: library/stdtypes.rst:3290
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the subsequence "
"*sub* is not found."
msgstr ""
"Όπως η :meth:`~bytes.rfind` αλλά κάνει raise μια :exc:`ValueError` όταν δεν "
"βρεθεί η υποακολουθία *sub*."

#: library/stdtypes.rst:3303
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not "
"found, return a 3-tuple containing two empty bytes or bytearray objects, "
"followed by a copy of the original sequence."
msgstr ""
"Διαχωρίζει την ακολουθία στην τελευταία εμφάνιση του *sep*, και επιστρέφει "
"μια 3-πλειάδα που περιέχει το τμήμα πριν από το διαχωριστικό, το ίδιο το "
"διαχωριστικό ή το αντίγραφο του bytearray και το τμήμα μετά το διαχωριστικό. "
"Εάν δεν βρεθεί το διαχωριστικό επιστρέφει μια 3-πλειάδα που περιέχει δύο "
"κενά byte ή αντικείμενα bytearray, ακολουθούμενα από ένα αντίγραφο της "
"αρχικής ακολουθίας."

#: library/stdtypes.rst:3316
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"Επιστρέφει ``True`` εάν τα δυαδικά δεδομένα ξεκινούν με το καθορισμένο "
"*prefix*, διαφορετικά επιστρέφει ``False``. Το *prefix* μπορεί επίσης να "
"είναι μια πλειάδα από προθέματα προς αναζήτηση.  Με το προαιρετικό *start*, "
"η δοκιμή ξεκινά από αυτή τη θέση.  Με το προαιρετικό *end*, σταματάει να "
"συγκρίνει σε αυτή τη θέση."

#: library/stdtypes.rst:3321
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr ""
"Το(α) πρόθεμα(τα) για αναζήτηση μπορεί να είναι οποιοδήποτε :term:`bytes-"
"like object`."

#: library/stdtypes.rst:3327
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""
"Επιστρέφει ένα αντίγραφο των bytes ή του αντικειμένου bytearray όπου "
"αφαιρούνται όλα τα byte που εμφανίζονται στο προαιρετικό όρισμα *delete* και "
"τα υπόλοιπα byte έχουν αντιστοιχιστεί μέσω του δεδομένου πίνακα μετάφρασης, "
"ο οποίος πρέπει να είναι ένα αντικείμενο bytes μήκους 256."

#: library/stdtypes.rst:3332
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""
"Μπορείτε να χρησιμοποιήσετε τη μέθοδο :func:`bytes.maketrans` για να "
"δημιουργήσετε έναν πίνακα μετάφρασης."

#: library/stdtypes.rst:3335
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""
"Ορίζει το όρισμα *table* σε ``None`` για μεταφράσεις που διαγράφουν μόνο "
"χαρακτήρες::"

#: library/stdtypes.rst:3338
msgid ""
">>> b'read this short text'.translate(None, b'aeiou')\n"
"b'rd ths shrt txt'"
msgstr ""
">>> b'read this short text'.translate(None, b'aeiou')\n"
"b'rd ths shrt txt'"

#: library/stdtypes.rst:3341
msgid "*delete* is now supported as a keyword argument."
msgstr "Το *delete* υποστηρίζεται πλέον ως όρισμα λέξης-κλειδιού."

#: library/stdtypes.rst:3345
msgid ""
"The following methods on bytes and bytearray objects have default behaviours "
"that assume the use of ASCII compatible binary formats, but can still be "
"used with arbitrary binary data by passing appropriate arguments. Note that "
"all of the bytearray methods in this section do *not* operate in place, and "
"instead produce new objects."
msgstr ""
"Οι ακόλουθες μέθοδοι σε byte και bytearray αντικείμενα έχουν προεπιλεγμένες "
"συμπεριφορές που προϋποθέτουν τη χρήση δυαδικών μορφών συμβατών με ASCII, "
"αλλά μπορούν να χρησιμοποιηθούν με αυθαίρετα δυαδικά δεδομένα περνώντας "
"κατάλληλα ορίσματα. Σημειώστε ότι όλες οι μέθοδοι bytearray σε αυτήν την "
"ενότητα *δεν* λειτουργούν στη θέση τους και όμως παράγουν νέα αντικείμενα."

#: library/stdtypes.rst:3354
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Επιστρέφει ένα αντίγραφο του αντικειμένου με κέντρο σε μια ακολουθία μήκους "
"*width*. Η συμπλήρωση πραγματοποιείται χρησιμοποιώντας το καθορισμένο "
"*fillbyte* (η προεπιλογή είναι ένα διάστημα ASCII). Για αντικείμενα :class:"
"`bytes, η αρχική ακολουθία επιστρέφεται εάν το *width* είναι μικρότερο ή ίσο "
"με ``len(s)``."

#: library/stdtypes.rst:3368
msgid ""
"Return a copy of the object left justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Επιστρέφει ένα αντίγραφο του αντικειμένου αριστερά ευθυγραμμισμένο σε μια "
"ακολουθία μήκους *width*. Η συμπλήρωση πραγματοποιείται χρησιμοποιώντας το "
"καθορισμένο *fillbyte* (η προεπιλογή είναι ένα διάστημα ASCII). Για "
"αντικείμενα :class:`bytes, η αρχική ακολουθία επιστρέφεται εάν το *width* "
"είναι μικρότερο ή ίσο με ``len(s)``."

#: library/stdtypes.rst:3382
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a prefix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Επιστρέφει ένα αντίγραφο της ακολουθίας με καθορισμένα βασικά byte που έχουν "
"αφαιρεθεί.  Το όρισμα *chars* είναι μια δυαδική ακολουθία που καθορίζει το "
"σύνολο των τιμών byte που πρέπει να αφαιρεθούν - το όνομα αναφέρεται στο "
"γεγονός ότι αυτή η μέθοδος χρησιμοποιείται συνήθως με χαρακτήρες ASCII.  Εάν "
"παραληφθεί ή είναι ``None``, το όρισμα *chars* έχει ως προεπιλογή την "
"αφαίρεση  του κενού διαστήματος  ASCII.  Το όρισμα *chars* δεν είναι "
"πρόθεμα, αλλά οι συνδυασμοί των τιμών του αφαιρούνται:"

#: library/stdtypes.rst:3389
msgid ""
">>> b'   spacious   '.lstrip()\n"
"b'spacious   '\n"
">>> b'www.example.com'.lstrip(b'cmowz.')\n"
"b'example.com'"
msgstr ""
">>> b'   spacious   '.lstrip()\n"
"b'spacious   '\n"
">>> b'www.example.com'.lstrip(b'cmowz.')\n"
"b'example.com'"

#: library/stdtypes.rst:3394
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removeprefix` for a method that will remove a "
"single prefix string rather than all of a set of characters.  For example::"
msgstr ""
"Η δυαδική ακολουθία τιμών byte προς κατάργηση μπορεί να είναι οποιαδήποτε :"
"term:`bytes-like object`. Βλέπε :meth:`~bytes.removeprefix` για μια μέθοδο "
"που θα αφαιρέσει μια μεμονωμένη συμβολοσειρά προθέματος αντί όλο το σύνολο "
"χαρακτήρων.  Για παράδειγμα::"

#: library/stdtypes.rst:3399
msgid ""
">>> b'Arthur: three!'.lstrip(b'Arthur: ')\n"
"b'ee!'\n"
">>> b'Arthur: three!'.removeprefix(b'Arthur: ')\n"
"b'three!'"
msgstr ""
">>> b'Arthur: three!'.lstrip(b'Arthur: ')\n"
"b'ee!'\n"
">>> b'Arthur: three!'.removeprefix(b'Arthur: ')\n"
"b'three!'"

#: library/stdtypes.rst:3413
msgid ""
"Return a copy of the object right justified in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII space). "
"For :class:`bytes` objects, the original sequence is returned if *width* is "
"less than or equal to ``len(s)``."
msgstr ""
"Επιστρέφει ένα αντίγραφο του αντικειμένου ευθυγραμμισμένο δεξιά που "
"δικαιολογείται σε μια ακολουθία μήκους *width*. Η συμπλήρωση "
"πραγματοποιείται χρησιμοποιώντας το καθορισμένο *fillbyte* (η προεπιλογή "
"είναι ένα διάστημα ASCII). Για αντικείμενα :class:`bytes`, η αρχική "
"ακολουθία επιστρέφεται εάν το *width* είναι μικρότερο ή ίσο με ``len(s)``."

#: library/stdtypes.rst:3427
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given, at most *maxsplit* splits are "
"done, the *rightmost* ones.  If *sep* is not specified or ``None``, any "
"subsequence consisting solely of ASCII whitespace is a separator. Except for "
"splitting from the right, :meth:`rsplit` behaves like :meth:`split` which is "
"described in detail below."
msgstr ""
"Διαχωρίζει τη δυαδική ακολουθία σε υποακολουθίες του ίδιου τύπου, "
"χρησιμοποιώντας το *sep* ως συμβολοσειρά οριοθέτησης. Εάν δοθεί *maxsplit*, "
"γίνονται το πολύ *maxsplit* διαχωρισμοί, οι *rightmost*.  Εάν δεν "
"καθορίζεται *sep* ή ``None``, οποιαδήποτε υποακολουθία που αποτελείται "
"αποκλειστικά από κενό διάστημα ASCII είναι διαχωριστικό, εκτός από το "
"διαχωρισμό από τα δεξιά, η :meth:`rsplit` συμπεριφέρεται όπως :meth:`split` "
"που περιγράφεται λεπτομερώς παρακάτω."

#: library/stdtypes.rst:3438
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values to "
"be removed - the name refers to the fact this method is usually used with "
"ASCII characters.  If omitted or ``None``, the *chars* argument defaults to "
"removing ASCII whitespace.  The *chars* argument is not a suffix; rather, "
"all combinations of its values are stripped::"
msgstr ""
"Επιστρέφει ένα αντίγραφο της ακολουθίας με τα καθορισμένα δευτερεύοντα byte "
"που έχουν αφαιρεθεί.  Το όρισμα *chars* είναι μια δυαδική ακολουθία που "
"καθορίζει το σύνολο των τιμών byte που πρέπει να αφαιρεθούν - το όνομα "
"αναφέρεται στο γεγονός ότι αυτή η μέθοδος χρησιμοποιείται συνήθως με "
"χαρακτήρες ASCII.  Εάν παραληφθεί ή είναι ``None``, το όρισμα *chars* έχει "
"ως προεπιλογή την αφαίρεση του κενού διαστήματος ASCII.  Το όρισμα *chars* "
"δεν είναι επίθημα, αλλά αφαιρούνται όλοι οι συνδυασμοί των τιμών του::"

#: library/stdtypes.rst:3445
msgid ""
">>> b'   spacious   '.rstrip()\n"
"b'   spacious'\n"
">>> b'mississippi'.rstrip(b'ipz')\n"
"b'mississ'"
msgstr ""
">>> b'   spacious   '.rstrip()\n"
"b'   spacious'\n"
">>> b'mississippi'.rstrip(b'ipz')\n"
"b'mississ'"

#: library/stdtypes.rst:3450
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`. See :meth:`~bytes.removesuffix` for a method that will remove a "
"single suffix string rather than all of a set of characters.  For example::"
msgstr ""
"Η δυαδική ακολουθία τιμών byte προς κατάργηση μπορεί να είναι οποιοδήποτε :"
"term:`bytes-like object`.  Βλέπε τη :meth:`~bytes.removesuffix` για μια "
"μέθοδο που θα αφαιρέσει μια συμβολοσειρά επιθέματος και όχι όλο το σύνολο "
"χαρακτήρων.  Για παράδειγμα:"

#: library/stdtypes.rst:3455
msgid ""
">>> b'Monty Python'.rstrip(b' Python')\n"
"b'M'\n"
">>> b'Monty Python'.removesuffix(b' Python')\n"
"b'Monty'"
msgstr ""
">>> b'Monty Python'.rstrip(b' Python')\n"
"b'M'\n"
">>> b'Monty Python'.removesuffix(b' Python')\n"
"b'Monty'"

#: library/stdtypes.rst:3469
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep* as "
"the delimiter string. If *maxsplit* is given and non-negative, at most "
"*maxsplit* splits are done (thus, the list will have at most ``maxsplit+1`` "
"elements).  If *maxsplit* is not specified or is ``-1``, then there is no "
"limit on the number of splits (all possible splits are made)."
msgstr ""
"Διαχωρίζει την δυαδική ακολουθία σε υποακολουθίες του ίδιου τύπου, "
"χρησιμοποιώντας το *sep* ως συμβολοσειρά οριοθέτησης Εάν δοθεί *maxsplit* "
"και μη αρνητικό, γίνονται το πολύ *maxsplit* διαχωρισμοί (άρα, η λίστα θα "
"έχε το πολύ ``maxsplit+1`` στοιχεία).  Εάν το *maxsplit* δεν έχει καθοριστεί "
"ή είναι ``-1``, τότε δεν υπάρχει όριο στον αριθμό των διαχωρισμών (όλες οι "
"πιθανές διασπάσεις γίνονται)."

#: library/stdtypes.rst:3475
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty subsequences (for example, ``b'1,,2'.split(b',')`` "
"returns ``[b'1', b'', b'2']``).  The *sep* argument may consist of a "
"multibyte sequence as a single delimiter. Splitting an empty sequence with a "
"specified separator returns ``[b'']`` or ``[bytearray(b'')]`` depending on "
"the type of object being split.  The *sep* argument may be any :term:`bytes-"
"like object`."
msgstr ""
"Αν δοθεί το *sep*, οι διαδοχικοί οριοθέτες δεν ομαδοποιούνται και θεωρείται "
"ότι οριοθετούν κενές υποακολουθίες (για παράδειγμα, ``b'1,,2'.split(b',')`` "
"επιστρέφει το ``[b'1', b'', b'2']``).  Το όρισμα *sep* μπορεί να αποτελείται "
"από μια ακολουθία πολλών byte ως μεμονωμένο οριοθέτη. Ο διαχωρισμός μιας "
"κενής ακολουθίας με ένα καθορισμένο διαχωριστικό επιστρέφει το ``[b'']`` ή "
"το ``[bytearray(b'')]`` ανάλογα με τον τύπο του αντικειμένου που χωρίζεται. "
"Το όρισμα *sep* μπορεί να είναι οποιοδήποτε :term:`bytes-like object`."

#: library/stdtypes.rst:3485
msgid ""
">>> b'1,2,3'.split(b',')\n"
"[b'1', b'2', b'3']\n"
">>> b'1,2,3'.split(b',', maxsplit=1)\n"
"[b'1', b'2,3']\n"
">>> b'1,2,,3,'.split(b',')\n"
"[b'1', b'2', b'', b'3', b'']\n"
">>> b'1<>2<>3<4'.split(b'<>')\n"
"[b'1', b'2', b'3<4']"
msgstr ""
">>> b'1,2,3'.split(b',')\n"
"[b'1', b'2', b'3']\n"
">>> b'1,2,3'.split(b',', maxsplit=1)\n"
"[b'1', b'2,3']\n"
">>> b'1,2,,3,'.split(b',')\n"
"[b'1', b'2', b'', b'3', b'']\n"
">>> b'1<>2<>3<4'.split(b'<>')\n"
"[b'1', b'2', b'3<4']"

#: library/stdtypes.rst:3494
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive ASCII whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or end "
"if the sequence has leading or trailing whitespace.  Consequently, splitting "
"an empty sequence or a sequence consisting solely of ASCII whitespace "
"without a specified separator returns ``[]``."
msgstr ""
"Εάν το *sep* δεν έχει καθοριστεί ή είναι ``None``, εφαρμόζεται ένας "
"διαφορετικός αλγόριθμος διαχωρισμού: οι εκτελέσεις διαδοχικών κενών "
"διαστημάτων ASCII θεωρούνται ως ένα ενιαίο διαχωριστικό, και το αποτέλεσμα "
"δεν θα περιέχει κενές συμβολοσειρές στην αρχή ή στο τέλος, εάν η ακολουθία "
"έχει κενό που έπεται ή προηγείται. Κατά συνέπεια, ο διαχωρισμός μιας κενής "
"ακολουθίας ή μιας ακολουθίας που αποτελείται αποκλειστικά από κενό διάστημα "
"ASCII χωρίς καθορισμένο διαχωριστικό επιστρέφει το ``[]``."

#: library/stdtypes.rst:3504
msgid ""
">>> b'1 2 3'.split()\n"
"[b'1', b'2', b'3']\n"
">>> b'1 2 3'.split(maxsplit=1)\n"
"[b'1', b'2 3']\n"
">>> b'   1   2   3   '.split()\n"
"[b'1', b'2', b'3']"
msgstr ""
">>> b'1 2 3'.split()\n"
"[b'1', b'2', b'3']\n"
">>> b'1 2 3'.split(maxsplit=1)\n"
"[b'1', b'2 3']\n"
">>> b'   1   2   3   '.split()\n"
"[b'1', b'2', b'3']"

#: library/stdtypes.rst:3515
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is not "
"a prefix or suffix; rather, all combinations of its values are stripped::"
msgstr ""
"Επιστρέφει ένα αντίγραφο της ακολουθίας με τα καθορισμένα bytes που "
"προηγούνται και τα bytes που έπονται. Το όρισμα *chars* είναι μια δυαδική "
"ακολουθία που καθορίζει το σύνολο των τιμών byte που πρέπει να αφαιρεθούν - "
"το όνομα αναφέρεται στο γεγονός ότι αυτή η μέθοδος χρησιμοποιείται συνήθως "
"με χαρακτήρες ASCII.  Εάν παραλείπεται ή είναι ``None``, το όρισμα *chars* "
"από προεπιλογή αφαιρεί το ASCII λευκό διάστημα. To όρισμα *chars* δεν είναι "
"πρόθεμα ή επίθημα, αλλά αφαιρούνται όλοι οι συνδυασμοί των τιμών του:"

#: library/stdtypes.rst:3523
msgid ""
">>> b'   spacious   '.strip()\n"
"b'spacious'\n"
">>> b'www.example.com'.strip(b'cmowz.')\n"
"b'example'"
msgstr ""
">>> b'   spacious   '.strip()\n"
"b'spacious'\n"
">>> b'www.example.com'.strip(b'cmowz.')\n"
"b'example'"

#: library/stdtypes.rst:3528
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like "
"object`."
msgstr ""
"Η δυαδική ακολουθία τιμών byte προς αφαίρεση μπορεί να είναι οποιοδήποτε :"
"term:`bytes-like object`."

#: library/stdtypes.rst:3537
msgid ""
"The following methods on bytes and bytearray objects assume the use of ASCII "
"compatible binary formats and should not be applied to arbitrary binary "
"data. Note that all of the bytearray methods in this section do *not* "
"operate in place, and instead produce new objects."
msgstr ""
"Οι ακόλουθες μέθοδοι σε byte και αντικείμενα bytearray προϋποθέτουν τη χρήση "
"δυαδικών μορφών συμβατών με ASCII και δεν πρέπει να εφαρμόζονται σε "
"αυθαίρετα δυαδικά δεδομένα. Σημειώστε ότι όλες οι μέθοδοι bytearray σε αυτήν "
"την ενότητα *δεν* λειτουργούν στη θέση τους και αντ' αυτού παράγουν νέα "
"αντικείμενα."

#: library/stdtypes.rst:3545
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-ASCII "
"byte values are passed through unchanged."
msgstr ""
"Επιστρέφει ένα αντίγραφο της ακολουθίας με κάθε byte να ερμηνεύεται ως ένας "
"χαρακτήρας ASCII, και το πρώτο byte γραμμένο με κεφαλαία και το υπόλοιπο με "
"πεζά. Οι τιμές των byte που δεν είναι ASCII μεταβιβάζονται αμετάβλητες."

#: library/stdtypes.rst:3558
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced by "
"one or more ASCII spaces, depending on the current column and the given tab "
"size.  Tab positions occur every *tabsize* bytes (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the sequence, the "
"current column is set to zero and the sequence is examined byte by byte.  If "
"the byte is an ASCII tab character (``b'\\t'``), one or more space "
"characters are inserted in the result until the current column is equal to "
"the next tab position. (The tab character itself is not copied.)  If the "
"current byte is an ASCII newline (``b'\\n'``) or carriage return "
"(``b'\\r'``), it is copied and the current column is reset to zero.  Any "
"other byte value is copied unchanged and the current column is incremented "
"by one regardless of how the byte value is represented when printed::"
msgstr ""
"Επιστρέφει ένα αντίγραφο της ακολουθίας όπου όλοι οι tab χαρακτήρες ASCII "
"αντικαθίστανται από ένα ή περισσότερα κενά ASCII, ανάλογα με την τρέχουσα "
"στήλη και το δεδομένο μέγεθος tab.  Οι θέσεις των tab εμφανίζονται κάθε "
"*tabsize* bytes (η προεπιλογή είναι 8, δίνοντας θέσεις καρτελών στις στήλες "
"0, 8, 16 και ούτω καθεξής).  Για την επέκταση της ακολουθίας, η τρέχουσα "
"στήλη ορίζεται στο μηδέν και η ακολουθία εξετάζεται byte προς byte.  Εάν το "
"byte είναι tab χαρακτήρας ASCII (``b'\\t'``), ένας ή περισσότεροι χαρακτήρες "
"διαστήματος εισάγονται στο αποτέλεσμα έως ότου η τρέχουσα στήλη ισούται με "
"την επόμενη θέση tab. (Ο ίδιος tab χαρακτήρας δεν αντιγράφεται.)  Εάν το "
"τρέχον byte είναι μια νέα γραμμή ASCII (``b'\\n'``), αντιγράφεται και η "
"τρέχουσα στήλη επαναφέρεται στο μηδέν.  Οποιαδήποτε άλλη τιμή byte "
"αντιγράφεται αμετάβλητη και η τρέχουσα στήλη προσαυξάνεται κατά ένα, "
"ανεξάρτητα από το πώς αναπαρίσταται η τιμή byte όταν εκτυπώνεται::"

#: library/stdtypes.rst:3572
msgid ""
">>> b'01\\t012\\t0123\\t01234'.expandtabs()\n"
"b'01      012     0123    01234'\n"
">>> b'01\\t012\\t0123\\t01234'.expandtabs(4)\n"
"b'01  012 0123    01234'"
msgstr ""
">>> b'01\\t012\\t0123\\t01234'.expandtabs()\n"
"b'01      012     0123    01234'\n"
">>> b'01\\t012\\t0123\\t01234'.expandtabs(4)\n"
"b'01  012 0123    01234'"

#: library/stdtypes.rst:3586
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, ``False`` "
"otherwise. Alphabetic ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. ASCII decimal "
"digits are those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Επιστρέφει ``True`` εάν όλα τα byte της ακολουθίας είναι αλφαβητικοί "
"χαρακτήρες ASCII ή ASCII δεκαδικά ψηφία και η ακολουθία δεν είναι κενή, "
"``False`` διαφορετικά. Οι αλφαβητικοί χαρακτήρες ASCII είναι εκείνες οι "
"τιμές byte στην ακολουθία "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. Τα δεκαδικά "
"ψηφία ASCII είναι αυτές οι τιμές byte στην ακολουθία ``b'0123456789'``."

#: library/stdtypes.rst:3594
msgid ""
">>> b'ABCabc1'.isalnum()\n"
"True\n"
">>> b'ABC abc1'.isalnum()\n"
"False"
msgstr ""
">>> b'ABCabc1'.isalnum()\n"
"True\n"
">>> b'ABC abc1'.isalnum()\n"
"False"

#: library/stdtypes.rst:3603
msgid ""
"Return ``True`` if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, ``False`` otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Επιστρέφει ``True`` εάν όλα τα bytes της ακολουθίας είναι αλφαβητικοί "
"χαρακτήρες ASCII και η ακολουθία δεν είναι κενή, ``False`` διαφορετικά.  Οι "
"αλφαβητικοί χαρακτήρες ASCII είναι εκείνες οι τιμές bytes στην ακολουθία "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: library/stdtypes.rst:3610
msgid ""
">>> b'ABCabc'.isalpha()\n"
"True\n"
">>> b'ABCabc1'.isalpha()\n"
"False"
msgstr ""
">>> b'ABCabc'.isalpha()\n"
"True\n"
">>> b'ABCabc1'.isalpha()\n"
"False"

#: library/stdtypes.rst:3619
msgid ""
"Return ``True`` if the sequence is empty or all bytes in the sequence are "
"ASCII, ``False`` otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""
"Επιστρέφει ``True`` εάν η ακολουθία είναι κενή ή όλα τα byte της ακολουθίας "
"είναι ASCII, ``False`` διαφορετικά. Τα bytes ASCII βρίσκονται στο εύρος "
"0-0x7F."

#: library/stdtypes.rst:3629
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII decimal digits and "
"the sequence is not empty, ``False`` otherwise. ASCII decimal digits are "
"those byte values in the sequence ``b'0123456789'``."
msgstr ""
"Επιστρέφει ``True`` εάν όλα τα bytes στην ακολουθία είναι δεκαδικά ψηφία "
"ASCII και η ακολουθία δεν είναι κενή, ``False`` διαφορετικά. Τα δεκαδικά "
"ψηφία ASCII είναι αυτές οι τιμές byte στην ακολουθία ``b'0123456789'``."

#: library/stdtypes.rst:3635
msgid ""
">>> b'1234'.isdigit()\n"
"True\n"
">>> b'1.23'.isdigit()\n"
"False"
msgstr ""
">>> b'1234'.isdigit()\n"
"True\n"
">>> b'1.23'.isdigit()\n"
"False"

#: library/stdtypes.rst:3644
msgid ""
"Return ``True`` if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, ``False`` otherwise."
msgstr ""
"Επιστρέφει ``True`` εάν υπάρχει τουλάχιστον ένας πεζός χαρακτήρας ASCII στην "
"ακολουθία και κανένας κεφαλαίος χαρακτήρας ASCII, ``False`` διαφορετικά."

#: library/stdtypes.rst:3649
msgid ""
">>> b'hello world'.islower()\n"
"True\n"
">>> b'Hello world'.islower()\n"
"False"
msgstr ""
">>> b'hello world'.islower()\n"
"True\n"
">>> b'Hello world'.islower()\n"
"False"

#: library/stdtypes.rst:3696 library/stdtypes.rst:3762
#: library/stdtypes.rst:3831
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"Οι πεζοί χαρακτήρες ASCII είναι αυτές οι τιμές byte στην ακολουθία "
"``b'abcdefghijklmnopqrstuvwxyz'``. Οι κεφαλαίοι χαρακτήρες ASCII είναι αυτές "
"οι τιμές byte στην ακολουθία ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."

#: library/stdtypes.rst:3662
msgid ""
"Return ``True`` if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, ``False`` otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"Επιστρέφει ``True`` εάν όλα τα byte στην ακολουθία είναι κενά ASCII και η "
"ακολουθία δεν είναι κενή, ``False`` διαφορετικά.  Οι χαρακτήρες κενού "
"διαστήματος ASCII είναι αυτές οι τιμές byte στην ακολουθία ``b' "
"\\t\\n\\r\\x0b\\f'`` (κενό, tab, νέα γραμμή, επιστροφή μεταφοράς, κάθετο "
"tab, μορφή ροής)."

#: library/stdtypes.rst:3671
msgid ""
"Return ``True`` if the sequence is ASCII titlecase and the sequence is not "
"empty, ``False`` otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"Επιστρέφει ``True`` εάν η ακολουθία είναι ASCII κεφαλαία τίτλου (δηλαδή τα "
"πρώτα γράμματα των λέξεων κεφαλαία) και η ακολουθία δεν είναι κενή, "
"``False`` διαφορετικά. Δείτε :meth:`bytes.title` για περισσότερες "
"λεπτομέρειες σχετικά με τον ορισμό του \"titlecase\"."

#: library/stdtypes.rst:3677
msgid ""
">>> b'Hello World'.istitle()\n"
"True\n"
">>> b'Hello world'.istitle()\n"
"False"
msgstr ""
">>> b'Hello World'.istitle()\n"
"True\n"
">>> b'Hello world'.istitle()\n"
"False"

#: library/stdtypes.rst:3686
msgid ""
"Return ``True`` if there is at least one uppercase alphabetic ASCII "
"character in the sequence and no lowercase ASCII characters, ``False`` "
"otherwise."
msgstr ""
"Επιστρέφει ``True`` εάν υπάρχει τουλάχιστον ένας κεφαλαίος αλφαβητικός "
"χαρακτήρας ASCII στην ακολουθία και κανένας πεζός χαρακτήρας ASCII, "
"διαφορετικά ``False``."

#: library/stdtypes.rst:3691
msgid ""
">>> b'HELLO WORLD'.isupper()\n"
"True\n"
">>> b'Hello world'.isupper()\n"
"False"
msgstr ""
">>> b'HELLO WORLD'.isupper()\n"
"True\n"
">>> b'Hello world'.isupper()\n"
"False"

#: library/stdtypes.rst:3704
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr ""
"Επιστρέφει ένα αντίγραφο της ακολουθίας με όλους τους κεφαλαίους χαρακτήρες "
"ASCII να έχουν μετατραπεί στα ισοδύναμα πεζά."

#: library/stdtypes.rst:3709
msgid ""
">>> b'Hello World'.lower()\n"
"b'hello world'"
msgstr ""
">>> b'Hello World'.lower()\n"
"b'hello world'"

#: library/stdtypes.rst:3729
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line "
"boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list unless "
"*keepends* is given and true."
msgstr ""
"Επιστρέφει μια λίστα με τις γραμμές στη δυαδική ακολουθία, σπάζοντας τα όρια "
"γραμμής του ASCII. Αυτή η μέθοδος χρησιμοποιεί την προσέγγιση :term:"
"`universal newlines` για τον διαχωρισμό των γραμμών. Οι αλλαγές γραμμής δεν "
"περιλαμβάνονται στη λίστα που προκύπτει εκτός εάν δοθεί *keepends* και είναι "
"αληθής."

#: library/stdtypes.rst:3736
msgid ""
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"[b'ab c', b'', b'de fg', b'kl']\n"
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']"
msgstr ""
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()\n"
"[b'ab c', b'', b'de fg', b'kl']\n"
">>> b'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(keepends=True)\n"
"[b'ab c\\n', b'\\n', b'de fg\\r', b'kl\\r\\n']"

#: library/stdtypes.rst:3741
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line::"
msgstr ""
"Σε αντίθεση με το :meth:`~bytes.split` όταν δίνεται μια οριοθετημένη "
"συμβολοσειρά *sep*, αυτή η μέθοδος επιστρέφει μια κενή λίστα για την κενή "
"συμβολοσειρά και μια αλλαγή γραμμής τερματικού δεν οδηγεί σε μια επιπλέον "
"γραμμή::"

#: library/stdtypes.rst:3745
msgid ""
">>> b\"\".split(b'\\n'), b\"Two lines\\n\".split(b'\\n')\n"
"([b''], [b'Two lines', b''])\n"
">>> b\"\".splitlines(), b\"One line\\n\".splitlines()\n"
"([], [b'One line'])"
msgstr ""
">>> b\"\".split(b'\\n'), b\"Two lines\\n\".split(b'\\n')\n"
"([b''], [b'Two lines', b''])\n"
">>> b\"\".splitlines(), b\"One line\\n\".splitlines()\n"
"([], [b'One line'])"

#: library/stdtypes.rst:3754
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr ""
"Επιστρέφει ένα αντίγραφο της ακολουθίας με όλους τους πεζούς χαρακτήρες "
"ASCII να έχουν μετατραπεί στο αντίστοιχο ισοδύναμο κεφαλαίο και αντίστροφα."

#: library/stdtypes.rst:3759
msgid ""
">>> b'Hello World'.swapcase()\n"
"b'hELLO wORLD'"
msgstr ""
">>> b'Hello World'.swapcase()\n"
"b'hELLO wORLD'"

#: library/stdtypes.rst:3766
msgid ""
"Unlike :func:`str.swapcase`, it is always the case that ``bin.swapcase()."
"swapcase() == bin`` for the binary versions. Case conversions are "
"symmetrical in ASCII, even though that is not generally true for arbitrary "
"Unicode code points."
msgstr ""
"Σε αντίθεση με το :func:`str.swapcase`, συμβαίνει πάντα ότι ``bin.swapcase()."
"swapcase() == bin`` για τις δυαδικές εκδόσεις. Οι μετατροπές κεφαλαίων είναι "
"συμμετρικές στο ASCII, παρόλο που αυτό δεν ισχύει γενικά για αυθαίρετα "
"σημεία Unicode κώδικα."

#: library/stdtypes.rst:3780
msgid ""
"Return a titlecased version of the binary sequence where words start with an "
"uppercase ASCII character and the remaining characters are lowercase. "
"Uncased byte values are left unmodified."
msgstr ""
"Επιστρέφει μια έκδοση με κεφαλαία τίτλου (δηλαδή τα πρώτα γράμματα των "
"λέξεων κεφαλαία) της δυαδικής ακολουθίας όπου οι λέξεις ξεκινούν με κεφαλαίο "
"χαρακτήρα ASCII και οι υπόλοιποι χαρακτήρες είναι πεζοί. Οι τιμές byte χωρίς "
"κεφαλαία γράμματα παραμένουν χωρίς τροποποίηση."

#: library/stdtypes.rst:3786
msgid ""
">>> b'Hello world'.title()\n"
"b'Hello World'"
msgstr ""
">>> b'Hello world'.title()\n"
"b'Hello World'"

#: library/stdtypes.rst:3789
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those byte "
"values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other byte "
"values are uncased."
msgstr ""
"Οι πεζοί χαρακτήρες ASCII είναι εκείνες οι τιμές byte στην ακολουθία "
"``b'abcdefghijklmnopqrstuvwxyz'``. Οι κεφαλαίο χαρακτήρες ASCII είναι "
"εκείνες οι τιμές byte στην ακολουθία ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. Όλες "
"οι άλλες τιμές byte είναι χωρίς κεφαλαία."

#: library/stdtypes.rst:3799
msgid ""
">>> b\"they're bill's friends from the UK\".title()\n"
"b\"They'Re Bill'S Friends From The Uk\""
msgstr ""
">>> b\"they're bill's friends from the UK\".title()\n"
"b\"They'Re Bill'S Friends From The Uk\""

#: library/stdtypes.rst:3802
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Μια λύση για αποστρόφους μπορεί να δημιουργηθεί χρησιμοποιώντας κανονικές "
"εκφράσεις::"

#: library/stdtypes.rst:3804
msgid ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0)[0:1].upper() +\n"
"...                              mo.group(0)[1:].lower(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(b\"they're bill's friends.\")\n"
"b\"They're Bill's Friends.\""
msgstr ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(rb\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0)[0:1].upper() +\n"
"...                              mo.group(0)[1:].lower(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(b\"they're bill's friends.\")\n"
"b\"They're Bill's Friends.\""

#: library/stdtypes.rst:3823
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr ""
"Επιστρέφει ένα αντίγραφο της ακολουθίας με όλους τους πεζούς χαρακτήρες "
"ASCII να έχουν μετατραπεί στο αντίστοιχο ισοδύναμο κεφαλαίο."

#: library/stdtypes.rst:3828
msgid ""
">>> b'Hello World'.upper()\n"
"b'HELLO WORLD'"
msgstr ""
">>> b'Hello World'.upper()\n"
"b'HELLO WORLD'"

#: library/stdtypes.rst:3844
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to make "
"a sequence of length *width*. A leading sign prefix (``b'+'``/ ``b'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(seq)``."
msgstr ""
"Επιστρέφει ένα αντίγραφο της ακολουθίας που έχει απομείνει γεμάτο με ψηφία "
"ASCII ``b'0'`` για να δημιουργήσετε μια ακολουθία μήκους *width*. Ένα "
"πρόθεμα προπορευόμενου σήματος (``b'+'``/ ``b'-'``) αντιμετωπίζεται με την "
"εισαγωγή της συμπλήρωσης του *after* χαρακτήρα προσήμου και όχι πριν. Για "
"αντικείμενα :class:`bytes`, η αρχική ακολουθία επιστρέφεται εάν το *width* "
"είναι μικρότερο ή ίσο με ``len(seq)``."

#: library/stdtypes.rst:3852
msgid ""
">>> b\"42\".zfill(5)\n"
"b'00042'\n"
">>> b\"-42\".zfill(5)\n"
"b'-0042'"
msgstr ""
">>> b\"42\".zfill(5)\n"
"b'00042'\n"
">>> b\"-42\".zfill(5)\n"
"b'-0042'"

#: library/stdtypes.rst:3866
msgid "``printf``-style Bytes Formatting"
msgstr "Μορφοποίηση Bytes τύπου ``printf``"

#: library/stdtypes.rst:3883
msgid ""
"The formatting operations described here exhibit a variety of quirks that "
"lead to a number of common errors (such as failing to display tuples and "
"dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"Οι λειτουργίες μορφοποίησης που περιγράφονται εδώ παρουσιάζουν μια ποικιλία "
"ιδιορρυθμιών που οδηγούν σε μια σειρά από κοινά σφάλματα (όπως η αποτυχία "
"εμφάνισης των πλειάδων και των λεξικών σωστά).  Εάν η τιμή που εκτυπώνεται "
"μπορεί να είναι πλειάδα ή λεξικό, κάντε το wrap σε μια πλειάδα."

#: library/stdtypes.rst:3888
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in operation: "
"the ``%`` operator (modulo). This is also known as the bytes *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"bytes object), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the :c:"
"func:`sprintf` in the C language."
msgstr ""
"Τα αντικείμενα bytes (``bytes``/``bytearray``) έχουν μια μοναδική "
"ενσωματωμένη λειτουργία: τον τελεστή ``%`` (modulo). Αυτό είναι επίσης "
"γνωστό ως τελεστής bytes *formatting* ή *interpolation*. Δεδομένων των "
"``format % values`` (όπου το *format* είναι αντικείμενο bytes), οι "
"προδιαγραφές μετατροπής ``%`` σε *format* αντικαθιστά με μηδέν ή περισσότερα "
"στοιχεία *values*. Το αποτέλεσμα είναι παρόμοιο με τη χρήση του :c:func:"
"`sprintf` στη γλώσσας C."

#: library/stdtypes.rst:3895
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format bytes object, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Εάν το *format* απαιτεί ένα μεμονωμένο όρισμα, το *values* μπορεί να είναι "
"ένα μεμονωμένο μη πολλαπλό αντικείμενο. [5]_ Διαφορετικά, το *values* πρέπει "
"να είναι πλειάδα με ακριβώς τον αριθμό των στοιχείων που καθορίζονται από το "
"αντικείμενο μορφής bytes ή μεμονωμένο mapping αντικείμενο (για παράδειγμα, "
"ένα λεξικό)."

#: library/stdtypes.rst:3929
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the bytes object *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Όταν το σωστό όρισμα είναι ένα λεξικό (ή άλλος τύπος αντιστοίχισης), τότε οι "
"μορφές στο αντικείμενο bytes *πρέπει* να περιλαμβάνουν ένα κλειδί "
"αντιστοίχισης σε παρένθεση σε αυτό το λεξικό που έχει εισαχθεί αμέσως μετά "
"τον χαρακτήρα ``'%'``. Το κλειδί αντιστοίχισης επιλέγει την τιμή που θα "
"μορφοποιηθεί από την αντιστοίχιση.  Για παράδειγμα:"

#: library/stdtypes.rst:4003
msgid "Single byte (accepts integer or single byte objects)."
msgstr "Μονό byte (δέχεται ακέραια ή μεμονωμένα byte αντικείμενα)."

#: library/stdtypes.rst:4006
msgid "``'b'``"
msgstr "``'b'``"

#: library/stdtypes.rst:4006
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>` or "
"has :meth:`~object.__bytes__`)."
msgstr ""
"Bytes (κάθε αντικείμενο που ακολουθεί το :ref:`buffer protocol "
"<bufferobjects>` ή έχει :meth:`~object.__bytes__`)."

#: library/stdtypes.rst:4010
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"Το ``'s'`` είναι ένα ψευδώνυμο για το ``'b'`` και θα πρέπει να "
"χρησιμοποιείται μόνο για κώδικα βάσει Python2/3."

#: library/stdtypes.rst:4013
msgid ""
"Bytes (converts any Python object using ``repr(obj).encode('ascii', "
"'backslashreplace')``)."
msgstr ""
"Bytes (μετατρέπει οποιοδήποτε αντικείμενο Python χρησιμοποιώντας ``repr(obj)."
"encode('ascii', 'backslashreplace')``)."

#: library/stdtypes.rst:4016
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 code "
"bases."
msgstr ""
"Το ``'r'`` είναι ένα ψευδώνυμο για ``'a'`` και θα πρέπει να χρησιμοποιείται "
"μόνο για βάσεις κώδικα Python2/3."

#: library/stdtypes.rst:4016
msgid "\\(7)"
msgstr "\\(7)"

#: library/stdtypes.rst:4051
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr ""
"Το ``b'%s'`` έχει καταργηθεί, αλλά δεν θα αφαιρεθεί κατά τη διάρκεια της "
"σειράς 3.x."

#: library/stdtypes.rst:4054
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr ""
"Το ``b'%r'`` έχει καταργηθεί, αλλά δεν θα αφαιρεθεί κατά τη διάρκεια της "
"σειράς 3.x."

#: library/stdtypes.rst:4066
msgid ":pep:`461` - Adding % formatting to bytes and bytearray"
msgstr ":pep:`461` - Προσθήκη % για μορφοποίηση σε bytes και bytearray"

#: library/stdtypes.rst:4073
msgid "Memory Views"
msgstr "Όψεις Μνήμης"

#: library/stdtypes.rst:4075
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying."
msgstr ""
"Τα αντικείμενα :class:`memoryview` επιτρέπουν στον κώδικα Python να έχει "
"πρόσβαση στα εσωτερικά δεδομένα ενός αντικειμένου που υποστηρίζει το "
"πρωτόκολλο :ref:`buffer protocol <bufferobjects>` χωρίς αντιγραφή."

#: library/stdtypes.rst:4081
msgid ""
"Create a :class:`memoryview` that references *object*.  *object* must "
"support the buffer protocol.  Built-in objects that support the buffer "
"protocol include :class:`bytes` and :class:`bytearray`."
msgstr ""
"Δημιουργεί μια :class:`memoryview` που αναφέρεται στο *object*.  Το *object* "
"πρέπει να υποστηρίζει το πρωτόκολλο buffer.  Τα ενσωματωμένα αντικείμενα που "
"υποστηρίζουν το πρωτόκολλο buffer περιλαμβάνουν :class:`bytes` και :class:"
"`bytearray`."

#: library/stdtypes.rst:4085
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating *object*.  For many simple types such "
"as :class:`bytes` and :class:`bytearray`, an element is a single byte, but "
"other types such as :class:`array.array` may have bigger elements."
msgstr ""
"Μια :class:`memoryview` έχει την έννοια ενός *στοιχείου*, το οποίο είναι η "
"μονάδα ατομικής μνήμης που χειρίζεται το αρχικό *object*.  Για πολλούς "
"απλούς τύπους όπως :class:`bytes` και :class:`bytearray`, ένα στοιχείο είναι "
"ένα μεμονωμένο byte, αλλά άλλοι τύποι όπως :class:`array.array` μπορεί να "
"έχουν μεγαλύτερα στοιχεία."

#: library/stdtypes.rst:4090
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`, which "
"is the nested list representation of the view. If ``view.ndim = 1``, this is "
"equal to the number of elements in the view."
msgstr ""
"Το ``len(view)`` ισούται με το μήκος του :class:`~memoryview.tolist`, το "
"οποίο είναι η ένθετη αναπαράσταση κατά την προβολή της λίστας. Εάν ``view."
"ndim = 1``, αυτό ισούται με τον αριθμό των στοιχείων για την προβολή."

#: library/stdtypes.rst:4094
msgid ""
"If ``view.ndim == 0``, ``len(view)`` now raises :exc:`TypeError` instead of "
"returning 1."
msgstr ""
"Εάν ``view.ndim == 0``, το ``len(view)`` τώρα κάνει raise μια :exc:"
"`TypeError` αντί να επιστρέψει 1."

#: library/stdtypes.rst:4097
msgid ""
"The :class:`~memoryview.itemsize` attribute will give you the number of "
"bytes in a single element."
msgstr ""
"Το χαρακτηριστικό :class:`~memoryview.itemsize` θα σας δώσει τον αριθμό των "
"byte σε ένα μόνο στοιχείο."

#: library/stdtypes.rst:4100
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. One-"
"dimensional slicing will result in a subview::"
msgstr ""
"Μια :class:`memoryview` υποστηρίζει λειτουργίες τμηματοποίησης και πρόσβαση "
"μέσω ευρετηρίου στα δεδομένα του. Μια μονοδιάστατη τμηματοποίηση θα έχει ως "
"αποτέλεσμα μια δευτερεύουσα προβολή::"

#: library/stdtypes.rst:4103
msgid ""
">>> v = memoryview(b'abcefg')\n"
">>> v[1]\n"
"98\n"
">>> v[-1]\n"
"103\n"
">>> v[1:4]\n"
"<memory at 0x7f3ddc9f4350>\n"
">>> bytes(v[1:4])\n"
"b'bce'"
msgstr ""
">>> v = memoryview(b'abcefg')\n"
">>> v[1]\n"
"98\n"
">>> v[-1]\n"
"103\n"
">>> v[1:4]\n"
"<memory at 0x7f3ddc9f4350>\n"
">>> bytes(v[1:4])\n"
"b'bce'"

#: library/stdtypes.rst:4113
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers from "
"the :mod:`struct` module, indexing with an integer or a tuple of integers is "
"also supported and returns a single *element* with the correct type.  One-"
"dimensional memoryviews can be indexed with an integer or a one-integer "
"tuple.  Multi-dimensional memoryviews can be indexed with tuples of exactly "
"*ndim* integers where *ndim* is the number of dimensions.  Zero-dimensional "
"memoryviews can be indexed with the empty tuple."
msgstr ""
"Εάν το :class:`~memoryview.format` είναι ένας από τους προσδιοριστές "
"εγγενούς μορφής από το module :mod:`struct`, η πρόσβαση μέσω ευρετηρίου με "
"έναν ακέραιο ή μια πλειάδα (tuple) ακεραίων υποστηρίζεται επίσης και "
"επιστρέφει ένα μεμονωμένο *στοιχείο* με το σωστό τύπο.  Τα μονοδιάστατα "
"memoryviews μπορούν να γίνουν indexed με έναν ακέραιο ή έναν ακέραιο πλειάδα "
"(tuple).  Τα πολυδιάστατα memoryviews μπορούν αν γίνουν indexed με πλειάδες "
"(tuples) ακριβώς *ndim* ακεραίων όπου *ndim* είναι ο αριθμός των "
"διαστάσεων.  Τα μηδενικών διαστάσεων memoryviews μπορούν να γίνουν indexed "
"με την κενή πλειάδα (tuple)."

#: library/stdtypes.rst:4122
msgid "Here is an example with a non-byte format::"
msgstr "Ακολουθεί ένα παράδειγμα με μη-byte μορφή::"

#: library/stdtypes.rst:4124
msgid ""
">>> import array\n"
">>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])\n"
">>> m = memoryview(a)\n"
">>> m[0]\n"
"-11111111\n"
">>> m[-1]\n"
"44444444\n"
">>> m[::2].tolist()\n"
"[-11111111, -33333333]"
msgstr ""
">>> import array\n"
">>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])\n"
">>> m = memoryview(a)\n"
">>> m[0]\n"
"-11111111\n"
">>> m[-1]\n"
"44444444\n"
">>> m[::2].tolist()\n"
"[-11111111, -33333333]"

#: library/stdtypes.rst:4134
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr ""
"Εάν το βασικό αντικείμενο είναι εγγράψιμο, το memoryview υποστηρίζει "
"μονοδιάστατη εκχώρηση τμηματοποίησης. Δεν επιτρέπεται η αλλαγή μεγέθους::"

#: library/stdtypes.rst:4137
msgid ""
">>> data = bytearray(b'abcefg')\n"
">>> v = memoryview(data)\n"
">>> v.readonly\n"
"False\n"
">>> v[0] = ord(b'z')\n"
">>> data\n"
"bytearray(b'zbcefg')\n"
">>> v[1:4] = b'123'\n"
">>> data\n"
"bytearray(b'z123fg')\n"
">>> v[2:3] = b'spam'\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: memoryview assignment: lvalue and rvalue have different "
"structures\n"
">>> v[2:6] = b'spam'\n"
">>> data\n"
"bytearray(b'z1spam')"
msgstr ""
">>> data = bytearray(b'abcefg')\n"
">>> v = memoryview(data)\n"
">>> v.readonly\n"
"False\n"
">>> v[0] = ord(b'z')\n"
">>> data\n"
"bytearray(b'zbcefg')\n"
">>> v[1:4] = b'123'\n"
">>> data\n"
"bytearray(b'z123fg')\n"
">>> v[2:3] = b'spam'\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: memoryview assignment: lvalue and rvalue have different "
"structures\n"
">>> v[2:6] = b'spam'\n"
">>> data\n"
"bytearray(b'z1spam')"

#: library/stdtypes.rst:4155
msgid ""
"One-dimensional memoryviews of :term:`hashable` (read-only) types with "
"formats 'B', 'b' or 'c' are also hashable. The hash is defined as ``hash(m) "
"== hash(m.tobytes())``::"
msgstr ""
"Τα μονοδιάστατα memoryviews των τύπων :term:`hashable` (μόνο για ανάγνωση) "
"με μορφές 'B', 'b' ή 'c' μπορούν επίσης να κατακερματιστούν. Ο "
"κατακερματισμός ορίζεται ως ``hash(m) == hash(m.tobytes())``::"

#: library/stdtypes.rst:4159
msgid ""
">>> v = memoryview(b'abcefg')\n"
">>> hash(v) == hash(b'abcefg')\n"
"True\n"
">>> hash(v[2:4]) == hash(b'ce')\n"
"True\n"
">>> hash(v[::-2]) == hash(b'abcefg'[::-2])\n"
"True"
msgstr ""
">>> v = memoryview(b'abcefg')\n"
">>> hash(v) == hash(b'abcefg')\n"
"True\n"
">>> hash(v[2:4]) == hash(b'ce')\n"
"True\n"
">>> hash(v[::-2]) == hash(b'abcefg'[::-2])\n"
"True"

#: library/stdtypes.rst:4167
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional memoryviews "
"with formats 'B', 'b' or 'c' are now :term:`hashable`."
msgstr ""
"Τα μονοδιάστατα memoryviews μπορούν πλέον να τμηματοποιηθούν. Τα "
"μονοδιάστατα memoryviews με μορφές 'B', 'b' ή 'c' είναι πλέον :term:"
"`hashable`."

#: library/stdtypes.rst:4171
msgid ""
"memoryview is now registered automatically with :class:`collections.abc."
"Sequence`"
msgstr ""
"το memoryview εγγράφεται πλέον αυτόματα με :class:`collections.abc.Sequence`"

#: library/stdtypes.rst:4175
msgid "memoryviews can now be indexed with tuple of integers."
msgstr ""
"τα memoryviews μπορούν τώρα να γίνουν ευρετηριοποίηση με πλειάδα (tuple) "
"ακεραίων."

#: library/stdtypes.rst:4178
msgid "memoryview is now a :term:`generic type`."
msgstr "Το memoryview είναι πλέον ένα :term:`generic type`."

#: library/stdtypes.rst:4181
msgid ":class:`memoryview` has several methods:"
msgstr "το :class:`memoryview` έχει διάφορες μεθόδους:"

#: library/stdtypes.rst:4185
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"Ένα memoryview και ένας εξαγωγέας :pep:`3118` είναι ίσοι εάν τα σχήματα τους "
"είναι ισοδύναμα και εάν όλες οι αντίστοιχες τιμές είναι ίσες όταν οι "
"αντίστοιχοι κωδικοί μορφής των τελεστών ερμηνεύονται χρησιμοποιώντας τη "
"σύνταξη :mod:`struct`."

#: library/stdtypes.rst:4189
msgid ""
"For the subset of :mod:`struct` format strings currently supported by :meth:"
"`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == w.tolist()``::"
msgstr ""
"Για το υποσύνολο του :mod:`struct` οι συμβολοσειρές μορφής που "
"υποστηρίζονται αυτή τη στιγμή από το :meth:`tolist`, ``v`` και ``w`` είναι "
"ίσες εάν ``v.tolist() == w.tolist()``::"

#: library/stdtypes.rst:4192
msgid ""
">>> import array\n"
">>> a = array.array('I', [1, 2, 3, 4, 5])\n"
">>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n"
">>> c = array.array('b', [5, 3, 1])\n"
">>> x = memoryview(a)\n"
">>> y = memoryview(b)\n"
">>> x == a == y == b\n"
"True\n"
">>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\n"
"True\n"
">>> z = y[::-2]\n"
">>> z == c\n"
"True\n"
">>> z.tolist() == c.tolist()\n"
"True"
msgstr ""
">>> import array\n"
">>> a = array.array('I', [1, 2, 3, 4, 5])\n"
">>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])\n"
">>> c = array.array('b', [5, 3, 1])\n"
">>> x = memoryview(a)\n"
">>> y = memoryview(b)\n"
">>> x == a == y == b\n"
"True\n"
">>> x.tolist() == a.tolist() == y.tolist() == b.tolist()\n"
"True\n"
">>> z = y[::-2]\n"
">>> z == c\n"
"True\n"
">>> z.tolist() == c.tolist()\n"
"True"

#: library/stdtypes.rst:4208
msgid ""
"If either format string is not supported by the :mod:`struct` module, then "
"the objects will always compare as unequal (even if the format strings and "
"buffer contents are identical)::"
msgstr ""
"Εάν καμία συμβολοσειρά μορφής δεν υποστηρίζεται από το module :mod:`struct`, "
"τότε τα αντικείμενα θα συγκρίνονται πάντα ως άνισα (ακόμα και αν οι "
"συμβολοσειρές μορφοποίησης και τα περιεχόμενα της προσωρινής μνήμης είναι "
"πανομοιότυπα)::"

#: library/stdtypes.rst:4212
msgid ""
">>> from ctypes import BigEndianStructure, c_long\n"
">>> class BEPoint(BigEndianStructure):\n"
"...     _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n"
"...\n"
">>> point = BEPoint(100, 200)\n"
">>> a = memoryview(point)\n"
">>> b = memoryview(point)\n"
">>> a == point\n"
"False\n"
">>> a == b\n"
"False"
msgstr ""
">>> from ctypes import BigEndianStructure, c_long\n"
">>> class BEPoint(BigEndianStructure):\n"
"...     _fields_ = [(\"x\", c_long), (\"y\", c_long)]\n"
"...\n"
">>> point = BEPoint(100, 200)\n"
">>> a = memoryview(point)\n"
">>> b = memoryview(point)\n"
">>> a == point\n"
"False\n"
">>> a == b\n"
"False"

#: library/stdtypes.rst:4224
msgid ""
"Note that, as with floating-point numbers, ``v is w`` does *not* imply ``v "
"== w`` for memoryview objects."
msgstr ""
"Λάβετε υπόψη ότι, όπως και με τους αριθμούς κινητής υποδιαστολής, ``v is w`` "
"*δεν* σημαίνει ``v == w`` για αντικείμενα memoryview."

#: library/stdtypes.rst:4227
msgid ""
"Previous versions compared the raw memory disregarding the item format and "
"the logical array structure."
msgstr ""
"Οι προηγούμενες εκδόσεις συνέκριναν την ακατέργαστη μνήμη αγνοώντας τη μορφή "
"του στοιχείου και τη δομή του λογικού πίνακα."

#: library/stdtypes.rst:4233
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""
"Επιστρέφει τα δεδομένα στο buffer ως ένα bytestring.  Αυτό ισοδυναμεί με την "
"κλήση του κατασκευαστή :class:`bytes` στο memoryview. ::"

#: library/stdtypes.rst:4236
msgid ""
">>> m = memoryview(b\"abc\")\n"
">>> m.tobytes()\n"
"b'abc'\n"
">>> bytes(m)\n"
"b'abc'"
msgstr ""
">>> m = memoryview(b\"abc\")\n"
">>> m.tobytes()\n"
"b'abc'\n"
">>> bytes(m)\n"
"b'abc'"

#: library/stdtypes.rst:4242
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in :mod:`struct` "
"module syntax."
msgstr ""
"Για μη συνεχόμενους πίνακες, το αποτέλεσμα είναι ίσο με την αναπαράσταση της "
"ισοπεδωμένης λίστας με όλα τα στοιχεία να μετατρέπονται σε bytes. Η :meth:"
"`tobytes` υποστηρίζει όλες τις συμβολοσειρές μορφής, συμπεριλαμβανομένων "
"εκείνων που δεν είναι στη σύνταξη του module :mod:`struct`."

#: library/stdtypes.rst:4247
msgid ""
"*order* can be {'C', 'F', 'A'}.  When *order* is 'C' or 'F', the data of the "
"original array is converted to C or Fortran order. For contiguous views, 'A' "
"returns an exact copy of the physical memory. In particular, in-memory "
"Fortran order is preserved. For non-contiguous views, the data is converted "
"to C first. *order=None* is the same as *order='C'*."
msgstr ""
"Το *order* μπορεί να είναι {'C', 'F', 'A'}.  Όταν το *order* είναι 'C' ή "
"'F', τα δεδομένα του αρχικού πίνακα μετατρέπονται σε C ή σε σειρά Fortran. "
"Για συνεχόμενες όψεις, το 'A' επιστρέφει ένα ακριβές αντίγραφο της φυσικής "
"μνήμης. Συγκεκριμένα, διατηρείται σειρά Fortran στη μνήμη. Για μη "
"συνεχόμενες προβολές, τα δεδομένα μετατρέπονται πρώτα σε C. Το *order=None* "
"είναι το ίδιο με το *order='C'*."

#: library/stdtypes.rst:4256
msgid ""
"Return a string object containing two hexadecimal digits for each byte in "
"the buffer. ::"
msgstr ""
"Επιστρέφει ένα αντικείμενο συμβολοσειράς που περιέχει δύο δεκαεξαδικά ψηφία "
"για κάθε byte στο buffer. ::"

#: library/stdtypes.rst:4259
msgid ""
">>> m = memoryview(b\"abc\")\n"
">>> m.hex()\n"
"'616263'"
msgstr ""
">>> m = memoryview(b\"abc\")\n"
">>> m.hex()\n"
"'616263'"

#: library/stdtypes.rst:4265
msgid ""
"Similar to :meth:`bytes.hex`, :meth:`memoryview.hex` now supports optional "
"*sep* and *bytes_per_sep* parameters to insert separators between bytes in "
"the hex output."
msgstr ""
"Παρόμοιο με το :meth:`bytes.hex`, το :meth:`memoryview.hex` τώρα υποστηρίζει "
"προαιρετικές παραμέτρους *sep* και *bytes_per_sep* για να εισάγετε "
"διαχωριστικά μεταξύ των byte στην εξαγωγή δεκαεξαδικού."

#: library/stdtypes.rst:4272
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "Επιστρέψτε τα δεδομένα στο buffer ως λίστα στοιχείων. ::"

#: library/stdtypes.rst:4274
msgid ""
">>> memoryview(b'abc').tolist()\n"
"[97, 98, 99]\n"
">>> import array\n"
">>> a = array.array('d', [1.1, 2.2, 3.3])\n"
">>> m = memoryview(a)\n"
">>> m.tolist()\n"
"[1.1, 2.2, 3.3]"
msgstr ""
">>> memoryview(b'abc').tolist()\n"
"[97, 98, 99]\n"
">>> import array\n"
">>> a = array.array('d', [1.1, 2.2, 3.3])\n"
">>> m = memoryview(a)\n"
">>> m.tolist()\n"
"[1.1, 2.2, 3.3]"

#: library/stdtypes.rst:4282
msgid ""
":meth:`tolist` now supports all single character native formats in :mod:"
"`struct` module syntax as well as multi-dimensional representations."
msgstr ""
"Η :meth:`tolist` υποστηρίζει πλέον όλες τις εγγενείς μορφές μεμονωμένων "
"χαρακτήρων στη σύνταξη του :mod:`struct`, καθώς και πολυδιάστατες "
"αναπαραστάσεις."

#: library/stdtypes.rst:4289
msgid ""
"Return a readonly version of the memoryview object.  The original memoryview "
"object is unchanged. ::"
msgstr ""
"Επιστρέφει μια έκδοση μόνο για ανάγνωση του αντικειμένου memoryview.  Το "
"αρχικό αντικείμενο memoryview είναι αμετάβλητο. ::"

#: library/stdtypes.rst:4292
msgid ""
">>> m = memoryview(bytearray(b'abc'))\n"
">>> mm = m.toreadonly()\n"
">>> mm.tolist()\n"
"[97, 98, 99]\n"
">>> mm[0] = 42\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: cannot modify read-only memory\n"
">>> m[0] = 43\n"
">>> mm.tolist()\n"
"[43, 98, 99]"
msgstr ""
">>> m = memoryview(bytearray(b'abc'))\n"
">>> mm = m.toreadonly()\n"
">>> mm.tolist()\n"
"[97, 98, 99]\n"
">>> mm[0] = 42\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: cannot modify read-only memory\n"
">>> m[0] = 43\n"
">>> mm.tolist()\n"
"[43, 98, 99]"

#: library/stdtypes.rst:4308
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"Απελευθερώνει το υποκείμενο buffer που εκτίθεται από το αντικείμενο "
"memoryview.  Πολλά αντικείμενα πραγματοποιούν ειδικές ενέργειες όταν "
"διατηρείται μια προβολή σε αυτά (για παράδειγμα, μια :class:`bytearray` θα "
"απαγόρευε προσωρινά την αλλαγή μεγέθους)· επομένως, η κλήση της release() "
"είναι βολική για την κατάργηση αυτών των περιορισμών (και απελευθερώνει "
"οποιουσδήποτε αιωρούμενους πόρους) το συντομότερο δυνατό."

#: library/stdtypes.rst:4314
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release` itself which can be called "
"multiple times)::"
msgstr ""
"Μετά την κλήση αυτής της μεθόδου, οποιαδήποτε περαιτέρω λειτουργία στην "
"προβολή δημιουργεί μια :class:`ValueError` (εκτός από την ίδια την :meth:"
"`release` που μπορεί να κληθεί πολλές φορές)::"

#: library/stdtypes.rst:4318
msgid ""
">>> m = memoryview(b'abc')\n"
">>> m.release()\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"
msgstr ""
">>> m = memoryview(b'abc')\n"
">>> m.release()\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"

#: library/stdtypes.rst:4325
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""
"Το πρωτόκολλο διαχείρισης περιεχομένου μπορεί να χρησιμοποιηθεί για παρόμοιο "
"αποτέλεσμα, χρησιμοποιώντας τη δήλωση ``with``::"

#: library/stdtypes.rst:4328
msgid ""
">>> with memoryview(b'abc') as m:\n"
"...     m[0]\n"
"...\n"
"97\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"
msgstr ""
">>> with memoryview(b'abc') as m:\n"
"...     m[0]\n"
"...\n"
"97\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"

#: library/stdtypes.rst:4341
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be "
"one-dimensional. The return value is a new memoryview, but the buffer itself "
"is not copied. Supported casts are 1D -> C-:term:`contiguous` and C-"
"contiguous -> 1D."
msgstr ""
"Μορφοποιεί ένα memoryview σε νέα μορφή ή σχήμα. Το *shape* είναι από "
"προεπιλογή ``[byte_length//new_itemsize]``, που σημαίνει ότι η προβολή "
"αποτελέσματος θα είναι μονοδιάστατη. Η επιστρεφόμενη τιμή είναι ένα νέο "
"memoryview, αλλά το ίδιο το buffer δεν αντιγράφεται. Οι υποστηριζόμενες "
"μετατροπές είναι 1D -> C-:term:`contiguous` και C-contiguous -> 1D."

#: library/stdtypes.rst:4347
msgid ""
"The destination format is restricted to a single element native format in :"
"mod:`struct` syntax. One of the formats must be a byte format ('B', 'b' or "
"'c'). The byte length of the result must be the same as the original length. "
"Note that all byte lengths may depend on the operating system."
msgstr ""
"Η μορφή προορισμού περιορίζεται σε μια εγγενή μορφή μεμονωμένου στοιχείου "
"στη σύνταξη :mod:`struct`. Μία από τις μορφές πρέπει να είναι μορφή byte "
"('B', 'b' ή 'c'). Το μήκος byte του αποτελέσματος πρέπει να είναι το ίδιο με "
"το αρχικό μήκος. Σημειώστε ότι όλα τα μήκη byte μπορεί να εξαρτώνται από το "
"λειτουργικό σύστημα."

#: library/stdtypes.rst:4353
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "Μορφοποίηση από 1D/long σε 1D/unsigned bytes::"

#: library/stdtypes.rst:4355
msgid ""
">>> import array\n"
">>> a = array.array('l', [1,2,3])\n"
">>> x = memoryview(a)\n"
">>> x.format\n"
"'l'\n"
">>> x.itemsize\n"
"8\n"
">>> len(x)\n"
"3\n"
">>> x.nbytes\n"
"24\n"
">>> y = x.cast('B')\n"
">>> y.format\n"
"'B'\n"
">>> y.itemsize\n"
"1\n"
">>> len(y)\n"
"24\n"
">>> y.nbytes\n"
"24"
msgstr ""
">>> import array\n"
">>> a = array.array('l', [1,2,3])\n"
">>> x = memoryview(a)\n"
">>> x.format\n"
"'l'\n"
">>> x.itemsize\n"
"8\n"
">>> len(x)\n"
"3\n"
">>> x.nbytes\n"
"24\n"
">>> y = x.cast('B')\n"
">>> y.format\n"
"'B'\n"
">>> y.itemsize\n"
"1\n"
">>> len(y)\n"
"24\n"
">>> y.nbytes\n"
"24"

#: library/stdtypes.rst:4376
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "Μορφοποίηση από 1D/unsigned bytes σε 1D/char::"

#: library/stdtypes.rst:4378
msgid ""
">>> b = bytearray(b'zyz')\n"
">>> x = memoryview(b)\n"
">>> x[0] = b'a'\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: memoryview: invalid type for format 'B'\n"
">>> y = x.cast('c')\n"
">>> y[0] = b'a'\n"
">>> b\n"
"bytearray(b'ayz')"
msgstr ""
">>> b = bytearray(b'zyz')\n"
">>> x = memoryview(b)\n"
">>> x[0] = b'a'\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: memoryview: invalid type for format 'B'\n"
">>> y = x.cast('c')\n"
">>> y[0] = b'a'\n"
">>> b\n"
"bytearray(b'ayz')"

#: library/stdtypes.rst:4389
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "Μορφοποίηση από 1D/bytes σε 3D/ints σε 1D/signed char::"

#: library/stdtypes.rst:4391
msgid ""
">>> import struct\n"
">>> buf = struct.pack(\"i\"*12, *list(range(12)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('i', shape=[2,2,3])\n"
">>> y.tolist()\n"
"[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]\n"
">>> y.format\n"
"'i'\n"
">>> y.itemsize\n"
"4\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> z = y.cast('b')\n"
">>> z.format\n"
"'b'\n"
">>> z.itemsize\n"
"1\n"
">>> len(z)\n"
"48\n"
">>> z.nbytes\n"
"48"
msgstr ""
">>> import struct\n"
">>> buf = struct.pack(\"i\"*12, *list(range(12)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('i', shape=[2,2,3])\n"
">>> y.tolist()\n"
"[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]\n"
">>> y.format\n"
"'i'\n"
">>> y.itemsize\n"
"4\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> z = y.cast('b')\n"
">>> z.format\n"
"'b'\n"
">>> z.itemsize\n"
"1\n"
">>> len(z)\n"
"48\n"
">>> z.nbytes\n"
"48"

#: library/stdtypes.rst:4415
msgid "Cast 1D/unsigned long to 2D/unsigned long::"
msgstr "Μορφοποίηση από 1D/unsigned long σε 2D/unsigned long::"

#: library/stdtypes.rst:4417
msgid ""
">>> buf = struct.pack(\"L\"*6, *list(range(6)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('L', shape=[2,3])\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> y.tolist()\n"
"[[0, 1, 2], [3, 4, 5]]"
msgstr ""
">>> buf = struct.pack(\"L\"*6, *list(range(6)))\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('L', shape=[2,3])\n"
">>> len(y)\n"
"2\n"
">>> y.nbytes\n"
"48\n"
">>> y.tolist()\n"
"[[0, 1, 2], [3, 4, 5]]"

#: library/stdtypes.rst:4429
msgid "The source format is no longer restricted when casting to a byte view."
msgstr ""
"Η πηγαία μορφή δεν είναι πλέον περιορισμένη κατά τη μορφοποίηση σε μια όψη "
"byte."

#: library/stdtypes.rst:4434
msgid "Count the number of occurrences of *value*."
msgstr "Μετράει τον αριθμό των εμφανίσεων του *value*."

#: library/stdtypes.rst:4440
msgid ""
"Return the index of the first occurrence of *value* (at or after index "
"*start* and before index *stop*)."
msgstr ""
"Επιστρέφει τον δείκτη της πρώτης εμφάνισης του *value* (στην ή μετά τον "
"δείκτη *start* και πριν από τον δείκτη *stop*)."

#: library/stdtypes.rst:4443
msgid "Raises a :exc:`ValueError` if *value* cannot be found."
msgstr ""
"Κάνει raise μια :exc:`ValueError` αν δεν μπορεί να βρεθεί η τιμή *value*."

#: library/stdtypes.rst:4447
msgid "There are also several readonly attributes available:"
msgstr "Υπάρχουν επίσης αρκετά διαθέσιμα χαρακτηριστικά μόνο για ανάγνωση:"

#: library/stdtypes.rst:4451
msgid "The underlying object of the memoryview::"
msgstr "Το βασικό αντικείμενο του memoryview::"

#: library/stdtypes.rst:4453
msgid ""
">>> b  = bytearray(b'xyz')\n"
">>> m = memoryview(b)\n"
">>> m.obj is b\n"
"True"
msgstr ""
">>> b  = bytearray(b'xyz')\n"
">>> m = memoryview(b)\n"
">>> m.obj is b\n"
"True"

#: library/stdtypes.rst:4462
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to ``len(m)``::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. Αυτή είναι η "
"ποσότητα χώρου σε byte που θα χρησιμοποιούσε ο πίνακας σε μια συνεχόμενη "
"αναπαράσταση. Δεν ισούται απαραίτητα με ``len(m)``::"

#: library/stdtypes.rst:4466
msgid ""
">>> import array\n"
">>> a = array.array('i', [1,2,3,4,5])\n"
">>> m = memoryview(a)\n"
">>> len(m)\n"
"5\n"
">>> m.nbytes\n"
"20\n"
">>> y = m[::2]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"12\n"
">>> len(y.tobytes())\n"
"12"
msgstr ""
">>> import array\n"
">>> a = array.array('i', [1,2,3,4,5])\n"
">>> m = memoryview(a)\n"
">>> len(m)\n"
"5\n"
">>> m.nbytes\n"
"20\n"
">>> y = m[::2]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"12\n"
">>> len(y.tobytes())\n"
"12"

#: library/stdtypes.rst:4481
msgid "Multi-dimensional arrays::"
msgstr "Πολυδιάστατοι πίνακες::"

#: library/stdtypes.rst:4483
msgid ""
">>> import struct\n"
">>> buf = struct.pack(\"d\"*12, *[1.5*x for x in range(12)])\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('d', shape=[3,4])\n"
">>> y.tolist()\n"
"[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"96"
msgstr ""
">>> import struct\n"
">>> buf = struct.pack(\"d\"*12, *[1.5*x for x in range(12)])\n"
">>> x = memoryview(buf)\n"
">>> y = x.cast('d', shape=[3,4])\n"
">>> y.tolist()\n"
"[[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]\n"
">>> len(y)\n"
"3\n"
">>> y.nbytes\n"
"96"

#: library/stdtypes.rst:4498
msgid "A bool indicating whether the memory is read only."
msgstr "Ένα bool που υποδεικνύει εάν η μνήμη είναι μόνο για ανάγνωση."

#: library/stdtypes.rst:4502
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"Μια συμβολοσειρά που περιέχει τη μορφή (σε module style :mod:`struct`) για "
"κάθε στοιχείο σε μια όψη. Μπορεί να δημιουργηθεί ένα memoryview από "
"εξαγωγείς με συμβολοσειρές αυθαίρετης μορφής, αλλά ορισμένες μέθοδοι (π.χ. :"
"meth:`tolist`) είναι περιορισμένες σε εγγενείς μορφές ενός στοιχείου."

#: library/stdtypes.rst:4507
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This "
"means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"η μορφή ``'B'`` αντιμετωπίζεται πλέον σύμφωνα με τη σύνταξη ενός struct "
"module. Αυτό σημαίνει ότι ``memoryview(b'abc')[0] == b'abc'[0] == 97``."

#: library/stdtypes.rst:4513
msgid "The size in bytes of each element of the memoryview::"
msgstr "Το μέγεθος σε bytes κάθε στοιχείου στο memoryview::"

#: library/stdtypes.rst:4515
msgid ""
">>> import array, struct\n"
">>> m = memoryview(array.array('H', [32000, 32001, 32002]))\n"
">>> m.itemsize\n"
"2\n"
">>> m[0]\n"
"32000\n"
">>> struct.calcsize('H') == m.itemsize\n"
"True"
msgstr ""
">>> import array, struct\n"
">>> m = memoryview(array.array('H', [32000, 32001, 32002]))\n"
">>> m.itemsize\n"
"2\n"
">>> m[0]\n"
"32000\n"
">>> struct.calcsize('H') == m.itemsize\n"
"True"

#: library/stdtypes.rst:4526
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Ένα ακέραιος αριθμός που δείχνει πόσες διαστάσεις ενός πολυδιάστατου πίνακα "
"αντιπροσωπεύει η μνήμη."

#: library/stdtypes.rst:4531
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"Μια πλειάδα (tuple) ακεραίων με μήκος :attr:`ndim` δίνοντας το σχήμα της "
"μνήμης ως πίνακα N-διαστάσεων."

#: library/stdtypes.rst:4542
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "Μια κενή πλειάδα (tuple) αντί για ``None`` όταν ndim = 0."

#: library/stdtypes.rst:4539
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"Μια πλειάδα ακεραίων με μήκος :attr:`ndim` που δίνει το μέγεθος σε bytes για "
"την πρόσβαση σε κάθε στοιχείο για κάθε διάσταση του πίνακα."

#: library/stdtypes.rst:4547
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr ""
"Χρησιμοποιείται εσωτερικά για συστοιχίες τύπου PIL. Η τιμή είναι μόνο "
"ενημερωτική."

#: library/stdtypes.rst:4551
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "Ένα bool που υποδεικνύει εάν η μνήμη είναι C-:term:`contiguous`."

#: library/stdtypes.rst:4557
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "Ένα bool που υποδεικνύει εάν η μνήμη είναι Fortran :term:`contiguous`."

#: library/stdtypes.rst:4563
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "Ένα bool που υποδεικνύει εάν η μνήμη είναι :term:`contiguous`."

#: library/stdtypes.rst:4571
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Τύποι Συνόλου (Set) --- :class:`set`, :class:`frozenset`"

#: library/stdtypes.rst:4575
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built-"
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""
"Ένα αντικείμενο :dfn:`set` είναι μια μη ταξινομημένη συλλογή από διακριτά "
"αντικείμενα :term:`hashable`. Οι συνήθεις χρήσεις περιλαμβάνουν τη δοκιμή "
"ιδιότητας μέλους, την αφαίρεση διπλότυπων από μια ακολουθία και τον "
"υπολογισμό μαθηματικών πράξεων όπως τομή, ένωση, διαφορά, και συμμετρική "
"διαφορά. (Για άλλα containers, δείτε τις ενσωματωμένες κλάσεις :class:"
"`dict`, :class:`list`, και :class:`tuple` και το module :mod:`collections`)."

#: library/stdtypes.rst:4582
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Όπως και άλλες συλλογές, τα σύνολα (sets) υποστηρίζουν ``x in set``, "
"``len(set)``, και ``for x in set``.  Όντως μια μη ταξινομημένη συλλογή, τα "
"σύνολα δεν καταγράφουν τη θέση του στοιχείου ή τη σειρά εισαγωγής.  Συνεπώς, "
"τα σύνολα (sets) δεν υποστηρίζουν λειτουργίες ευρετηριοποίησης, "
"τμηματοποίησης ή άλλη συμπεριφορά ακολουθίας."

#: library/stdtypes.rst:4587
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since "
"it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type "
"is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element "
"of another set."
msgstr ""
"Υπάρχουν αυτή τη στιγμή δύο ενσωματωμένοι τύποι συνόλου, :class:`set` και :"
"class:`frozenset`. Ο τύπος :class:`set` είναι ευμετάβλητος --- τα "
"περιεχόμενα του μπορούν να αλλάξουν χρησιμοποιώντας μεθόδους όπως :meth:"
"`~set.add` και :meth:`~set.remove`.  Δεδομένου ότι είναι ευμετάβλητο, δεν "
"έχει τιμή κατακερματισμού και δεν μπορεί να χρησιμοποιηθεί ούτε ως κλειδί "
"λεξικού ούτε ως στοιχείο ενός άλλου συνόλου (set).  Ο τύπος :class:"
"`frozenset` είναι αμετάβλητος και :term:`hashable` --- το περιεχόμενό του "
"δεν μπορεί να αλλάξει μετά τη δημιουργία του· μπορεί επομένως να "
"χρησιμοποιηθεί ως κλειδί λεξικού ή ως στοιχείο άλλου συνόλου (set)."

#: library/stdtypes.rst:4595
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""
"Μπορούν να δημιουργηθούν μη κενά σύνολα (όχι παγωμένα σύνολα (frozensets)) "
"τοποθετώντας μια λίστα στοιχείων διαχωρισμένων με κόμμα μέσα σε αγκύλες, για "
"παράδειγμα: ``{'jack', 'sjoerd'}``, επιπλέον με τη χρήση του constructor "
"του :class:`set`."

#: library/stdtypes.rst:4599
msgid "The constructors for both classes work the same:"
msgstr "Οι constructors και για τις δύο κλάσεις λειτουργούν το ίδιο:"

#: library/stdtypes.rst:4604
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Επιστρέφει ένα νέο σύνολο (set) ή ένα παγωμένο σύνολο (frozenset) των οποίων "
"τα στοιχεία έχουν ληφθεί από το *iterable*.  Τα στοιχεία ενός συνόλου πρέπει "
"να είναι :term:`hashable`.  Για να αναπαραστήσουν σύνολα συνόλων, τα "
"εσωτερικά σύνολα πρέπει να είναι :class:`frozenset` αντικείμενα.  Εάν δεν "
"έχει καθοριστεί το *iterable*, επιστρέφεται ένα νέο κενό σύνολο."

#: library/stdtypes.rst:4610
msgid "Sets can be created by several means:"
msgstr "Τα σύνολα μπορούν να δημιουργηθούν με διάφορους τρόπους:"

#: library/stdtypes.rst:4612
msgid ""
"Use a comma-separated list of elements within braces: ``{'jack', 'sjoerd'}``"
msgstr ""
"Χρησιμοποιώντας μια λίστα στοιχείων διαχωρισμένη με κόμματα: ``{'jack', "
"'sjoerd'}``"

#: library/stdtypes.rst:4613
msgid ""
"Use a set comprehension: ``{c for c in 'abracadabra' if c not in 'abc'}``"
msgstr ""
"Χρησιμοποιώντας ένα set comprehension: ``{c for c in 'abracadabra' if c not "
"in 'abc'}``"

#: library/stdtypes.rst:4614
msgid ""
"Use the type constructor: ``set()``, ``set('foobar')``, ``set(['a', 'b', "
"'foo'])``"
msgstr ""
"Χρησιμοποιώντας τον τύπο constructor: ``set()``, ``set('foobar')``, "
"``set(['a', 'b', 'foo'])``"

#: library/stdtypes.rst:4616
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
"Τα στιγμιότυπα των :class:`set` και :class:`frozenset` παρέχουν τις "
"ακόλουθες λειτουργίες:"

#: library/stdtypes.rst:4621
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr ""
"Επιστρέφει τον αριθμό των στοιχείων στο σύνολο *s* (πληθικότητα του *s*)."

#: library/stdtypes.rst:4625
msgid "Test *x* for membership in *s*."
msgstr "Ελέγχει αν το *x* είναι μέρος στο *s*."

#: library/stdtypes.rst:4629
msgid "Test *x* for non-membership in *s*."
msgstr "Ελέγχει αν το *x* δεν είναι μέρος στο *s*."

#: library/stdtypes.rst:4633
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""
"Επιστρέφει ``True`` εάν το σύνολο δεν έχει κοινά στοιχεία με το *other*.  Τα "
"σύνολα είναι ασύνδετα εάν και μόνο εάν η τομή τους είναι το κενό σύνολο."

#: library/stdtypes.rst:4639
msgid "Test whether every element in the set is in *other*."
msgstr "Ελέγχει εάν κάθε στοιχείο στο σύνολο βρίσκεται στο *other*."

#: library/stdtypes.rst:4643
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Ελέγχει εάν το σύνολο είναι σωστό υποσύνολο του *other*, δηλαδή, ``set <= "
"other and set != other``."

#: library/stdtypes.rst:4649
msgid "Test whether every element in *other* is in the set."
msgstr "Ελέγχει αν κάθε στοιχείο του *other* είναι στο σύνολο."

#: library/stdtypes.rst:4653
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Ελέγχει αν το σύνολο είναι σωστό υπερσύνολο του *other*, δηλαδή, ``set >= "
"other and set != other``."

#: library/stdtypes.rst:4659
msgid "Return a new set with elements from the set and all others."
msgstr "Επιστρέφει ένα νέο σύνολο με στοιχεία από το σύνολο και όλα τα άλλα."

#: library/stdtypes.rst:4664
msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Επιστρέφει ένα νέο σύνολο με στοιχεία κοινά στο σύνολο και σε όλα τα άλλα."

#: library/stdtypes.rst:4669
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""
"Επιστρέφει ένα νέο σύνολο με στοιχεία στο σύνολο που δεν υπάρχουν στα άλλα."

#: library/stdtypes.rst:4674
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Επιστρέφει ένα νέο σύνολο με στοιχεία είτε στο σύνολο είτε στο *other* αλλά "
"όχι και στα δύο."

#: library/stdtypes.rst:4678
msgid "Return a shallow copy of the set."
msgstr "Επιστρέφει ένα ρηχό αντίγραφο του συνόλου."

#: library/stdtypes.rst:4681
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, :meth:`symmetric_difference`, :meth:`issubset`, and :meth:"
"`issuperset` methods will accept any iterable as an argument.  In contrast, "
"their operator based counterparts require their arguments to be sets.  This "
"precludes error-prone constructions like ``set('abc') & 'cbs'`` in favor of "
"the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"Σημείωση, οι εκδόσεις μη τελεστών των μεθόδων :meth:`union`, :meth:"
"`intersection`, :meth:`difference`, :meth:`symmetric_difference`, :meth:"
"`issubset`, και :meth:`issuperset` θα δεχτούν οποιοδήποτε iterable ως "
"όρισμα.  Αντίθετα, οι αντίστοιχοι τελεστές απαιτούν να οριστούν τα ορίσματά "
"τους για να γίνουν σύνολα.  Αυτό αποκλείει κατασκευαστές επιρρεπείς σε "
"σφάλματα όπως ``set('abc') & 'cbs'`` υπέρ του πιο ευανάγνωστου ``set('abc')."
"intersection('cbs')``."

#: library/stdtypes.rst:4688
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""
"Τόσο το :class:`set` και :class:`frozenset` υποστηρίζουν τη σύγκριση μεταξύ "
"συνόλων. Δύο σύνολα είναι ίσα εάν και μόνο εάν κάθε στοιχείο κάθε συνόλου "
"περιέχεται στο άλλο (το καθένα είναι υποσύνολο του άλλου). Ένα σύνολο είναι "
"μικρότερο από ένα άλλο σύνολο εάν και μόνο αν το πρώτο σύνολο είναι σωστό "
"υποσύνολο του δεύτερου συνόλου (είναι υποσύνολο, αλλά δεν είναι ίσο), ένα "
"σύνολο είναι μεγαλύτερο από ένα άλλο σύνολο, αν και μόνο αν το πρώτο σύνολο "
"είναι σωστό υπερσύνολο του δεύτερου συνόλου (είναι υπερσύνολο αλλά δεν είναι "
"ίσο)."

#: library/stdtypes.rst:4695
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
"Τα στιγμιότυπα της :class:`set` συγκρίνονται με τα στιγμιότυπα της :class:"
"`frozenset` με βάση τα μέλη τους.  Για παράδειγμα, το ``set('abc') == "
"frozenset('abc')`` επιστρέφει ``True`` και το ίδιο συμβαίνει και με το "
"``set('abc') in set([frozenset('abc')])``."

#: library/stdtypes.rst:4699
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two nonempty disjoint sets are not equal and are "
"not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"Οι συγκρίσεις υποσυνόλου και ισότητας δεν γενικεύονται σε μια συνάρτηση "
"ολικής ταξινόμησης.  Για παράδειγμα, οποιαδήποτε δύο μη κενά συνεχή σύνολα "
"δεν είναι ίσα και δεν είναι υποσύνολα το ένα του άλλου, επομένως *όλα* τα "
"ακόλουθα επιστρέφουν ``False``: ``a<b``, ``a==b``, or ``a>b``."

#: library/stdtypes.rst:4704
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Δεδομένου ότι τα σύνολα ορίζουν μόνο μερική σειρά (σχέσεις υποσυνόλων), η "
"έξοδος της μεθόδου :meth:`list.sort` δεν έχει οριστεί για λίστες συνόλων."

#: library/stdtypes.rst:4707
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""
"Τα στοιχεία συνόλου, όπως τα κλειδιά λεξικού, πρέπει να είναι :term:"
"`hashable`."

#: library/stdtypes.rst:4709
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"Δυαδικές πράξεις που συνδυάζουν στιγμιότυπα :class:`set` με :class:"
"`frozenset` επιστρέφουν τον τύπο του πρώτου τελεστή.  Για παράδειγμα: "
"``frozenset('ab') | set('bc')`` επιστρέφει ένα στιγμιότυπο του :class:"
"`frozenset`."

#: library/stdtypes.rst:4713
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"Ο παρακάτω πίνακας παραθέτει λειτουργίες που είναι διαθέσιμες για :class:"
"`set` που δεν ισχύουν για αμετάβλητα στιγμιότυπα της :class:`frozenset`:"

#: library/stdtypes.rst:4719
msgid "Update the set, adding elements from all others."
msgstr "Ενημερώνει το σύνολο (set), προσθέτοντας στοιχεία από όλα τα άλλα."

#: library/stdtypes.rst:4724
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""
"Ενημερώνει το σύνολο, διατηρώντας μόνο τα στοιχεία που βρίσκονται σε αυτό "
"και όλα τα άλλα."

#: library/stdtypes.rst:4729
msgid "Update the set, removing elements found in others."
msgstr "Ενημερώνει το σύνολο, αφαιρώντας στοιχεία που βρίσκονται σε άλλα."

#: library/stdtypes.rst:4734
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Ενημερώνει το σύνολο, διατηρώντας μόνο τα στοιχεία που βρίσκονται σε κάθε "
"σύνολο, αλλά όχι και στα δύο."

#: library/stdtypes.rst:4738
msgid "Add element *elem* to the set."
msgstr "Προσθέτει το στοιχείο *elem* στο σύνολο."

#: library/stdtypes.rst:4742
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""
"Αφαιρεί το στοιχείο *elem* από το σύνολο.  Κάνει raise τη :exc:`KeyError` "
"εάν το *elem* δεν περιέχεται στο σύνολο."

#: library/stdtypes.rst:4747
msgid "Remove element *elem* from the set if it is present."
msgstr "Αφαιρεί το στοιχείο *elem* από το σύνολο εάν υπάρχει."

#: library/stdtypes.rst:4751
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""
"Αφαιρεί και επιστρέφει ένα αυθαίρετο στοιχείο από το σύνολο.  Κάνει raise "
"μια :exc:`KeyError` εάν το σύνολο είναι κενό."

#: library/stdtypes.rst:4756
msgid "Remove all elements from the set."
msgstr "Αφαιρεί όλα τα στοιχεία από το σύνολο (set)."

#: library/stdtypes.rst:4759
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"Σημείωση, οι εκδόσεις μη-τελεστή μεθόδων :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, και :meth:"
"`symmetric_difference_update` θα δέχονται οποιοδήποτε επαναλαμβανόμενο "
"στοιχείο ως όρισμα."

#: library/stdtypes.rst:4764
msgid ""
"Note, the *elem* argument to the :meth:`~object.__contains__`, :meth:"
"`remove`, and :meth:`discard` methods may be a set.  To support searching "
"for an equivalent frozenset, a temporary one is created from *elem*."
msgstr ""
"Σημείωση, το όρισμα *elem* για τις μεθόδους :meth:`~object.__contains__`, :"
"meth:`remove`, και :meth:`discard` μπορεί να είναι ένα σύνολο.  Για την "
"υποστήριξη της αναζήτησης για ένα ισοδύναμο παγωμένο σύνολο (frozenset), ένα "
"προσωρινό δημιουργείται από το *elem*."

#: library/stdtypes.rst:4773
msgid "Mapping Types --- :class:`dict`"
msgstr "Τύποι αντιστοίχισης --- :class:`dict`"

#: library/stdtypes.rst:4783
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built-in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
"Ένα αντικείμενο :term:`mapping` αντιστοιχίζει :term:`hashable` τιμές σε "
"αυθαίρετα αντικείμενα. Οι αντιστοιχίσεις είναι μεταβλητά αντικείμενα.  "
"Υπάρχει επί του παρόντος μόνο ένα τυπικός τύπο αντιστοίχισης, το :dfn:"
"`dictionary`.  (Για άλλα containers δείτε τις ενσωματωμένες (built-in) :"
"class:`list`, :class:`set`, και :class:`tuple` κλάσεις, και το module :mod:"
"`collections`.)"

#: library/stdtypes.rst:4789
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys. Values that compare equal (such as ``1``, ``1.0``, "
"and ``True``) can be used interchangeably to index the same dictionary entry."
msgstr ""
"Τα κλειδιά ενός λεξικού είναι *σχεδόν* αυθαίρετες τιμές.  Οι τιμές που δεν "
"είναι :term:`hashable`, δηλαδή, τιμές που περιέχουν λίστες, λεξικά ή άλλους "
"μεταβλητούς τύπους (που συγκρίνονται βάσει τιμής και όχι βάσει ταυτότητας "
"αντικειμένου) δεν μπορούν να χρησιμοποιηθούν ως κλειδιά. Οι τιμές που "
"συγκρίνονται ίσες (όπως ``1``, ``1.0``, και ``True``) μπορούν να "
"χρησιμοποιηθούν εναλλακτικά για το index της ίδιας καταχώρισης λεξικού."

#: library/stdtypes.rst:4800
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""
"Επιστρέφει ένα νέο λεξικό που έχει αρχικοποιηθεί από ένα προαιρετικό όρισμα "
"θέσης και ένα πιθανό κενό σύνολο ορισμάτων λέξεων-κλειδιών."

#: library/stdtypes.rst:4803
msgid "Dictionaries can be created by several means:"
msgstr "Τα λεξικά μπορούν να δημιουργηθούν με διάφορους τρόπους:"

#: library/stdtypes.rst:4805
msgid ""
"Use a comma-separated list of ``key: value`` pairs within braces: ``{'jack': "
"4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``"
msgstr ""
"Χρησιμοποιήστε μια λίστα διαχωρισμένων με κόμματα ζευγών ``key: value`` μέσα "
"σε αγκύλες: ``{'jack': 4098, 'sjoerd': 4127}`` or ``{4098: 'jack', 4127: "
"'sjoerd'}``"

#: library/stdtypes.rst:4807
msgid "Use a dict comprehension: ``{}``, ``{x: x ** 2 for x in range(10)}``"
msgstr ""
"Χρησιμοποιήστε ένα comprehension λεξικού: ``{}``, ``{x: x ** 2 for x in "
"range(10)}``"

#: library/stdtypes.rst:4808
msgid ""
"Use the type constructor: ``dict()``, ``dict([('foo', 100), ('bar', "
"200)])``, ``dict(foo=100, bar=200)``"
msgstr ""
"Χρησιμοποιήστε τον κατασκευαστή τύπου: ``dict()``, ``dict([('foo', 100), "
"('bar', 200)])``, ``dict(foo=100, bar=200)``"

#: library/stdtypes.rst:4811
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it defines a ``keys()`` method, a "
"dictionary is created by calling :meth:`~object.__getitem__` on the argument "
"with each returned key from the method.  Otherwise, the positional argument "
"must be an :term:`iterable` object.  Each item in the iterable must itself "
"be an iterable with exactly two elements.  The first element of each item "
"becomes a key in the new dictionary, and the second element the "
"corresponding value.  If a key occurs more than once, the last value for "
"that key becomes the corresponding value in the new dictionary."
msgstr ""
"Εάν δεν δοθεί όρισμα θέσης, δημιουργείται ένα κενό λεξικό. Εάν δοθεί ένα "
"όρισμα θέσης και ορίζει μια μέθοδο ``keys()``, δημιουργείται ένα λεξικό "
"καλώντας το :meth:`~object.__getitem__` στο όρισμα με κάθε κλειδί που "
"επιστρέφεται από τη μέθοδο. Διαφορετικά, το όρισμα θέσης πρέπει να είναι ένα "
"αντικείμενο :term:`iterable`. Κάθε στοιχείο στο iterable πρέπει από μόνο του "
"να είναι ένας iterable με ακριβώς δύο στοιχεία. Το πρώτο στοιχείο κάθε "
"στοιχείου γίνεται κλειδί στο νέο λεξικό και το δεύτερο στοιχείο η αντίστοιχη "
"τιμή. Εάν ένα κλειδί εμφανίζεται περισσότερες από μία φορές, η τελευταία "
"τιμή για αυτό το κλειδί γίνεται η αντίστοιχη τιμή στο νέο λεξικό."

#: library/stdtypes.rst:4821
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""
"Εάν δίνονται ορίσματα λέξης-κλειδιού, τα ορίσματα λέξης-κλειδιού και οι "
"τιμές τους προστίθενται στο λεξικό που δημιουργήθηκε από το όρισμα θέσης.  "
"Εάν υπάρχει ήδη ένα κλειδί που προστίθεται, η τιμή από το όρισμα λέξης-"
"κλειδιού αντικαθιστά την τιμή από το όρισμα θέσης."

#: library/stdtypes.rst:4844
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"Η παροχή ορισμάτων λέξεων-κλειδιών όπως στο πρώτο παράδειγμα λειτουργεί μόνο "
"για κλειδιά που είναι έγκυρα αναγνωριστικά Python.  Διαφορετικά, μπορούν να "
"χρησιμοποιηθούν οποιαδήποτε έγκυρα κλειδιά."

#: library/stdtypes.rst:4829
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs (regardless of ordering). Order comparisons ('<', '<=', '>=', "
"'>') raise :exc:`TypeError`.  To illustrate dictionary creation and "
"equality, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"Τα λεξικά συγκρίνονται ως ίσα εάν και μόνο εάν έχουν τα ίδια ζεύγη ``(key, "
"value)`` (ανεξάρτητα από τη σειρά). Οι συγκρίσεις διάταξης ('<', '<=', '>=', "
"'>') κάνουν raise την :exc:`TypeError`.  Για να επεξηγηθεί η δημιουργία "
"λεξικού και η ισότητα, τα ακόλουθα παραδείγματα επιστρέφουν όλα ένα λεξικό "
"ίσο με ``{\"one\": 1, \"two\": 2, \"three\": 3}``::"

#: library/stdtypes.rst:4835
msgid ""
">>> a = dict(one=1, two=2, three=3)\n"
">>> b = {'one': 1, 'two': 2, 'three': 3}\n"
">>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n"
">>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n"
">>> e = dict({'three': 3, 'one': 1, 'two': 2})\n"
">>> f = dict({'one': 1, 'three': 3}, two=2)\n"
">>> a == b == c == d == e == f\n"
"True"
msgstr ""
">>> a = dict(one=1, two=2, three=3)\n"
">>> b = {'one': 1, 'two': 2, 'three': 3}\n"
">>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n"
">>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n"
">>> e = dict({'three': 3, 'one': 1, 'two': 2})\n"
">>> f = dict({'one': 1, 'three': 3}, two=2)\n"
">>> a == b == c == d == e == f\n"
"True"

#: library/stdtypes.rst:4847
msgid ""
"Dictionaries preserve insertion order.  Note that updating a key does not "
"affect the order.  Keys added after deletion are inserted at the end. ::"
msgstr ""
"Τα λεξικά διατηρούν τη σειρά εισαγωγής.  Σημειώστε ότι η ενημέρωση ενός "
"κλειδιού δεν επηρεάζει τη σειρά.  Τα κλειδιά που προστέθηκαν μετά τη "
"διαγραφή εισάγονται στο τέλος. ::"

#: library/stdtypes.rst:4850
msgid ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(d)\n"
"['one', 'two', 'three', 'four']\n"
">>> list(d.values())\n"
"[1, 2, 3, 4]\n"
">>> d[\"one\"] = 42\n"
">>> d\n"
"{'one': 42, 'two': 2, 'three': 3, 'four': 4}\n"
">>> del d[\"two\"]\n"
">>> d[\"two\"] = None\n"
">>> d\n"
"{'one': 42, 'three': 3, 'four': 4, 'two': None}"
msgstr ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(d)\n"
"['one', 'two', 'three', 'four']\n"
">>> list(d.values())\n"
"[1, 2, 3, 4]\n"
">>> d[\"one\"] = 42\n"
">>> d\n"
"{'one': 42, 'two': 2, 'three': 3, 'four': 4}\n"
">>> del d[\"two\"]\n"
">>> d[\"two\"] = None\n"
">>> d\n"
"{'one': 42, 'three': 3, 'four': 4, 'two': None}"

#: library/stdtypes.rst:4865
msgid ""
"Dictionary order is guaranteed to be insertion order.  This behavior was an "
"implementation detail of CPython from 3.6."
msgstr ""
"Η σειρά λεξικού είναι εγγυημένη ότι είναι η σειρά εισαγωγής.  Αυτή η "
"συμπεριφορά ήταν μια λεπτομέρεια υλοποίηση της CPython από την έκδοση 3.6."

#: library/stdtypes.rst:4869
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Αυτές είναι οι λειτουργίες που υποστηρίζουν τα λεξικά (και επομένως, θα "
"πρέπει να υποστηρίζουν και προσαρμοσμένους τύπους αντιστοίχισης επίσης):"

#: library/stdtypes.rst:4874
msgid "Return a list of all the keys used in the dictionary *d*."
msgstr ""
"Επιστρέφει μια λίστα με όλα τα κλειδιά που χρησιμοποιούνται στο λεξικό *d*."

#: library/stdtypes.rst:4878
msgid "Return the number of items in the dictionary *d*."
msgstr "Επιστρέφει τον αριθμό των στοιχείων στο λεξικό *d*."

#: library/stdtypes.rst:4882
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""
"Επιστρέφει το στοιχείο του *d* με το κλειδί *key*.  Κάνει raise μια :exc:"
"`KeyError` εάν το *key* δεν υπάρχει για να αντιστοιχηθεί."

#: library/stdtypes.rst:4887
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, :"
"exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot be "
"an instance variable::"
msgstr ""
"Εάν μια υποκλάση ενός λεξικού ορίζει μια μέθοδο :meth:`__missing__` και το "
"*key* δεν υπάρχει, η λειτουργία ``d[key]`` καλεί αυτήν την μέθοδο με το "
"κλειδί *key* ως όρισμα. Στη συνέχεια, η λειτουργία ``d[key]`` επιστρέφει ή "
"κάνει raise ό, τι επιστρέφεται ή γίνεται raise από την κλήση "
"``__missing__(key)``. Καμία άλλη λειτουργία ή μέθοδος δεν επικαλεί την :meth:"
"`__missing__`. Εάν το :meth:`__missing__` δεν έχει οριστεί, γίνεται raise :"
"exc:`KeyError`. To :meth:`__missing__` πρέπει να είναι μέθοδος∙ δεν μπορεί "
"να είναι ένα στιγμιότυπο μεταβλητής::"

#: library/stdtypes.rst:4895
msgid ""
">>> class Counter(dict):\n"
"...     def __missing__(self, key):\n"
"...         return 0\n"
"...\n"
">>> c = Counter()\n"
">>> c['red']\n"
"0\n"
">>> c['red'] += 1\n"
">>> c['red']\n"
"1"
msgstr ""
">>> class Counter(dict):\n"
"...     def __missing__(self, key):\n"
"...         return 0\n"
"...\n"
">>> c = Counter()\n"
">>> c['red']\n"
"0\n"
">>> c['red'] += 1\n"
">>> c['red']\n"
"1"

#: library/stdtypes.rst:4906
msgid ""
"The example above shows part of the implementation of :class:`collections."
"Counter`.  A different ``__missing__`` method is used by :class:`collections."
"defaultdict`."
msgstr ""
"Το παραπάνω παράδειγμα δείχνει μέρος της υλοποίησης του :class:`collections."
"Counter`.  Μια διαφορετική μέθοδος ``__missing__`` χρησιμοποιείται από την :"
"class:`collections.defaultdict`."

#: library/stdtypes.rst:4912
msgid "Set ``d[key]`` to *value*."
msgstr "Ορίζει το ``d[key]`` στο *value*."

#: library/stdtypes.rst:4916
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""
"Αφαιρεί το ``d[key]`` από το *d*.  Κάνει raise ένα :exc:`KeyError` εάν το "
"*key* δεν υπάρχει για αντιστοίχιση."

#: library/stdtypes.rst:4921
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr ""
"Επιστρέφει ``True`` εάν το *d* έχει ένα κλειδί *key*, διαφορετικά ``False``."

#: library/stdtypes.rst:4925
msgid "Equivalent to ``not key in d``."
msgstr "Ισοδυναμεί με ``not key in d``."

#: library/stdtypes.rst:4929
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""
"Επιστρέφει έναν iterator πάνω από τα κλειδιά του λεξικού.  Αυτή είναι μια "
"συντόμευση για ``iter(d.keys())``."

#: library/stdtypes.rst:4934
msgid "Remove all items from the dictionary."
msgstr "Αφαιρεί όλα τα στοιχεία από το λεξικό."

#: library/stdtypes.rst:4938
msgid "Return a shallow copy of the dictionary."
msgstr "Επιστρέφει ένα ρηχό αντίγραφο του λεξικού."

#: library/stdtypes.rst:4942
msgid ""
"Create a new dictionary with keys from *iterable* and values set to *value*."
msgstr ""
"Δημιουργεί ένα νέο λεξικό με κλειδιά από το *iterable* και τιμές ως *value*."

#: library/stdtypes.rst:4944
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``.  All of the values refer to just a single instance, so "
"it generally doesn't make sense for *value* to be a mutable object such as "
"an empty list.  To get distinct values, use a :ref:`dict comprehension "
"<dict>` instead."
msgstr ""
"Το :meth:`fromkeys` είναι μια μέθοδος κλάσης που επιστρέφει ένα νέο λεξικό. "
"Η τιμή *value* ορίζεται από προεπιλογή σε ``None``.  Όλες οι τιμές "
"αναφέρονται σε ένα μόνο στιγμιότυπο, επομένως γενικά δεν έχει νόημα για το "
"*value* να είναι μεταβλητό αντικείμενο, όπως μια κενή λίστα.  Για να λάβετε "
"διαφορετικές τιμές, χρησιμοποιήστε αντ' αυτού ένα :ref:`dict comprehension "
"<dict>`."

#: library/stdtypes.rst:4952
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"Επιστρέφει την τιμή για το *key* εάν το *key* είναι στο λεξικό, αλλιώς "
"*default*. Εάν το *default* δεν δίνεται, ορίζεται από προεπιλογή σε "
"``None``, έτσι ώστε αυτή η μέθοδος να μην κάνει raise μια :exc:`KeyError`."

#: library/stdtypes.rst:4958
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See "
"the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"Επιστρέφει μια νέα όψη των στοιχείων του λεξικού (``(key, value)`` ζεύγη). "
"Δείτε την :ref:`documentation of view objects <dict-views>`."

#: library/stdtypes.rst:4963
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation of "
"view objects <dict-views>`."
msgstr ""
"Επιστρέφει μια νέα όψη των κλειδιών του λεξικού.  Δείτε το :ref:"
"`documentation of view objects <dict-views>`."

#: library/stdtypes.rst:4968
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""
"Εάν το *key* βρίσκεται στο λεξικό, αφαιρείται και επιστρέφει την τιμή του, "
"διαφορετικά επιστρέφει *default*.  Εάν *default* δεν δίνεται και το *key* "
"δεν είναι στο λεξικό, γίνεται raise ένα :exc:`KeyError`."

#: library/stdtypes.rst:4974
msgid ""
"Remove and return a ``(key, value)`` pair from the dictionary. Pairs are "
"returned in :abbr:`LIFO (last-in, first-out)` order."
msgstr ""
"Αφαιρεί και επιστρέφει ένα ζεύγος ``(key, value)`` από το λεξικό. Τα ζεύγη "
"επιστρέφονται με τη σειρά :abbr:`LIFO (last-in, first-out)`."

#: library/stdtypes.rst:4977
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""
"Η μέθοδος :meth:`popitem` είναι χρήσιμη για καταστροφική επανάληψη σε ένα "
"λεξικό, όπως χρησιμοποιείται συχνά σε αλγόριθμους συνόλου.  Εάν το λεξικό "
"είναι κενό, η κλήση της :meth:`popitem` κάνει raise ένα :exc:`KeyError`."

#: library/stdtypes.rst:4981
msgid ""
"LIFO order is now guaranteed. In prior versions, :meth:`popitem` would "
"return an arbitrary key/value pair."
msgstr ""
"Η σειρά LIFO είναι πλέον εγγυημένη. Σε προηγούμενες εκδόσεις, η :meth:"
"`popitem` επιστρέφει ένα αυθαίρετο ζεύγος κλειδιού/τιμής."

#: library/stdtypes.rst:4987
msgid ""
"Return a reverse iterator over the keys of the dictionary. This is a "
"shortcut for ``reversed(d.keys())``."
msgstr ""
"Επιστρέφει έναν αντίστροφο iterator πάνω από τα κλειδιά του λεξικού. Αυτή "
"είναι μια συντόμευση για ``reversed(d.keys())``."

#: library/stdtypes.rst:4994
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"Εάν το *key* βρίσκεται στο λεξικό, επιστρέφει την τιμή του.  Εάν όχι, "
"εισάγετε το *key* με τιμή *default* και επιστρέφει *default*.  Το *default* "
"από προεπιλογή είναι ``None``."

#: library/stdtypes.rst:5000
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"Ενημερώνει το λεξικό με τα ζεύγη κλειδιών/τιμών από το *other*, "
"αντικαθιστώντας τα υπάρχοντα κλειδιά.  Επιστρέφει ``None``."

#: library/stdtypes.rst:5003
msgid ""
":meth:`update` accepts either another object with a ``keys()`` method (in "
"which case :meth:`~object.__getitem__` is called with every key returned "
"from the method) or an iterable of key/value pairs (as tuples or other "
"iterables of length two). If keyword arguments are specified, the dictionary "
"is then updated with those key/value pairs: ``d.update(red=1, blue=2)``."
msgstr ""
"Η :meth:`update` δέχεται είτε ένα άλλο αντικείμενο με τη μέθοδο ``keys()`` "
"(στην περίπτωση αυτή το :meth:`~object.__getitem__` καλείται με κάθε κλειδί "
"που επιστρέφεται από τη μέθοδο) είτε ένα iterable από ζεύγη κλειδιών/τιμών "
"(ως πλειάδες ή άλλα iterables μήκους δύο). Εάν καθορίζονται ορίσματα λέξεων-"
"κλειδιών, το λεξικό ενημερώνεται στη συνέχεια με αυτά τα ζεύγη κλειδιών/"
"τιμών: ``d.update(red=1, blue=2)``."

#: library/stdtypes.rst:5011
msgid ""
"Return a new view of the dictionary's values.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr ""
"Επιστρέφει μια νέα όψη των τιμών του λεξικού.  Δείτε την :ref:`documentation "
"of view objects <dict-views>`."

#: library/stdtypes.rst:5014
msgid ""
"An equality comparison between one ``dict.values()`` view and another will "
"always return ``False``. This also applies when comparing ``dict.values()`` "
"to itself::"
msgstr ""
"Μια σύγκριση ισότητας μεταξύ μιας όψης ``dict.values()`` και μιας άλλης θα "
"επιστρέφει πάντα ``False``. Αυτό ισχύει επίσης όταν συγκρίνετε το ``dict."
"values()`` με τον εαυτό της::"

#: library/stdtypes.rst:5018
msgid ""
">>> d = {'a': 1}\n"
">>> d.values() == d.values()\n"
"False"
msgstr ""
">>> d = {'a': 1}\n"
">>> d.values() == d.values()\n"
"False"

#: library/stdtypes.rst:5024
msgid ""
"Create a new dictionary with the merged keys and values of *d* and *other*, "
"which must both be dictionaries. The values of *other* take priority when "
"*d* and *other* share keys."
msgstr ""
"Δημιουργεί ένα νέο λεξικό με τα συγχωνευμένα κλειδιά και τις τιμές των *d* "
"και *other*, τα οποία πρέπει να είναι και τα δύο λεξικά. Οι τιμές του "
"*other* έχουν προτεραιότητα όταν τα κλειδιά των *d* και *other* είναι κοινά."

#: library/stdtypes.rst:5032
msgid ""
"Update the dictionary *d* with keys and values from *other*, which may be "
"either a :term:`mapping` or an :term:`iterable` of key/value pairs. The "
"values of *other* take priority when *d* and *other* share keys."
msgstr ""
"Ενημερώνει το λεξικό *d* με κλειδιά και τιμές από το *other*, που μπορεί να "
"είναι είτε :term:`mapping` είτε :term:`iterable` ζευγάρι κλειδιών/τιμών. Οι "
"τιμές του *other* έχουν προτεραιότητα όταν τα κλειδιά των το *d* και *other* "
"είναι κοινά."

#: library/stdtypes.rst:5038
msgid "Dictionaries and dictionary views are reversible. ::"
msgstr "Τα λεξικά και οι όψεις λεξικών είναι αναστρέψιμες. ::"

#: library/stdtypes.rst:5040
msgid ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(reversed(d))\n"
"['four', 'three', 'two', 'one']\n"
">>> list(reversed(d.values()))\n"
"[4, 3, 2, 1]\n"
">>> list(reversed(d.items()))\n"
"[('four', 4), ('three', 3), ('two', 2), ('one', 1)]"
msgstr ""
">>> d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4}\n"
">>> d\n"
"{'one': 1, 'two': 2, 'three': 3, 'four': 4}\n"
">>> list(reversed(d))\n"
"['four', 'three', 'two', 'one']\n"
">>> list(reversed(d.values()))\n"
"[4, 3, 2, 1]\n"
">>> list(reversed(d.items()))\n"
"[('four', 4), ('three', 3), ('two', 2), ('one', 1)]"

#: library/stdtypes.rst:5050
msgid "Dictionaries are now reversible."
msgstr "Τα λεξικά είναι πλέον αναστρέψιμα."

#: library/stdtypes.rst:5055
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of a :"
"class:`dict`."
msgstr ""
"Η :class:`types.MappingProxyType` μπορεί να χρησιμοποιηθεί για τη δημιουργία "
"μιας όψης μόνο για ανάγνωση μιας :class:`dict`."

#: library/stdtypes.rst:5062
msgid "Dictionary view objects"
msgstr "Αντικείμενα όψης λεξικού"

#: library/stdtypes.rst:5064
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""
"Τα αντικείμενα που επιστρέφονται από τις :meth:`dict.keys`, :meth:`dict."
"values` and :meth:`dict.items` είναι *όψεις αντικειμένων (view objects)*.  "
"Παρέχουν μια δυναμική όψη στις εγγραφές του λεξικού, που σημαίνει ότι όταν "
"αλλάζει το λεξικό, η όψη αντικατοπτρίζει αυτές τις αλλαγές."

#: library/stdtypes.rst:5069
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"Οι όψεις λεξικού μπορούν να γίνουν iterate για την απόδοση των αντίστοιχων "
"δεδομένων τους και την υποστήριξη ελέγχων για το αν είναι μέρος του:"

#: library/stdtypes.rst:5074
msgid "Return the number of entries in the dictionary."
msgstr "Επιστρέφει τον αριθμό των καταχωρήσεων στο λεξικό."

#: library/stdtypes.rst:5078
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Επιστρέφει έναν iterator πάνω στα κλειδιά, τις τιμές ή τα στοιχεία (που "
"αντιπροσωπεύονται ως πλειάδες (tuples) του ``(key, value)`` στο λεξικό."

#: library/stdtypes.rst:5081
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = zip(d."
"values(), d.keys())``.  Another way to create the same list is ``pairs = "
"[(v, k) for (k, v) in d.items()]``."
msgstr ""
"Τα κλειδιά και οι τιμές επαναλαμβάνονται με την σειρά εισαγωγής. Αυτό "
"επιτρέπει τη δημιουργία ζευγών ``(value, key)`` χρησιμοποιώντας τη :func:"
"`zip`: ``pairs = zip(d.values(), d.keys())``.  Ένας άλλος τρόπος είναι να "
"δημιουργήσετε την ίδια λίστα είναι ``pairs = [(v, k) for (k, v) in d."
"items()]``."

#: library/stdtypes.rst:5086
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"Το iterate όψεων κατά την προσθήκη ή τη διαγραφή καταχωρήσεων στο λεξικό "
"μπορεί να κάνει raise μια :exc:`RuntimeError` ή να αποτύχει το iterate σε "
"όλες τις καταχωρήσεις."

#: library/stdtypes.rst:5089
msgid "Dictionary order is guaranteed to be insertion order."
msgstr "Η σειρά λεξικού είναι εγγυημένη σειρά εισαγωγής."

#: library/stdtypes.rst:5094
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"Επιστρέφει ``True`` εάν το *x* βρίσκεται στα κλειδιά του λεξικού, τις τιμές "
"ή τα στοιχεία του υποκείμενου λεξικού (στην τελευταία περίπτωση, το *x* θα "
"πρέπει να είναι μια ``(key, value)`` πλειάδα (tuple))."

#: library/stdtypes.rst:5099
msgid ""
"Return a reverse iterator over the keys, values or items of the dictionary. "
"The view will be iterated in reverse order of the insertion."
msgstr ""
"Επιστρέφει έναν αντίστροφο iterator πάνω στα κλειδιά, τις τιμές ή τα "
"στοιχεία του λεξικού. Η όψη θα γίνει iterate με την αντίστροφη σειρά από την "
"εισαγωγή."

#: library/stdtypes.rst:5102
msgid "Dictionary views are now reversible."
msgstr "Οι όψεις λεξικού είναι πλέον αναστρέψιμες."

#: library/stdtypes.rst:5107
msgid ""
"Return a :class:`types.MappingProxyType` that wraps the original dictionary "
"to which the view refers."
msgstr ""
"Επιστρέφει μια :class:`types.MappingProxyType` που αναδιπλώνει το αρχικό "
"λεξικό στο οποίο αναφέρεται η όψη."

#: library/stdtypes.rst:5112
msgid ""
"Keys views are set-like since their entries are unique and :term:`hashable`. "
"Items views also have set-like operations since the (key, value) pairs are "
"unique and the keys are hashable. If all values in an items view are "
"hashable as well, then the items view can interoperate with other sets. "
"(Values views are not treated as set-like since the entries are generally "
"not unique.)  For set-like views, all of the operations defined for the "
"abstract base class :class:`collections.abc.Set` are available (for example, "
"``==``, ``<``, or ``^``).  While using set operators, set-like views accept "
"any iterable as the other operand, unlike sets which only accept sets as the "
"input."
msgstr ""
"Οι όψεις κλειδιών μοιάζουν με σύνολο καθώς οι καταχωρίσεις τους είναι "
"μοναδικές και :term:`hashable`. Οι όψεις στοιχείων έχουν επίσης λειτουργίες "
"που μοιάζουν με σύνολο, καθώς τα ζεύγη (κλειδί, τιμή) είναι μοναδικά και τα "
"κλειδιά μπορούν να κατακερματιστούν. Εάν όλες οι τιμές σε μία όψη στοιχείων "
"μπορούν επίσης να κατακερματιστούν, τότε η όψη στοιχείων μπορεί να "
"διαλειτουργήσει με άλλα σύνολα. (Οι όψεις  τιμών δεν αντιμετωπίζονται ως "
"σύνολο, καθώς οι καταχωρίσεις δεν είναι γενικά μοναδικές.)  Για όψεις που "
"μοιάζουν με σύνολο, όλες οι λειτουργίες που ορίζονται για την αφηρημένη "
"βασική κλάση :class:`collections.abc.Set` είναι διαθέσιμες (για "
"παράδειγμα, )``==``, ``<``, or ``^``).  Κατά τη χρήση τελεστών συνόλου, οι "
"όψεις που μοιάζουν με σύνολο δέχονται οποιοδήποτε iterable ως άλλο τελεστή, "
"σε αντίθεση με τα σύνολα που δέχονται μόνο σύνολα ως είσοδο."

#: library/stdtypes.rst:5124
msgid "An example of dictionary view usage::"
msgstr "Ένα παράδειγμα χρήσης όψης λεξικού::"

#: library/stdtypes.rst:5126
msgid ""
">>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}\n"
">>> keys = dishes.keys()\n"
">>> values = dishes.values()\n"
"\n"
">>> # iteration\n"
">>> n = 0\n"
">>> for val in values:\n"
"...     n += val\n"
"...\n"
">>> print(n)\n"
"504\n"
"\n"
">>> # keys and values are iterated over in the same order (insertion order)\n"
">>> list(keys)\n"
"['eggs', 'sausage', 'bacon', 'spam']\n"
">>> list(values)\n"
"[2, 1, 1, 500]\n"
"\n"
">>> # view objects are dynamic and reflect dict changes\n"
">>> del dishes['eggs']\n"
">>> del dishes['sausage']\n"
">>> list(keys)\n"
"['bacon', 'spam']\n"
"\n"
">>> # set operations\n"
">>> keys & {'eggs', 'bacon', 'salad'}\n"
"{'bacon'}\n"
">>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}\n"
"True\n"
">>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}\n"
"True\n"
"\n"
">>> # get back a read-only proxy for the original dictionary\n"
">>> values.mapping\n"
"mappingproxy({'bacon': 1, 'spam': 500})\n"
">>> values.mapping['spam']\n"
"500"
msgstr ""
">>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}\n"
">>> keys = dishes.keys()\n"
">>> values = dishes.values()\n"
"\n"
">>> # iteration\n"
">>> n = 0\n"
">>> for val in values:\n"
"...     n += val\n"
"...\n"
">>> print(n)\n"
"504\n"
"\n"
">>> # keys and values are iterated over in the same order (insertion order)\n"
">>> list(keys)\n"
"['eggs', 'sausage', 'bacon', 'spam']\n"
">>> list(values)\n"
"[2, 1, 1, 500]\n"
"\n"
">>> # view objects are dynamic and reflect dict changes\n"
">>> del dishes['eggs']\n"
">>> del dishes['sausage']\n"
">>> list(keys)\n"
"['bacon', 'spam']\n"
"\n"
">>> # set operations\n"
">>> keys & {'eggs', 'bacon', 'salad'}\n"
"{'bacon'}\n"
">>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}\n"
"True\n"
">>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}\n"
"True\n"
"\n"
">>> # get back a read-only proxy for the original dictionary\n"
">>> values.mapping\n"
"mappingproxy({'bacon': 1, 'spam': 500})\n"
">>> values.mapping['spam']\n"
"500"

#: library/stdtypes.rst:5168
msgid "Context Manager Types"
msgstr "Τύποι Διαχείρισης Περιεχομένου"

#: library/stdtypes.rst:5175
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""
"Η δήλωση :keyword:`with` της Python υποστηρίζει την έννοια ενός περιεχομένου "
"χρόνου εκτέλεσης που ορίζεται από έναν διαχειριστή περιεχομένου.  Αυτό "
"υλοποιείται χρησιμοποιώντας ένα ζεύγος μεθόδων που επιτρέπουν σε κλάσεις που "
"ορίζονται από το χρήστη να ορίζουν περιεχόμενο χρόνου εκτέλεσης που "
"εισάγεται πριν από την εκτέλεση του σώματος της δήλωσης και να κάνει έξοδο "
"όταν τερματιστεί η δήλωση:"

#: library/stdtypes.rst:5183
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`!as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""
"Εισάγει το περιεχόμενο εκτέλεσης και επιστρέφει είτε αυτό το αντικείμενο "
"είτε ένα άλλο που σχετίζεται με το περιεχόμενο χρόνου εκτέλεσης. Η τιμή που "
"επιστρέφεται από αυτήν την μέθοδο είναι δεσμευμένη στο αναγνωριστικό στην "
"πρόταση :keyword:`!as` των δηλώσεων :keyword:`with` διαχείρισης περιεχομένου."

#: library/stdtypes.rst:5188
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""
"Ένα παράδειγμα ενός διαχειριστή περιεχομένου που επιστρέφει ο ίδιος είναι "
"ένα :term:`file object`. Τα αντικείμενα αρχείου επιστρέφουν μόνα τους από "
"__enter__() για να επιτρέψουν στο :func:`open` να χρησιμοποιηθεί ως έκφραση "
"περιεχομένου σε μια δήλωση :keyword:`with`."

#: library/stdtypes.rst:5192
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`!with` statement."
msgstr ""
"Ένα παράδειγμα διαχείρισης περιεχομένου που επιστρέφει ένα σχετικό "
"αντικείμενο είναι αυτό που επιστρέφεται από το :func:`decimal.localcontext`. "
"Αυτοί οι διαχειριστές ορίζουν το ενεργό δεκαδικό περιεχόμενο σε ένα "
"αντίγραφο του αρχικού δεκαδικού περιεχομένου και στη συνέχεια επιστρέφουν το "
"αντίγραφο. Αυτό επιτρέπει την πραγματοποίηση αλλαγών στο τρέχον δεκαδικό "
"πλαίσιο στο σώμα της δήλωσης :keyword:`with`, χωρίς να επηρεάζεται ο κώδικας "
"εκτός της δήλωσης :keyword:`!with`."

#: library/stdtypes.rst:5202
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"Τερματίζει από το περιεχόμενο χρόνου εκτέλεσης και επιστρέφει ένα Boolean "
"δείκτη που υποδεικνύει εάν κάποια εξαίρεση που προέκυψε θα πρέπει να "
"καταργηθεί. Εάν προκύψει μια εξαίρεση κατά την εκτέλεση του σώματος της "
"δήλωσης :keyword:`with`, τα ορίσματα περιέχουν τον τύπο εξαίρεσης, την τιμή "
"και τις πληροφορίες ανίχνευσης. Διαφορετικά, και τα τρία ορίσματα είναι "
"``None``."

#: library/stdtypes.rst:5207
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`!with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`!with` "
"statement."
msgstr ""
"Η επιστροφή μιας πραγματικής τιμής από αυτήν την μέθοδο θα έχει ως "
"αποτέλεσμα η δήλωση :keyword:`with` να καταργήσει την εξαίρεση και να "
"συνεχίσει την εκτέλεση με τη δήλωση αμέσως μετά τη δήλωση :keyword:`!with`. "
"Διαφορετικά, η εξαίρεση θα συνεχίσει να διαδίδεται μετά την ολοκλήρωση αυτής "
"της μεθόδου. Οι εξαιρέσεις που προκύπτουν κατά την εκτέλεση αυτής της "
"μεθόδου θα αντικαταστήσουν κάθε εξαίρεση που προέκυψε στο σώμα της δήλωσης :"
"keyword:`!with`."

#: library/stdtypes.rst:5214
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code to easily detect whether or not an :meth:`~object."
"__exit__` method has actually failed."
msgstr ""
"Η εξαίρεση που διαβιβάστηκε δεν θα πρέπει ποτέ να επανατοποθετηθεί ρητά - "
"αντίθετα, αυτή η μέθοδος θα πρέπει να επιστρέψει μια ψευδή τιμή για να "
"υποδείξει ότι η μέθοδος ολοκληρώθηκε με επιτυχία και δεν θέλει να αποκρύψει "
"την εξαίρεση που έχει γίνει raise. Αυτό επιτρέπει στον κώδικα διαχείρισης "
"περιεχομένου να εντοπίζει εύκολα εάν μια μέθοδος :meth:`~object.__exit__` "
"έχει  πράγματι αποτύχει."

#: library/stdtypes.rst:5220
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Η Python ορίζει  αρκετούς διαχειριστές περιεχομένου για να υποστηρίζουν τον "
"εύκολο συγχρονισμό νημάτων, το  άμεσο κλείσιμο αρχείων ή άλλων αντικειμένων "
"και τον απλούστερο χειρισμό του ενεργού δεκαδικού αριθμητικού περιεχομένου. "
"Οι συγκεκριμένοι τύποι δεν αντιμετωπίζονται ειδικά πέρα από την εφαρμογή "
"τους πρωτοκόλλου διαχείρισης περιεχομένου. Δείτε το module :mod:`contextlib` "
"για μερικά παραδείγματα."

#: library/stdtypes.rst:5226
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`~contextmanager.__enter__` and :meth:`~contextmanager.__exit__` methods, "
"rather than the iterator produced by an undecorated generator function."
msgstr ""
"Οι decorators της Python :term:`generator`\\s και :class:`contextlib."
"contextmanager` παρέχουν έναν βολικό τρόπο υλοποίησης αυτών των "
"πρωτοκόλλων.  Εάν μια συνάρτηση γεννήτριας είναι decorated με τον :class:"
"`contextlib.contextmanager` decorator, θα επιστρέψει έναν διαχειριστή "
"περιεχομένου που εφαρμόζει τις απαραίτητες μεθόδους :meth:`~contextmanager."
"__enter__` και :meth:`~contextmanager.__exit__`, αντί του iterator που "
"παράγεται από μια undecorated συνάρτηση γεννήτριας."

#: library/stdtypes.rst:5233
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""
"Λάβετε υπόψη ότι δεν υπάρχει συγκεκριμένη υποδοχή για καμία από αυτές τις "
"μεθόδους στη δομή τύπου για αντικείμενα Python στο Python/C API. Οι τύποι "
"επεκτάσεων που θέλουν να ορίσουν αυτές τις μεθόδους πρέπει να τις παρέχουν "
"ως μια κανονική μέθοδο προσβάσιμη στην Python. Σε σύγκριση με την επιβάρυνση "
"της ρύθμισης στο πλαίσιο του χρόνου εκτέλεσης, η επιβάρυνση μιας απλής "
"αναζήτησης κλάσης λεξικού είναι αμελητέα."

#: library/stdtypes.rst:5241
msgid ""
"Type Annotation Types --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"
msgstr ""
"Τύποι Annotation τύπου --- :ref:`Generic Alias <types-genericalias>`, :ref:"
"`Union <types-union>`"

#: library/stdtypes.rst:5246
msgid ""
"The core built-in types for :term:`type annotations <annotation>` are :ref:"
"`Generic Alias <types-genericalias>` and :ref:`Union <types-union>`."
msgstr ""
"Οι βασικοί ενσωματωμένοι τύποι για :term:`type annotations <annotation>` "
"είναι :ref:`Generic Alias <types-genericalias>` και :ref:`Union <types-"
"union>`."

#: library/stdtypes.rst:5253
msgid "Generic Alias Type"
msgstr "Τύπος Generic Alias"

#: library/stdtypes.rst:5259
msgid ""
"``GenericAlias`` objects are generally created by :ref:`subscripting "
"<subscriptions>` a class. They are most often used with :ref:`container "
"classes <sequence-types>`, such as :class:`list` or :class:`dict`. For "
"example, ``list[int]`` is a ``GenericAlias`` object created by subscripting "
"the ``list`` class with the argument :class:`int`. ``GenericAlias`` objects "
"are intended primarily for use with :term:`type annotations <annotation>`."
msgstr ""
"Τα αντικείμενα ``GenericAlias`` δημιουργούνται γενικά με :ref:`subscripting "
"<subscriptions>` κλάση. Χρησιμοποιούνται πιο συχνά με :ref:`container "
"classes <sequence-types>`, όπως :class:`list` ή :class:`dict`.Για "
"παράδειγμα, το ``list[int]`` είναι ένα αντικείμενο ``GenericAlias`` που "
"δημιουργήθηκε με την εγγραφή της κλάσης ``list`` με το όρισμα :class:`int`. "
"Τα αντικείμενα ``GenericAlias`` προορίζονται κυρίως για χρήση με :term:`type "
"annotations <annotation>`."

#: library/stdtypes.rst:5269
msgid ""
"It is generally only possible to subscript a class if the class implements "
"the special method :meth:`~object.__class_getitem__`."
msgstr ""
"Γενικά είναι δυνατή η εγγραφή μιας κλάσης μόνο εάν η κλάση εφαρμόζει την "
"ειδική μέθοδο :meth:`~object.__class_getitem__`."

#: library/stdtypes.rst:5272
msgid ""
"A ``GenericAlias`` object acts as a proxy for a :term:`generic type`, "
"implementing *parameterized generics*."
msgstr ""
"Ένα αντικείμενο ``GenericAlias`` λειτουργεί ως διακομιστής μεσολάβησης "
"(proxy) για έναν :term:`generic type`, υλοποιώντας *parameterized generics*."

#: library/stdtypes.rst:5275
msgid ""
"For a container class, the argument(s) supplied to a :ref:`subscription "
"<subscriptions>` of the class may indicate the type(s) of the elements an "
"object contains. For example, ``set[bytes]`` can be used in type annotations "
"to signify a :class:`set` in which all the elements are of type :class:"
"`bytes`."
msgstr ""
"Για μια κλάση container, το(α) όρισμα(τα) που παρέχει σε μια :ref:"
"`subscription <subscriptions>` της κλάσης μπορεί να υποδεικνύει τον(ους) "
"τύπο(ους) των στοιχείων που περιέχει ένα αντικείμενο. Για παράδειγμα, το "
"``set[bytes]`` μπορεί να χρησιμοποιηθεί σε annotations τύπου για  να "
"υποδηλώσει ένα :class:`set` στο  οποίο όλα τα στοιχεία είναι τύπου :class:"
"`bytes`."

#: library/stdtypes.rst:5281
msgid ""
"For a class which defines :meth:`~object.__class_getitem__` but is not a "
"container, the argument(s) supplied to a subscription of the class will "
"often indicate the return type(s) of one or more methods defined on an "
"object. For example, :mod:`regular expressions <re>` can be used on both "
"the :class:`str` data type and the :class:`bytes` data type:"
msgstr ""
"Για μια κλάση που ορίζει :meth:`~object.__class_getitem__` αλλά δεν είναι "
"container, τα ορίσματα που παρέχονται σε μια συνδρομή της κλάσης θα "
"υποδεικνύουν συχνά τον τύπο ή τους τύπους επιστροφής μιας ή περισσότερων "
"μεθόδων που ορίζονται σε ένα αντικείμενο. Για παράδειγμα, το :mod:`regular "
"expressions <re>` μπορούν να χρησιμοποιηθούν τόσο στον τύπο δεδομένων :class:"
"`str` όσο και στον τύπο δεδομένων :class:`bytes`:"

#: library/stdtypes.rst:5287
msgid ""
"If ``x = re.search('foo', 'foo')``, ``x`` will be a :ref:`re.Match <match-"
"objects>` object where the return values of ``x.group(0)`` and ``x[0]`` will "
"both be of type :class:`str`. We can represent this kind of object in type "
"annotations with the ``GenericAlias`` ``re.Match[str]``."
msgstr ""
"Εάν ``x = re.search('foo', 'foo')``, το ``x`` θα είναι ένα αντικείμενο :ref:"
"`re.Match <match-objects>` όπου επιστρέφονται οι τιμές του το ``x.group(0)`` "
"και το ``x[0]`` θα είναι και τα δύο τύπου :class:`str`. Μπορούμε να "
"αναπαραστήσουμε αυτό το είδος  αντικειμένου σε σχολιασμούς τύπου με το "
"``GenericAlias`` ``re.Match[str]``."

#: library/stdtypes.rst:5293
msgid ""
"If ``y = re.search(b'bar', b'bar')``, (note the ``b`` for :class:`bytes`), "
"``y`` will also be an instance of ``re.Match``, but the return values of ``y."
"group(0)`` and ``y[0]`` will both be of type :class:`bytes`. In type "
"annotations, we would represent this variety of :ref:`re.Match <match-"
"objects>` objects with ``re.Match[bytes]``."
msgstr ""
"Εάν ``y = re.search(b'bar', b'bar')``, (σημειώστε το ``b`` για :class:"
"`bytes`), το ``y`` θα είναι επίσης μια παρουσία του ``re.Match``, αλλά οι "
"επιστρεφόμενες τιμές των ``y.group(0)`` και ``y[0]`` θα είναι και οι δύο "
"τύπου :class:`bytes`. Στους τύπους annotations, θα αντιπροσωπεύαμε αυτήν την "
"ποικιλία αντικειμένων :ref:`re.Match <match-objects>` με το ``re."
"Match[bytes]``."

#: library/stdtypes.rst:5299
msgid ""
"``GenericAlias`` objects are instances of the class :class:`types."
"GenericAlias`, which can also be used to create ``GenericAlias`` objects "
"directly."
msgstr ""
"Τα αντικείμενα ``GenericAlias`` είναι στιγμιότυπα της κλάσης :class:`types."
"GenericAlias`, τα οποία μπορούν επίσης να χρησιμοποιηθούν για την δημιουργία "
"αντικειμένων ``GenericAlias`` απευθείας."

#: library/stdtypes.rst:5305
msgid ""
"Creates a ``GenericAlias`` representing a type ``T`` parameterized by types "
"*X*, *Y*, and more depending on the ``T`` used. For example, a function "
"expecting a :class:`list` containing :class:`float` elements::"
msgstr ""
"Δημιουργεί ένα ``GenericAlias`` που αντιπροσωπεύει έναν τύπο ``T`` "
"παραμετροποιημένο από τύπους *X*, *Y*, και άλλα ανάλογα με το ``T`` που "
"χρησιμοποιείται. Για παράδειγμα, μια συνάρτηση που αναμένει μια :class:"
"`list` που περιέχει στοιχεία της  :class:`float`::"

#: library/stdtypes.rst:5310
msgid ""
"def average(values: list[float]) -> float:\n"
"    return sum(values) / len(values)"
msgstr ""
"def average(values: list[float]) -> float:\n"
"    return sum(values) / len(values)"

#: library/stdtypes.rst:5313
msgid ""
"Another example for :term:`mapping` objects, using a :class:`dict`, which is "
"a generic type expecting two type parameters representing the key type and "
"the value type.  In this example, the function expects a ``dict`` with keys "
"of type :class:`str` and values of type :class:`int`::"
msgstr ""
"Ένα άλλο παράδειγμα για αντικείμενα :term:`mapping`, χρησιμοποιώντας ένα :"
"class:`dict`,που είναι ένας generic τύπος που αναμένει δύο παραμέτρους τύπου "
"που αντιπροσωπεύουν τον τύπο κλειδιού και τον τύπο τιμής.  Σε αυτό το "
"παράδειγμα, η συνάρτηση αναμένει ένα ``dict`` με κλειδιά τύπου :class:`str` "
"και τιμές τύπου :class:`int`::"

#: library/stdtypes.rst:5318
msgid ""
"def send_post_request(url: str, body: dict[str, int]) -> None:\n"
"    ..."
msgstr ""
"def send_post_request(url: str, body: dict[str, int]) -> None:\n"
"    ..."

#: library/stdtypes.rst:5321
msgid ""
"The builtin functions :func:`isinstance` and :func:`issubclass` do not "
"accept ``GenericAlias`` types for their second argument::"
msgstr ""
"Οι ενσωματωμένες συναρτήσεις (built-in) :func:`isinstance` και :func:"
"`issubclass` δεν δέχονται τους τύπους ``GenericAlias`` για το δεύτερο όρισμά "
"τους::"

#: library/stdtypes.rst:5324
msgid ""
">>> isinstance([1, 2], list[str])\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: isinstance() argument 2 cannot be a parameterized generic"
msgstr ""
">>> isinstance([1, 2], list[str])\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: isinstance() argument 2 cannot be a parameterized generic"

#: library/stdtypes.rst:5329
msgid ""
"The Python runtime does not enforce :term:`type annotations <annotation>`. "
"This extends to generic types and their type parameters. When creating a "
"container object from a ``GenericAlias``, the elements in the container are "
"not checked against their type. For example, the following code is "
"discouraged, but will run without errors::"
msgstr ""
"Ο χρόνος εκτέλεσης Python δεν επιβάλλει :term:`type annotations "
"<annotation>`. Αυτό επεκτείνεται σε generic τύπους και στις παραμέτρους "
"τύπου τους. Κατά τη δημιουργία ενός αντικειμένου container από ένα "
"``GenericAlias``, τα στοιχεία στο container δεν ελέγχονται ως προς τον τύπο "
"τους. Για παράδειγμα, ο ακόλουθος κώδικας αποθαρρύνεται, αλλά θα εκτελεστεί "
"χωρίς σφάλματα::"

#: library/stdtypes.rst:5335
msgid ""
">>> t = list[str]\n"
">>> t([1, 2, 3])\n"
"[1, 2, 3]"
msgstr ""
">>> t = list[str]\n"
">>> t([1, 2, 3])\n"
"[1, 2, 3]"

#: library/stdtypes.rst:5339
msgid ""
"Furthermore, parameterized generics erase type parameters during object "
"creation::"
msgstr ""
"Επιπλέον, τα παραμετροποιημένα generics διαγράφουν τις παραμέτρους τύπου "
"κατά τη δημιουργία αντικειμένου::"

#: library/stdtypes.rst:5342
msgid ""
">>> t = list[str]\n"
">>> type(t)\n"
"<class 'types.GenericAlias'>\n"
"\n"
">>> l = t()\n"
">>> type(l)\n"
"<class 'list'>"
msgstr ""
">>> t = list[str]\n"
">>> type(t)\n"
"<class 'types.GenericAlias'>\n"
"\n"
">>> l = t()\n"
">>> type(l)\n"
"<class 'list'>"

#: library/stdtypes.rst:5350
msgid ""
"Calling :func:`repr` or :func:`str` on a generic shows the parameterized "
"type::"
msgstr ""
"Η κλήση :func:`repr` ή :func:`str` σε ένα generic δείχνει τον "
"παραμετροποιημένο τύπο::"

#: library/stdtypes.rst:5352
msgid ""
">>> repr(list[int])\n"
"'list[int]'\n"
"\n"
">>> str(list[int])\n"
"'list[int]'"
msgstr ""
">>> repr(list[int])\n"
"'list[int]'\n"
"\n"
">>> str(list[int])\n"
"'list[int]'"

#: library/stdtypes.rst:5358
msgid ""
"The :meth:`~object.__getitem__` method of generic containers will raise an "
"exception to disallow mistakes like ``dict[str][str]``::"
msgstr ""
"Η μέθοδος :meth:`~object.__getitem__` των generic containers θα κάνει raise "
"μια εξαίρεση για την απαγόρευση λαθών όπως ``dict[str][str]``::"

#: library/stdtypes.rst:5361
msgid ""
">>> dict[str][str]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: dict[str] is not a generic class"
msgstr ""
">>> dict[str][str]\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: dict[str] is not a generic class"

#: library/stdtypes.rst:5366
msgid ""
"However, such expressions are valid when :ref:`type variables <generics>` "
"are used.  The index must have as many elements as there are type variable "
"items in the ``GenericAlias`` object's :attr:`~genericalias.__args__`. ::"
msgstr ""
"Ωστόσο, τέτοιες εκφράσεις είναι έγκυρες όταν χρησιμοποιούνται μεταβλητές "
"τύπου :ref:`type variables <generics>`.  Το ευρετήριο πρέπει να έχει τόσα "
"στοιχεία όσα και τα στοιχεία μεταβλητής τύπου στο αντικείμενο "
"``GenericAlias`` :attr:`~genericalias.__args__`. ::"

#: library/stdtypes.rst:5370
msgid ""
">>> from typing import TypeVar\n"
">>> Y = TypeVar('Y')\n"
">>> dict[str, Y][int]\n"
"dict[str, int]"
msgstr ""
">>> from typing import TypeVar\n"
">>> Y = TypeVar('Y')\n"
">>> dict[str, Y][int]\n"
"dict[str, int]"

#: library/stdtypes.rst:5377
msgid "Standard Generic Classes"
msgstr "Τυπικές Γενικές Κλάσεις"

#: library/stdtypes.rst:5379
msgid ""
"The following standard library classes support parameterized generics. This "
"list is non-exhaustive."
msgstr ""
"Οι ακόλουθες τυπικές κλάσεις βιβλιοθήκης υποστηρίζουν γενικά "
"παραμετροποιημένα. Αυτή η λίστα δεν είναι εξαντλητική."

#: library/stdtypes.rst:5382
msgid ":class:`tuple`"
msgstr ":class:`tuple`"

#: library/stdtypes.rst:5383
msgid ":class:`list`"
msgstr ":class:`list`"

#: library/stdtypes.rst:5384
msgid ":class:`dict`"
msgstr ":class:`dict`"

#: library/stdtypes.rst:5385
msgid ":class:`set`"
msgstr ":class:`set`"

#: library/stdtypes.rst:5386
msgid ":class:`frozenset`"
msgstr ":class:`frozenset`"

#: library/stdtypes.rst:5387
msgid ":class:`type`"
msgstr ":class:`type`"

#: library/stdtypes.rst:5388
msgid ":class:`asyncio.Future`"
msgstr ":class:`asyncio.Future`"

#: library/stdtypes.rst:5389
msgid ":class:`asyncio.Task`"
msgstr ":class:`asyncio.Task`"

#: library/stdtypes.rst:5390
msgid ":class:`collections.deque`"
msgstr ":class:`collections.deque`"

#: library/stdtypes.rst:5391
msgid ":class:`collections.defaultdict`"
msgstr ":class:`collections.defaultdict`"

#: library/stdtypes.rst:5392
msgid ":class:`collections.OrderedDict`"
msgstr ":class:`collections.OrderedDict`"

#: library/stdtypes.rst:5393
msgid ":class:`collections.Counter`"
msgstr ":class:`collections.Counter`"

#: library/stdtypes.rst:5394
msgid ":class:`collections.ChainMap`"
msgstr ":class:`collections.ChainMap`"

#: library/stdtypes.rst:5395
msgid ":class:`collections.abc.Awaitable`"
msgstr ":class:`collections.abc.Awaitable`"

#: library/stdtypes.rst:5396
msgid ":class:`collections.abc.Coroutine`"
msgstr ":class:`collections.abc.Coroutine`"

#: library/stdtypes.rst:5397
msgid ":class:`collections.abc.AsyncIterable`"
msgstr ":class:`collections.abc.AsyncIterable`"

#: library/stdtypes.rst:5398
msgid ":class:`collections.abc.AsyncIterator`"
msgstr ":class:`collections.abc.AsyncIterator`"

#: library/stdtypes.rst:5399
msgid ":class:`collections.abc.AsyncGenerator`"
msgstr ":class:`collections.abc.AsyncGenerator`"

#: library/stdtypes.rst:5400
msgid ":class:`collections.abc.Iterable`"
msgstr ":class:`collections.abc.Iterable`"

#: library/stdtypes.rst:5401
msgid ":class:`collections.abc.Iterator`"
msgstr ":class:`collections.abc.Iterator`"

#: library/stdtypes.rst:5402
msgid ":class:`collections.abc.Generator`"
msgstr ":class:`collections.abc.Generator`"

#: library/stdtypes.rst:5403
msgid ":class:`collections.abc.Reversible`"
msgstr ":class:`collections.abc.Reversible`"

#: library/stdtypes.rst:5404
msgid ":class:`collections.abc.Container`"
msgstr ":class:`collections.abc.Container`"

#: library/stdtypes.rst:5405
msgid ":class:`collections.abc.Collection`"
msgstr ":class:`collections.abc.Collection`"

#: library/stdtypes.rst:5406
msgid ":class:`collections.abc.Callable`"
msgstr ":class:`collections.abc.Callable`"

#: library/stdtypes.rst:5407
msgid ":class:`collections.abc.Set`"
msgstr ":class:`collections.abc.Set`"

#: library/stdtypes.rst:5408
msgid ":class:`collections.abc.MutableSet`"
msgstr ":class:`collections.abc.MutableSet`"

#: library/stdtypes.rst:5409
msgid ":class:`collections.abc.Mapping`"
msgstr ":class:`collections.abc.Mapping`"

#: library/stdtypes.rst:5410
msgid ":class:`collections.abc.MutableMapping`"
msgstr ":class:`collections.abc.MutableMapping`"

#: library/stdtypes.rst:5411
msgid ":class:`collections.abc.Sequence`"
msgstr ":class:`collections.abc.Sequence`"

#: library/stdtypes.rst:5412
msgid ":class:`collections.abc.MutableSequence`"
msgstr ":class:`collections.abc.MutableSequence`"

#: library/stdtypes.rst:5413
msgid ":class:`collections.abc.MappingView`"
msgstr ":class:`collections.abc.MappingView`"

#: library/stdtypes.rst:5414
msgid ":class:`collections.abc.KeysView`"
msgstr ":class:`collections.abc.KeysView`"

#: library/stdtypes.rst:5415
msgid ":class:`collections.abc.ItemsView`"
msgstr ":class:`collections.abc.ItemsView`"

#: library/stdtypes.rst:5416
msgid ":class:`collections.abc.ValuesView`"
msgstr ":class:`collections.abc.ValuesView`"

#: library/stdtypes.rst:5417
msgid ":class:`contextlib.AbstractContextManager`"
msgstr ":class:`contextlib.AbstractContextManager`"

#: library/stdtypes.rst:5418
msgid ":class:`contextlib.AbstractAsyncContextManager`"
msgstr ":class:`contextlib.AbstractAsyncContextManager`"

#: library/stdtypes.rst:5419
msgid ":class:`dataclasses.Field`"
msgstr ":class:`dataclasses.Field`"

#: library/stdtypes.rst:5420
msgid ":class:`functools.cached_property`"
msgstr ":class:`functools.cached_property`"

#: library/stdtypes.rst:5421
msgid ":class:`functools.partialmethod`"
msgstr ":class:`functools.partialmethod`"

#: library/stdtypes.rst:5422
msgid ":class:`os.PathLike`"
msgstr ":class:`os.PathLike`"

#: library/stdtypes.rst:5423
msgid ":class:`queue.LifoQueue`"
msgstr ":class:`queue.LifoQueue`"

#: library/stdtypes.rst:5424
msgid ":class:`queue.Queue`"
msgstr ":class:`queue.Queue`"

#: library/stdtypes.rst:5425
msgid ":class:`queue.PriorityQueue`"
msgstr ":class:`queue.PriorityQueue`"

#: library/stdtypes.rst:5426
msgid ":class:`queue.SimpleQueue`"
msgstr ":class:`queue.SimpleQueue`"

#: library/stdtypes.rst:5427
msgid ":ref:`re.Pattern <re-objects>`"
msgstr ":ref:`re.Pattern <re-objects>`"

#: library/stdtypes.rst:5428
msgid ":ref:`re.Match <match-objects>`"
msgstr ":ref:`re.Match <match-objects>`"

#: library/stdtypes.rst:5429
msgid ":class:`shelve.BsdDbShelf`"
msgstr ":class:`shelve.BsdDbShelf`"

#: library/stdtypes.rst:5430
msgid ":class:`shelve.DbfilenameShelf`"
msgstr ":class:`shelve.DbfilenameShelf`"

#: library/stdtypes.rst:5431
msgid ":class:`shelve.Shelf`"
msgstr ":class:`shelve.Shelf`"

#: library/stdtypes.rst:5432
msgid ":class:`types.MappingProxyType`"
msgstr ":class:`types.MappingProxyType`"

#: library/stdtypes.rst:5433
msgid ":class:`weakref.WeakKeyDictionary`"
msgstr ":class:`weakref.WeakKeyDictionary`"

#: library/stdtypes.rst:5434
msgid ":class:`weakref.WeakMethod`"
msgstr ":class:`weakref.WeakMethod`"

#: library/stdtypes.rst:5435
msgid ":class:`weakref.WeakSet`"
msgstr ":class:`weakref.WeakSet`"

#: library/stdtypes.rst:5436
msgid ":class:`weakref.WeakValueDictionary`"
msgstr ":class:`weakref.WeakValueDictionary`"

#: library/stdtypes.rst:5441
msgid "Special Attributes of ``GenericAlias`` objects"
msgstr "Ειδικά Χαρακτηριστικά αντικειμένων ``GenericAlias``"

#: library/stdtypes.rst:5443
msgid "All parameterized generics implement special read-only attributes."
msgstr ""
"Όλα τα παραμετροποιημένα generics εφαρμόζουν ειδικά χαρακτηριστικά μόνο για "
"ανάγνωση."

#: library/stdtypes.rst:5447
msgid "This attribute points at the non-parameterized generic class::"
msgstr "Αυτό το χαρακτηριστικό δείχνει στη μη παραμετροποιημένη γενική κλάση::"

#: library/stdtypes.rst:5449
msgid ""
">>> list[int].__origin__\n"
"<class 'list'>"
msgstr ""
">>> list[int].__origin__\n"
"<class 'list'>"

#: library/stdtypes.rst:5455
msgid ""
"This attribute is a :class:`tuple` (possibly of length 1) of generic types "
"passed to the original :meth:`~object.__class_getitem__` of the generic "
"class::"
msgstr ""
"Αυτό το χαρακτηριστικό είναι μια :class:`tuple` (πιθανώς μήκους 1) generic "
"τύπων που μεταβιβάστηκαν στο αρχικό :meth:`~object.__class_getitem__` της "
"generic κλάσης::"

#: library/stdtypes.rst:5459
msgid ""
">>> dict[str, list[int]].__args__\n"
"(<class 'str'>, list[int])"
msgstr ""
">>> dict[str, list[int]].__args__\n"
"(<class 'str'>, list[int])"

#: library/stdtypes.rst:5465
msgid ""
"This attribute is a lazily computed tuple (possibly empty) of unique type "
"variables found in ``__args__``::"
msgstr ""
"Αυτό το χαρακτηριστικό είναι μία νωχελικά υπολογισμένη πλειάδα (tuple) "
"(πιθανώς κενή) μεταβλητών μοναδικού τύπου που βρίσκονται στο ``__args__``::"

#: library/stdtypes.rst:5468
msgid ""
">>> from typing import TypeVar\n"
"\n"
">>> T = TypeVar('T')\n"
">>> list[T].__parameters__\n"
"(~T,)"
msgstr ""
">>> from typing import TypeVar\n"
"\n"
">>> T = TypeVar('T')\n"
">>> list[T].__parameters__\n"
"(~T,)"

#: library/stdtypes.rst:5476
msgid ""
"A ``GenericAlias`` object with :class:`typing.ParamSpec` parameters may not "
"have correct ``__parameters__`` after substitution because :class:`typing."
"ParamSpec` is intended primarily for static type checking."
msgstr ""
"Ένα αντικείμενο ``GenericAlias`` με παραμέτρους :class:`typing.ParamSpec` "
"ενδέχεται να μην έχει σωστές ``__parameters__`` μετά την αντικατάσταση "
"επειδή το :class:`typing.ParamSpec` προορίζεται κυρίως για έλεγχο στατικού "
"τύπου."

#: library/stdtypes.rst:5483
msgid ""
"A boolean that is true if the alias has been unpacked using the ``*`` "
"operator (see :data:`~typing.TypeVarTuple`)."
msgstr ""
"Ένα boolean που ισχύει αν το alias έχει αποσυμπιεστεί χρησιμοποιώντας τον "
"τελεστή ``*`` (δείτε το :data:`~typing.TypeVarTuple`)."

#: library/stdtypes.rst:5491
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - Type Hints"

#: library/stdtypes.rst:5492
msgid "Introducing Python's framework for type annotations."
msgstr "Παρουσιάζοντας το framework της Python για τύπους annotations."

#: library/stdtypes.rst:5494
msgid ":pep:`585` - Type Hinting Generics In Standard Collections"
msgstr ":pep:`585` - Τύπος Generics Συμβουλών στις Τυπικές Συλλογές"

#: library/stdtypes.rst:5495
msgid ""
"Introducing the ability to natively parameterize standard-library classes, "
"provided they implement the special class method :meth:`~object."
"__class_getitem__`."
msgstr ""
"Εισαγωγή της δυνατότητας εγγενούς παραμετροποίησης κλάσεων τυπικής "
"βιβλιοθήκης, υπό την προϋπόθεση ότι εφαρμόζουν τη μέθοδο ειδικής κλάσης :"
"meth:`~object.__class_getitem__`."

#: library/stdtypes.rst:5499
msgid ""
":ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` and :"
"class:`typing.Generic`"
msgstr ""
"Τα :ref:`Generics`, :ref:`user-defined generics <user-defined-generics>` "
"και :class:`typing.Generic`"

#: library/stdtypes.rst:5500
msgid ""
"Documentation on how to implement generic classes that can be parameterized "
"at runtime and understood by static type-checkers."
msgstr ""
"Τεκμηρίωση για τον τρόπο υλοποίησης generic κλάσεων που μπορούν να "
"παραμετροποιηθούν κατά το χρόνο εκτέλεσης και να κατανοηθούν από στατικούς "
"ελεγκτές τύπων."

#: library/stdtypes.rst:5509
msgid "Union Type"
msgstr "Τύπος Ένωσης"

#: library/stdtypes.rst:5515
msgid ""
"A union object holds the value of the ``|`` (bitwise or) operation on "
"multiple :ref:`type objects <bltin-type-objects>`.  These types are intended "
"primarily for :term:`type annotations <annotation>`. The union type "
"expression enables cleaner type hinting syntax compared to subscripting :"
"class:`typing.Union`."
msgstr ""
"Ένα αντικείμενο ένωσης διατηρεί την τιμή της λειτουργίας ``|`` (bitwise or) "
"σε πολλαπλά αντικείμενα :ref:`type objects <bltin-type-objects>`.  Αυτοί οι "
"τύποι προορίζονται κυρίως για :term:`type annotations <annotation>`. Η "
"έκφραση τύπου ένωσης επιτρέπει την καθαρότερη σύνταξη υποδείξεων σε σύγκριση "
"με την εγγραφή :class:`typing.Union`."

#: library/stdtypes.rst:5522
msgid ""
"Defines a union object which holds types *X*, *Y*, and so forth. ``X | Y`` "
"means either X or Y.  It is equivalent to ``typing.Union[X, Y]``. For "
"example, the following function expects an argument of type :class:`int` or :"
"class:`float`::"
msgstr ""
"Ορίζει ένα αντικείμενο ένωσης που περιέχει τύπους *X*, *Y*, και ούτω "
"καθεξής. Το ``X | Y`` σημαίνει είτε X είτε Y.  Είναι ισοδύναμο με το "
"``typing.Union[X, Y]``. Για παράδειγμα, η ακόλουθη συνάρτηση αναμένει ένα "
"όρισμα τύπου :class:`int` or :class:`float`::"

#: library/stdtypes.rst:5527
msgid ""
"def square(number: int | float) -> int | float:\n"
"    return number ** 2"
msgstr ""
"def square(number: int | float) -> int | float:\n"
"    return number ** 2"

#: library/stdtypes.rst:5532
msgid ""
"The ``|`` operand cannot be used at runtime to define unions where one or "
"more members is a forward reference. For example, ``int | \"Foo\"``, where "
"``\"Foo\"`` is a reference to a class not yet defined, will fail at runtime. "
"For unions which include forward references, present the whole expression as "
"a string, e.g. ``\"int | Foo\"``."
msgstr ""
"Ο τελεστής ``|`` δεν μπορεί να χρησιμοποιηθεί κατά το χρόνο εκτέλεσης για να "
"ορίσει ενώσεις όπου ένα ή περισσότερα μέλη είναι μια μπροστινή αναφορά. Για  "
"παράδειγμα το ``int | \"Foo\"``, όπου το ``\"Foo\"`` είναι μια αναφορά σε "
"μια κλάση που δεν έχει ακόμη καθοριστεί, θα αποτύχει κατά το χρόνο "
"εκτέλεσης. Για ενώσεις που περιλαμβάνουν μπροστινές αναφορές, παρουσιάζει "
"ολόκληρη την έκφραση ως συμβολοσειρά, π.χ. ``\"int | Foo\"``."

#: library/stdtypes.rst:5540
msgid ""
"Union objects can be tested for equality with other union objects.  Details:"
msgstr ""
"Τα αντικείμενα ένωσης μπορούν να ελεγχθούν για ισότητα με άλλα αντικείμενα "
"ένωσης.  Λεπτομέρειες:"

#: library/stdtypes.rst:5542
msgid "Unions of unions are flattened::"
msgstr "Οι ενώσεις των ενώσεων ισοπεδώνονται::"

#: library/stdtypes.rst:5544
msgid "(int | str) | float == int | str | float"
msgstr "(int | str) | float == int | str | float"

#: library/stdtypes.rst:5546
msgid "Redundant types are removed::"
msgstr "Οι περιττοί τύποι καταργούνται::"

#: library/stdtypes.rst:5548
msgid "int | str | int == int | str"
msgstr "int | str | int == int | str"

#: library/stdtypes.rst:5550
msgid "When comparing unions, the order is ignored::"
msgstr "Κατά τη σύγκριση των ενώσεων, η σειρά αγνοείται::"

#: library/stdtypes.rst:5552
msgid "int | str == str | int"
msgstr "int | str == str | int"

#: library/stdtypes.rst:5554
msgid "It creates instances of :class:`typing.Union`::"
msgstr "Δημιουργεί στιγμιότυπα της :class:`typing.Union`::"

#: library/stdtypes.rst:5556
msgid ""
"int | str == typing.Union[int, str]\n"
"type(int | str) is typing.Union"
msgstr ""
"int | str == typing.Union[int, str]\n"
"type(int | str) is typing.Union"

#: library/stdtypes.rst:5559
msgid "Optional types can be spelled as a union with ``None``::"
msgstr "Οι προαιρετικοί τύποι μπορούν να γραφτούν ως ένωση με ``None``::"

#: library/stdtypes.rst:5561
msgid "str | None == typing.Optional[str]"
msgstr "str | None == typing.Optional[str]"

#: library/stdtypes.rst:5566
msgid ""
"Calls to :func:`isinstance` and :func:`issubclass` are also supported with a "
"union object::"
msgstr ""
"Οι κλήσεις σε :func:`isinstance` και :func:`issubclass` υποστηρίζονται "
"επίσης με ένα αντικείμενο ένωσης::"

#: library/stdtypes.rst:5569
msgid ""
">>> isinstance(\"\", int | str)\n"
"True"
msgstr ""
">>> isinstance(\"\", int | str)\n"
"True"

#: library/stdtypes.rst:5572
msgid ""
"However, :ref:`parameterized generics <types-genericalias>` in union objects "
"cannot be checked::"
msgstr ""
"Ωστόσο, το :ref:`parameterized generics <types-genericalias>` σε αντικείμενα "
"ένωσης δεν μπορούν να ελεγχθούν::"

#: library/stdtypes.rst:5575
msgid ""
">>> isinstance(1, int | list[int])  # short-circuit evaluation\n"
"True\n"
">>> isinstance([1], int | list[int])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: isinstance() argument 2 cannot be a parameterized generic"
msgstr ""
">>> isinstance(1, int | list[int])  # short-circuit evaluation\n"
"True\n"
">>> isinstance([1], int | list[int])\n"
"Traceback (most recent call last):\n"
"  ...\n"
"TypeError: isinstance() argument 2 cannot be a parameterized generic"

#: library/stdtypes.rst:5582
msgid ""
"The user-exposed type for the union object can be accessed from :class:"
"`typing.Union` and used for :func:`isinstance` checks::"
msgstr ""
"Ο τύπος που εκτίθεται από τον χρήστη για το αντικείμενο ένωσης μπορεί να "
"προσπελαστεί από το :data:`types.UnionType` και να χρησιμοποιηθεί για "
"ελέγχους :func:`isinstance`."

#: library/stdtypes.rst:5585
msgid ""
">>> import typing\n"
">>> isinstance(int | str, typing.Union)\n"
"True\n"
">>> typing.Union()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: cannot create 'typing.Union' instances"
msgstr ""
">>> import typing\n"
">>> isinstance(int | str, typing.Union)\n"
"True\n"
">>> typing.Union()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: cannot create 'typing.Union' instances"

#: library/stdtypes.rst:5594
msgid ""
"The :meth:`!__or__` method for type objects was added to support the syntax "
"``X | Y``.  If a metaclass implements :meth:`!__or__`, the Union may "
"override it:"
msgstr ""
"Η μέθοδος :meth:`!__or__` για αντικείμενα τύπου προστέθηκε για να "
"υποστηρίξει τη σύνταξη ``X | Y``.  Εάν μια μετακλάση υλοποιεί :meth:`!"
"__or__`, η Ένωση μπορεί να την παρακάμψει:"

#: library/stdtypes.rst:5598
msgid ""
">>> class M(type):\n"
"...     def __or__(self, other):\n"
"...         return \"Hello\"\n"
"...\n"
">>> class C(metaclass=M):\n"
"...     pass\n"
"...\n"
">>> C | int\n"
"'Hello'\n"
">>> int | C\n"
"int | C"
msgstr ""
">>> class M(type):\n"
"...     def __or__(self, other):\n"
"...         return \"Hello\"\n"
"...\n"
">>> class C(metaclass=M):\n"
"...     pass\n"
"...\n"
">>> C | int\n"
"'Hello'\n"
">>> int | C\n"
"int | C"

#: library/stdtypes.rst:5614
msgid ":pep:`604` -- PEP proposing the ``X | Y`` syntax and the Union type."
msgstr ""
":pep:`604` -- Το PEP προτείνει τη σύνταξη ``X | Y`` και τον τύπο Ένωση."

#: library/stdtypes.rst:5620
msgid ""
"Union objects are now instances of :class:`typing.Union`. Previously, they "
"were instances of :class:`types.UnionType`, which remains an alias for :"
"class:`typing.Union`."
msgstr ""
"Τα αντικείμενα Union είναι πλέον στιγμιότυπα του :class:`typing.Union`. "
"Προηγουμένως, ήταν στιγμιότυπα της :class:`types.UnionType`, το οποίο "
"παραμείνει ένα ψευδώνυμο για τη :class:`typing.Union`."

#: library/stdtypes.rst:5627
msgid "Other Built-in Types"
msgstr "Άλλοι Ενσωματωμένοι (built-in) Τύποι"

#: library/stdtypes.rst:5629
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"Ο διερμηνέας υποστηρίζει πολλά άλλα είδη αντικειμένων. Τα περισσότερα από "
"αυτά υποστηρίζουν μόνο μία ή δύο λειτουργίες."

#: library/stdtypes.rst:5636
msgid "Modules"
msgstr "Modules"

#: library/stdtypes.rst:5638
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"Η μόνη ειδική λειτουργία σε ένα module είναι η πρόσβαση χαρακτηριστικών: ``m."
"name``, όπου το *m* είναι ένα module και το *name* έχει πρόσβαση σε ένα "
"όνομα που ορίζεται στον πίνακα συμβόλων του *m*. Τα χαρακτηριστικά του "
"module μπορούν να εκχωρηθούν.  (Σημειώστε ότι η δήλωση :keyword:`import` δεν "
"είναι, αυστηρά, μια λειτουργία σε ένα αντικείμενο module· το ``import foo`` "
"δεν απαιτεί να υπάρχει ένα αντικείμενο module με το όνομα *foo* αλλά απαιτεί "
"έναν (εξωτερικό) *definition* για ένα module που ονομάζεται *foo* κάπου.)"

#: library/stdtypes.rst:5645
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`~object.__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is not "
"recommended."
msgstr ""
"Ένα ειδικό χαρακτηριστικό κάθε module είναι :attr:`~object.__dict__`. Αυτό "
"είναι το λεξικό που περιέχει τον πίνακα συμβόλων της ενότητας. Η τροποποίηση "
"αυτού του λεξικού θα αλλάξει στην πραγματικότητα τον πίνακα συμβόλων του "
"module, αλλά η απευθείας εκχώρηση στο χαρακτηριστικό :attr:`~object."
"__dict__` δεν είναι δυνατή (μπορείτε να γράψετε ``m.__dict__['a'] = 1``, που "
"ορίζει το ``m.a`` να είναι ``1``, αλλά δεν μπορείτε να γράψετε ``m.__dict__ "
"= {}``).  Δεν συνίσταται η απευθείας τροποποίηση του :attr:`~object."
"__dict__`."

#: library/stdtypes.rst:5653
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"Τα modules που είναι ενσωματωμένες στον διερμηνέα γράφονται ως εξής: "
"``<module 'sys' (built-in)>``.  Εάν φορτωθούν από ένα αρχείο, γράφονται ως "
"``<module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."

#: library/stdtypes.rst:5661
msgid "Classes and Class Instances"
msgstr "Κλάσεις και Στιγμιότυπα Κλάσης"

#: library/stdtypes.rst:5663
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Δείτε :ref:`objects` και :ref:`class` για αυτά."

#: library/stdtypes.rst:5669
msgid "Functions"
msgstr "Συναρτήσεις"

#: library/stdtypes.rst:5671
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""
"Τα αντικείμενα συναρτήσεων δημιουργούνται από ορισμούς συναρτήσεων.  Η μόνη "
"λειτουργία σε ένα αντικείμενο συνάρτησης είναι να το ονομάσουμε: "
"``func(argument-list)``."

#: library/stdtypes.rst:5674
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"Υπάρχουν πραγματικά δύο είδη αντικειμένων συναρτήσεων: ενσωματωμένες "
"συναρτήσεις και συναρτήσεις που καθορίζονται από τον χρήστη.  Και οι δύο "
"υποστηρίζουν την ίδια λειτουργία (για να καλέσετε τη συνάρτηση), αλλά η "
"υλοποίηση είναι διαφορετική, εξ ου και οι διαφορετικοί τύποι αντικειμένων."

#: library/stdtypes.rst:5678
msgid "See :ref:`function` for more information."
msgstr "Δείτε το :ref:`function` για περισσότερες πληροφορίες."

#: library/stdtypes.rst:5684
msgid "Methods"
msgstr "Μέθοδοι"

#: library/stdtypes.rst:5688
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: :ref:`built-in methods <builtin-methods>` (such as :meth:"
"`append` on lists) and :ref:`class instance method <instance-methods>`. "
"Built-in methods are described with the types that support them."
msgstr ""
"Οι μέθοδοι είναι συναρτήσεις που καλούνται χρησιμοποιώντας το notation "
"χαρακτηριστικών. Υπάρχουν δύο είδη: :ref:`built-in methods <builtin-"
"methods>` (όπως η :meth:`append` στις λίστες) και :ref:`class instance "
"method <instance-methods>`. Οι ενσωματωμένες μέθοδοι περιγράφονται με τους "
"τύπους που τις υποστηρίζουν."

#: library/stdtypes.rst:5693
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :ref:"
"`instance method <instance-methods>`) object. When called, it will add the "
"``self`` argument to the argument list.  Bound methods have two special read-"
"only attributes: :attr:`m.__self__ <method.__self__>` is the object on which "
"the method operates, and :attr:`m.__func__ <method.__func__>` is the "
"function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-n)`` "
"is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""
"Εάν αποκτήσετε πρόσβαση σε μια μέθοδο (μια συνάρτηση που ορίζεται μια "
"namespace κλάση) μέσω ενός στιγμιοτύπου, λαμβάνετε ένα ειδικό αντικείμενο: "
"ένα αντικείμενο :dfn:`bound method` (ονομάζεται επίσης :ref:`instance method "
"<instance-methods>`). Όταν καλείται, θα προσθέσει το όρισμα ``self`` στη "
"λίστα ορισμάτων.  Οι δεσμευμένες μέθοδοι έχουν δύο ειδικά χαρακτηριστικά "
"μόνο για ανάγνωση: :attr:`m.__self__ <method.__self__>` είναι το αντικείμενο "
"στο οποίο λειτουργεί η μέθοδος και :attr:`m.__func__ <method.__func__>` "
"είναι η συνάρτηση που υλοποιεί την μέθοδο.  Η κλήση του ``m(arg-1, "
"arg-2, ..., arg-n)`` είναι απολύτως ισοδύναμη με την κλήση του ``m."
"__func__(m.__self__, arg-1, arg-2, ..., arg-n)``."

#: library/stdtypes.rst:5704
msgid ""
"Like :ref:`function objects <user-defined-funcs>`, bound method objects "
"support getting arbitrary attributes.  However, since method attributes are "
"actually stored on the underlying function object (:attr:`method.__func__`), "
"setting method attributes on bound methods is disallowed.  Attempting to set "
"an attribute on a method results in an :exc:`AttributeError` being raised.  "
"In order to set a method attribute, you need to explicitly set it on the "
"underlying function object:"
msgstr ""
"Όπως τα :ref:`function objects <user-defined-funcs>`, τα αντικείμενα "
"δεσμευμένης μεθόδου υποστηρίζουν τη λήψη αυθαίρετων χαρακτηριστικών. Ωστόσο, "
"δεδομένου ότι τα χαρακτηριστικά της μεθόδου αποθηκεύονται στην "
"πραγματικότητα στο υποκείμενο αντικείμενο συνάρτησης (:attr:`method."
"__func__`), ο ορισμός χαρακτηριστικών μεθόδου σε δεσμευμένες μεθόδους δεν "
"επιτρέπεται.  Η προσπάθεια ορισμού ενός χαρακτηριστικού σε μια μέθοδο έχει "
"ως αποτέλεσμα να γίνει raise η :exc:`AttributeError`.  Για να ορίσετε ένα "
"χαρακτηριστικό μεθόδου πρέπει να το ορίσετε ρητά στο υποκείμενο αντικείμενο "
"συνάρτησης:"

#: library/stdtypes.rst:5712
msgid ""
">>> class C:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> c = C()\n"
">>> c.method.whoami = 'my name is method'  # can't set on the method\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"AttributeError: 'method' object has no attribute 'whoami'\n"
">>> c.method.__func__.whoami = 'my name is method'\n"
">>> c.method.whoami\n"
"'my name is method'"
msgstr ""
">>> class C:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> c = C()\n"
">>> c.method.whoami = 'my name is method'  # can't set on the method\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"AttributeError: 'method' object has no attribute 'whoami'\n"
">>> c.method.__func__.whoami = 'my name is method'\n"
">>> c.method.whoami\n"
"'my name is method'"

#: library/stdtypes.rst:5727
msgid "See :ref:`instance-methods` for more information."
msgstr "Δείτε το :ref:`instance-methods` για περισσότερες πληροφορίες."

#: library/stdtypes.rst:5735
msgid "Code Objects"
msgstr "Αντικείμενα Κώδικα"

#: library/stdtypes.rst:5741
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`~function.__code__` attribute. See also the :mod:`code` module."
msgstr ""
"Τα αντικείμενα κώδικα χρησιμοποιούνται από την υλοποίηση για να "
"αναπαραστήσουν τον \"ψευδο-μεταγλωττισμένο\" εκτελέσιμο κώδικα Python, όπως "
"ένα σώμα συνάρτησης. Διαφέρουν από τα αντικείμενα συνάρτησης επειδή δεν "
"περιέχουν αναφορά στο παγκόσμιο (global) περιβάλλον εκτέλεσης τους.  Τα "
"αντικείμενα κώδικα επιστρέφονται από την ενσωματωμένη συνάρτηση :func:"
"`compile` και μπορεί να εξαχθεί από τα αντικείμενα συνάρτησης μέσω του "
"χαρακτηριστικού τους :attr:`~function.__code__`. Δείτε επίσης το module :mod:"
"`code`."

#: library/stdtypes.rst:5748
msgid ""
"Accessing :attr:`~function.__code__` raises an :ref:`auditing event "
"<auditing>` ``object.__getattr__`` with arguments ``obj`` and "
"``\"__code__\"``."
msgstr ""
"Η πρόσβαση στη :attr:`~function.__code__` κάνει raise ένα :ref:`auditing "
"event <auditing>` ``object.__getattr__`` με ορίσματα ``obj`` και "
"``\"__code__\"``."

#: library/stdtypes.rst:5755
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"Ένα αντικείμενο κώδικα μπορεί να εκτελεστεί ή να αξιολογηθεί περνώντας το "
"(αντί για πηγαία συμβολοσειρά) στις ενσωματωμένες συναρτήσεις :func:`exec` "
"ή :func:`eval`."

#: library/stdtypes.rst:5758
msgid "See :ref:`types` for more information."
msgstr "Δείτε :ref:`types` για περισσότερες πληροφορίες."

#: library/stdtypes.rst:5764
msgid "Type Objects"
msgstr "Τύποι Αντικειμένων"

#: library/stdtypes.rst:5770
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""
"Τα αντικείμενα τύπου αντιπροσωπεύουν τους διάφορους τύπους αντικειμένων.  Ο "
"τύπος ενός αντικειμένου προσεγγίζεται από την ενσωματωμένη συνάρτηση :func:"
"`type`.  Δεν υπάρχουν ειδικές λειτουργίες στους τύπους.  Το τυπικό "
"(standard) module :mod:`types` ορίζει ονόματα για όλους τους τυπικούς "
"ενσωματωμένους τύπους."

#: library/stdtypes.rst:5775
msgid "Types are written like this: ``<class 'int'>``."
msgstr "Οι τύποι γράφονται ως εξής: ``<class 'int'>``."

#: library/stdtypes.rst:5781
msgid "The Null Object"
msgstr "Το Αντικείμενο Null"

#: library/stdtypes.rst:5783
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name).  ``type(None)()`` produces the same singleton."
msgstr ""
"Αυτό το αντικείμενο επιστρέφεται από συναρτήσεις που δεν επιστρέφουν ρητά "
"μια τιμή.  Δεν υποστηρίζει ειδικές λειτουργίες.  Υπάρχει ακριβώς ένα "
"μηδενικό αντικείμενο, που ονομάζεται ``None`` (ένα ενσωματωμένο όνομα).  Το "
"``type(None)()`` παράγει το ίδιο singleton."

#: library/stdtypes.rst:5787
msgid "It is written as ``None``."
msgstr "Γράφεται ως ``None``."

#: library/stdtypes.rst:5794
msgid "The Ellipsis Object"
msgstr "Το αντικείμενο Ellipsis"

#: library/stdtypes.rst:5796
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces the :const:"
"`Ellipsis` singleton."
msgstr ""
"Αυτό το αντικείμενο χρησιμοποιείται συνήθως με λειτουργία τμηματοποίησης "
"(δείτε :ref:`slicings`).  Δεν υποστηρίζει ειδικές λειτουργίες.  Υπάρχει "
"ακριβώς ένα αντικείμενο έλλειψης, που ονομάζεται :const:`Ellipsis` (ένα "
"ενσωματωμένο όνομα).  Το ``type(Ellipsis)()`` παράγει το :const:`Ellipsis` "
"singleton."

#: library/stdtypes.rst:5801
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "Γράφεται ως ``Ellipsis`` ή ``...``."

#: library/stdtypes.rst:5807
msgid "The NotImplemented Object"
msgstr "Το NotImplemented Αντικείμενο"

#: library/stdtypes.rst:5809
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information.  There is exactly one :data:`NotImplemented` object. :code:"
"`type(NotImplemented)()` produces the singleton instance."
msgstr ""
"Αυτό το αντικείμενο επιστρέφεται από συγκρίσεις και δυαδικές λειτουργίες "
"όταν τους ζητείται να λειτουργήσουν σε τύπους που δεν υποστηρίζουν. Δείτε "
"το :ref:`comparisons` για περισσότερες πληροφορίες.  Υπάρχει ακριβώς ένα "
"αντικείμενο :data:`NotImplemented`. Το :code:`type(NotImplemented)()` "
"παράγει το στιγμιότυπο singleton."

#: library/stdtypes.rst:5814
msgid "It is written as :code:`NotImplemented`."
msgstr "Είναι γραμμένο ως :code:`NotImplemented`."

#: library/stdtypes.rst:5820
msgid "Internal Objects"
msgstr "Εσωτερικά Αντικείμενα"

#: library/stdtypes.rst:5822
msgid ""
"See :ref:`types` for this information.  It describes :ref:`stack frame "
"objects <frame-objects>`, :ref:`traceback objects <traceback-objects>`, and "
"slice objects."
msgstr ""
"Δείτε :ref:`types` για αυτές τις πληροφορίες.  Περιγράφει :ref:`stack frame "
"objects <frame-objects>`, :ref:`traceback objects <traceback-objects>`, και "
"αντικείμενα τμηματοποίησης."

#: library/stdtypes.rst:5830
msgid "Special Attributes"
msgstr "Ειδικά Χαρακτηριστικά"

#: library/stdtypes.rst:5832
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""
"Η υλοποίηση προσθέτει μερικά ειδικά χαρακτηριστικά μόνο για ανάγνωση σε "
"διάφορους τύπους αντικειμένων, όπου είναι σχετικά.  Ορισμένα από αυτά δεν "
"αναφέρονται από την ενσωματωμένη συνάρτηση :func:`dir`."

#: library/stdtypes.rst:5839
msgid ""
"The name of the class, function, method, descriptor, or generator instance."
msgstr ""
"Το όνομα της κλάσης, της συνάρτησης, της μεθόδου, του descriptor ή του "
"στιγμιοτύπου generator."

#: library/stdtypes.rst:5845
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or "
"generator instance."
msgstr ""
"Το :term:`qualified name` της κλάσης, της συνάρτησης, της μεθόδου, του "
"descriptor, ή του στιγμιοτύπου generator."

#: library/stdtypes.rst:5853
msgid "The name of the module in which a class or function was defined."
msgstr "Το όνομα του module στο οποίο ορίστηκε μια κλάση ή μια συνάρτηση."

#: library/stdtypes.rst:5858
msgid ""
"The documentation string of a class or function, or ``None`` if undefined."
msgstr ""
"Η συμβολοσειρά τεκμηρίωσης μιας κλάσης ή συνάρτησης ή ``None`` εάν δεν έχει "
"οριστεί."

#: library/stdtypes.rst:5863
msgid ""
"The :ref:`type parameters <type-params>` of generic classes, functions, and :"
"ref:`type aliases <type-aliases>`. For classes and functions that are not "
"generic, this will be an empty tuple."
msgstr ""
"Οι παράμετροι :ref:`type parameters <type-params>` των γενικών κλάσεων, "
"συναρτήσεων και :ref:`type aliases <type-aliases>`. Για κλάσεις και "
"συναρτήσεις που δεν είναι γενικές, αυτή θα είναι μια κενή πλειάδα."

#: library/stdtypes.rst:5873
msgid "Integer string conversion length limitation"
msgstr "Περιορισμός μήκους μετατροπής συμβολοσειράς ακέραιου αριθμού"

#: library/stdtypes.rst:5875
msgid ""
"CPython has a global limit for converting between :class:`int` and :class:"
"`str` to mitigate denial of service attacks. This limit *only* applies to "
"decimal or other non-power-of-two number bases. Hexadecimal, octal, and "
"binary conversions are unlimited. The limit can be configured."
msgstr ""
"Η CPython έχει ένα παγκόσμιο όριο για τη μετατροπή μεταξύ :class:`int` and :"
"class:`str` για τον μετριασμό των επιθέσεων άρνησης υπηρεσίας. Αυτό το όριο "
"ισχύει *μόνο* για δεκαδικές ή άλλες βάσεις αριθμών που δεν έχουν την δύναμη "
"του δύο. Οι δεξαεξαδικές, οκταδικές, και δυαδικές μετατροπές είναι "
"απεριόριστες. Το όριο μπορεί να διαμορφωθεί."

#: library/stdtypes.rst:5880
msgid ""
"The :class:`int` type in CPython is an arbitrary length number stored in "
"binary form (commonly known as a \"bignum\"). There exists no algorithm that "
"can convert a string to a binary integer or a binary integer to a string in "
"linear time, *unless* the base is a power of 2. Even the best known "
"algorithms for base 10 have sub-quadratic complexity. Converting a large "
"value such as ``int('1' * 500_000)`` can take over a second on a fast CPU."
msgstr ""
"Ο τύπος :class:`int` στην CPython είναι ένας αυθαίρετος αριθμός μήκους που "
"είναι αποθηκευμένος σε δυαδική μορφή (κοινώς γνωστός ως \"bignum\"). Δεν "
"υπάρχει αλγόριθμος που να μπορεί να μετατρέψει μια συμβολοσειρά σε δυαδικό "
"ακέραιο ή δυαδικό ακέραιο σε μια συμβολοσειρά σε γραμμικό χρόνο, *εκτός* εάν "
"η βάση είναι δύναμη του 2. Ακόμη και οι πιο γνωστοί αλγόριθμοι για τη βάση "
"10 έχουν υποτετραγωνική πολυπλοκότητα. Η μετατροπή μιας μεγάλης τιμής όπως "
"``int('1' * 500_000)`` μπορεί να διαρκέσει περισσότερο από ένα δευτερόλεπτο "
"σε μια γρήγορη CPU."

#: library/stdtypes.rst:5887
msgid ""
"Limiting conversion size offers a practical way to avoid :cve:`2020-10735`."
msgstr ""
"Ο περιορισμός του μεγέθους μετατροπής προσφέρει έναν πρακτικό τρόπο αποφυγής "
"του :cve:`2020-10735`."

#: library/stdtypes.rst:5889
msgid ""
"The limit is applied to the number of digit characters in the input or "
"output string when a non-linear conversion algorithm would be involved.  "
"Underscores and the sign are not counted towards the limit."
msgstr ""
"Το όριο εφαρμόζεται στον αριθμό των ψηφιακών χαρακτήρων στη συμβολοσειρά "
"εισόδου ή εξόδου όταν εμπλέκεται ένας μη γραμμικός αλγόριθμος μετατροπής.  "
"Τα underscores και το πρόσημο δεν υπολογίζονται στο όριο."

#: library/stdtypes.rst:5893
msgid ""
"When an operation would exceed the limit, a :exc:`ValueError` is raised:"
msgstr ""
"Όταν μια λειτουργία υπερβαίνει το όριο, γίνεται raise μια :exc:`ValueError`:"

#: library/stdtypes.rst:5895
msgid ""
">>> import sys\n"
">>> sys.set_int_max_str_digits(4300)  # Illustrative, this is the default.\n"
">>> _ = int('2' * 5432)\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Exceeds the limit (4300 digits) for integer string conversion: "
"value has 5432 digits; use sys.set_int_max_str_digits() to increase the "
"limit\n"
">>> i = int('2' * 4300)\n"
">>> len(str(i))\n"
"4300\n"
">>> i_squared = i*i\n"
">>> len(str(i_squared))\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Exceeds the limit (4300 digits) for integer string conversion; "
"use sys.set_int_max_str_digits() to increase the limit\n"
">>> len(hex(i_squared))\n"
"7144\n"
">>> assert int(hex(i_squared), base=16) == i*i  # Hexadecimal is unlimited."
msgstr ""
">>> import sys\n"
">>> sys.set_int_max_str_digits(4300)  # Illustrative, this is the default.\n"
">>> _ = int('2' * 5432)\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Exceeds the limit (4300 digits) for integer string conversion: "
"value has 5432 digits; use sys.set_int_max_str_digits() to increase the "
"limit\n"
">>> i = int('2' * 4300)\n"
">>> len(str(i))\n"
"4300\n"
">>> i_squared = i*i\n"
">>> len(str(i_squared))\n"
"Traceback (most recent call last):\n"
"...\n"
"ValueError: Exceeds the limit (4300 digits) for integer string conversion; "
"use sys.set_int_max_str_digits() to increase the limit\n"
">>> len(hex(i_squared))\n"
"7144\n"
">>> assert int(hex(i_squared), base=16) == i*i  # Hexadecimal is unlimited."

#: library/stdtypes.rst:5915
msgid ""
"The default limit is 4300 digits as provided in :data:`sys.int_info."
"default_max_str_digits <sys.int_info>`. The lowest limit that can be "
"configured is 640 digits as provided in :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."
msgstr ""
"Το προεπιλεγμένο όριο είναι 4300 ψηφία όπως προβλέπεται στο :data:`sys."
"int_info.default_max_str_digits <sys.int_info>`. Το κατώτατο όριο που μπορεί "
"να διαμορφωθεί είναι 640 ψηφία όπως προβλέπεται στο :data:`sys.int_info."
"str_digits_check_threshold <sys.int_info>`."

#: library/stdtypes.rst:5920
msgid "Verification:"
msgstr "Επαλήθευση:"

#: library/stdtypes.rst:5922
msgid ""
">>> import sys\n"
">>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info\n"
">>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info\n"
">>> msg = int('578966293710682886880994035146873798396722250538762761564'\n"
"...           '9252925514383915483333812743580549779436104706260696366600'\n"
"...           '571186405732').to_bytes(53, 'big')\n"
"..."
msgstr ""
">>> import sys\n"
">>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info\n"
">>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info\n"
">>> msg = int('578966293710682886880994035146873798396722250538762761564'\n"
"...           '9252925514383915483333812743580549779436104706260696366600'\n"
"...           '571186405732').to_bytes(53, 'big')\n"
"..."

#: library/stdtypes.rst:5935
msgid "Affected APIs"
msgstr "Επηρεασμένα APIs"

#: library/stdtypes.rst:5937
msgid ""
"The limitation only applies to potentially slow conversions between :class:"
"`int` and :class:`str` or :class:`bytes`:"
msgstr ""
"Ο περιορισμός ισχύει μόνο για δυνητικά αργές μετατροπές μεταξύ :class:`int` "
"και :class:`str` ή :class:`bytes`:"

#: library/stdtypes.rst:5940
msgid "``int(string)`` with default base 10."
msgstr "``int(string)`` με default βάση το 10."

#: library/stdtypes.rst:5941
msgid "``int(string, base)`` for all bases that are not a power of 2."
msgstr "``int(string, base)`` για όλες τις βάσεις που δεν είναι δύναμη του 2."

#: library/stdtypes.rst:5942
msgid "``str(integer)``."
msgstr "``str(integer)``."

#: library/stdtypes.rst:5943
msgid "``repr(integer)``."
msgstr "``repr(integer)``."

#: library/stdtypes.rst:5944
msgid ""
"any other string conversion to base 10, for example ``f\"{integer}\"``, "
"``\"{}\".format(integer)``, or ``b\"%d\" % integer``."
msgstr ""
"οποιαδήποτε άλλη μετατροπή συμβολοσειράς στη βάση 10, για παράδειγμα "
"``f\"{integer}\"``, ``\"{}\".format(integer)``, ή ``b\"%d\" % integer``."

#: library/stdtypes.rst:5947
msgid "The limitations do not apply to functions with a linear algorithm:"
msgstr "Οι περιορισμοί δεν ισχύουν για συναρτήσεις με γραμμικό αλγόριθμο:"

#: library/stdtypes.rst:5949
msgid "``int(string, base)`` with base 2, 4, 8, 16, or 32."
msgstr "``int(string, base)`` με βάση 2, 4, 8, 16, ή 32."

#: library/stdtypes.rst:5950
msgid ":func:`int.from_bytes` and :func:`int.to_bytes`."
msgstr ":func:`int.from_bytes` και :func:`int.to_bytes`."

#: library/stdtypes.rst:5951
msgid ":func:`hex`, :func:`oct`, :func:`bin`."
msgstr ":func:`hex`, :func:`oct`, :func:`bin`."

#: library/stdtypes.rst:5952
msgid ":ref:`formatspec` for hex, octal, and binary numbers."
msgstr ""
":ref:`formatspec` για δεκαεξαδικούς, οκταδικούς και δυαδικούς αριθμούς."

#: library/stdtypes.rst:5953
msgid ":class:`str` to :class:`float`."
msgstr ":class:`str` σε :class:`float`."

#: library/stdtypes.rst:5954
msgid ":class:`str` to :class:`decimal.Decimal`."
msgstr ":class:`str` σε :class:`decimal.Decimal`."

#: library/stdtypes.rst:5957
msgid "Configuring the limit"
msgstr "Διαμόρφωση ορίου"

#: library/stdtypes.rst:5959
msgid ""
"Before Python starts up you can use an environment variable or an "
"interpreter command line flag to configure the limit:"
msgstr ""
"Πριν από την εκκίνηση της Python, μπορείτε να χρησιμοποιήσετε μια μεταβλητή "
"περιβάλλοντος ή ένα δείκτη γραμμής εντολών διερμηνέα για να διαμορφώσετε το "
"όριο:"

#: library/stdtypes.rst:5962
msgid ""
":envvar:`PYTHONINTMAXSTRDIGITS`, e.g. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"to set the limit to 640 or ``PYTHONINTMAXSTRDIGITS=0 python3`` to disable "
"the limitation."
msgstr ""
":envvar:`PYTHONINTMAXSTRDIGITS`, π.χ. ``PYTHONINTMAXSTRDIGITS=640 python3`` "
"για να ορίσετε το όριο σε 640 ή ``PYTHONINTMAXSTRDIGITS=0 python3`` για να "
"απενεργοποιήσετε τον περιορισμό."

#: library/stdtypes.rst:5965
msgid ""
":option:`-X int_max_str_digits <-X>`, e.g. ``python3 -X "
"int_max_str_digits=640``"
msgstr ""
":option:`-X int_max_str_digits <-X>`, π.χ. ``python3 -X "
"int_max_str_digits=640``"

#: library/stdtypes.rst:5967
msgid ""
":data:`sys.flags.int_max_str_digits` contains the value of :envvar:"
"`PYTHONINTMAXSTRDIGITS` or :option:`-X int_max_str_digits <-X>`. If both the "
"env var and the ``-X`` option are set, the ``-X`` option takes precedence. A "
"value of *-1* indicates that both were unset, thus a value of :data:`sys."
"int_info.default_max_str_digits` was used during initialization."
msgstr ""
"Το :data:`sys.flags.int_max_str_digits` περιέχει την τιμή :envvar:"
"`PYTHONINTMAXSTRDIGITS` ή :option:`-X int_max_str_digits <-X>`. Εάν και η "
"επιλογή env var και η επιλογή  ``-X`` είναι καθορισμένη, η επιλογή ``-X`` "
"έχει προτεραιότητα. Μια τιμή *-1* υποδεικνύει ότι και τα δύο δεν ορίστηκαν, "
"επομένως χρησιμοποιήθηκε μια τιμή :data:`sys.int_info."
"default_max_str_digits` κατά την προετοιμασία."

#: library/stdtypes.rst:5973
msgid ""
"From code, you can inspect the current limit and set a new one using these :"
"mod:`sys` APIs:"
msgstr ""
"Από τον κώδικα, μπορείτε να επιθεωρήσετε το τρέχον όριο και να ορίσετε ένα "
"νέο χρησιμοποιώντας αυτά τα :mod:`sys` APIs:"

#: library/stdtypes.rst:5976
msgid ""
":func:`sys.get_int_max_str_digits` and :func:`sys.set_int_max_str_digits` "
"are a getter and setter for the interpreter-wide limit. Subinterpreters have "
"their own limit."
msgstr ""
"Οι :func:`sys.get_int_max_str_digits` και :func:`sys.set_int_max_str_digits` "
"είναι ένας getter και setter για το όριο σε όλο τον διερμηνέα. Οι "
"δευτερεύοντες διερμηνείς έχουν το δικό τους όριο."

#: library/stdtypes.rst:5980
msgid ""
"Information about the default and minimum can be found in :data:`sys."
"int_info`:"
msgstr ""
"Πληροφορίες σχετικά με την προεπιλογή και το ελάχιστο μπορούν να βρεθούν "
"στο :data:`sys.int_info`:"

#: library/stdtypes.rst:5982
msgid ""
":data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-"
"in default limit."
msgstr ""
"Το :data:`sys.int_info.default_max_str_digits <sys.int_info>` είναι το  "
"μεταγλωττισμένο προεπιλεγμένο όριο."

#: library/stdtypes.rst:5984
msgid ""
":data:`sys.int_info.str_digits_check_threshold <sys.int_info>` is the lowest "
"accepted value for the limit (other than 0 which disables it)."
msgstr ""
"Το :data:`sys.int_info.str_digits_check_threshold <sys.int_info>` είναι η "
"χαμηλότερη αποδεκτή τιμή για το όριο (εκτός από το 0 που το απενεργοποιεί)."

#: library/stdtypes.rst:5991
msgid ""
"Setting a low limit *can* lead to problems. While rare, code exists that "
"contains integer constants in decimal in their source that exceed the "
"minimum threshold. A consequence of setting the limit is that Python source "
"code containing decimal integer literals longer than the limit will "
"encounter an error during parsing, usually at startup time or import time or "
"even at installation time - anytime an up to date ``.pyc`` does not already "
"exist for the code. A workaround for source that contains such large "
"constants is to convert them to ``0x`` hexadecimal form as it has no limit."
msgstr ""
"Ο ορισμός ενός χαμηλού ορίου *μπορεί* να οδηγήσει σε προβλήματα. Αν και "
"σπάνιος, υπάρχει κώδικας που περιέχει ακέραιες σταθερές σε δεκαδικό αριθμό "
"στην πηγή τους που υπερβαίνουν το ελάχιστο όριο. Συνέπεια της ρύθμισης του "
"ορίου είναι ότι ο πηγαίος κώδικας Python που περιέχει δεκαδικούς ακέραιους "
"αριθμούς μεγαλύτερους από το όριο θα αντιμετωπίσει σφάλμα κατά την ανάλυση, "
"συνήθως κατά την εκκίνηση ή την ώρα της εισαγωγής ή ακόμα και κατά την "
"εγκατάσταση - ανά πάσα στιγμή είναι ενημερωμένο ``.pyc`` δεν υπάρχει ήδη για "
"τον κώδικα. Μια λύση για τον πηγαίο που περιέχει τόσο μεγάλες σταθερές είναι "
"να τις μετατρέψετε σε δεκαεξαδική μορφή ``0x`` καθώς δεν έχει όριο."

#: library/stdtypes.rst:6000
msgid ""
"Test your application thoroughly if you use a low limit. Ensure your tests "
"run with the limit set early via the environment or flag so that it applies "
"during startup and even during any installation step that may invoke Python "
"to precompile ``.py`` sources to ``.pyc`` files."
msgstr ""
"Δοκιμάστε σχολαστικά την εφαρμογή σας εάν χρησιμοποιείτε χαμηλό όριο. "
"Βεβαιωθείτε ότι οι δοκιμές σας εκτελούνται με το όριο που έχει οριστεί νωρίς "
"μέσω του περιβάλλοντος ή του δείκτη, ώστε να ισχύει κατά την εκκίνηση και "
"ακόμη και κατά τη διάρκεια οποιουδήποτε βήματος εγκατάστασης που μπορεί να "
"καλέσει την Python για να μεταγλωττίσει εκ των προτέρων το ``.py`` πηγαίο σε "
"αρχεία ``.pyc``."

#: library/stdtypes.rst:6006
msgid "Recommended configuration"
msgstr "Προτεινόμενη διαμόρφωση"

#: library/stdtypes.rst:6008
msgid ""
"The default :data:`sys.int_info.default_max_str_digits` is expected to be "
"reasonable for most applications. If your application requires a different "
"limit, set it from your main entry point using Python version agnostic code "
"as these APIs were added in security patch releases in versions before 3.12."
msgstr ""
"Το προεπιλεγμένο :data:`sys.int_info.default_max_str_digits` αναμένεται να "
"είναι λογικό για τις περισσότερες εφαρμογές. Εάν η εφαρμογή σας απαιτεί "
"διαφορετικό όριο, ορίστε το από το κύριο σημείο εισόδου σας χρησιμοποιώντας "
"τον συμβατό με τον κώδικα της έκδοσης Python, καθώς αυτά τα API προστέθηκαν "
"στην ενημερωμένη έκδοση κώδικα ασφαλείας σε εκδόσεις πριν από την 3.12."

#: library/stdtypes.rst:6013
msgid "Example::"
msgstr "Παράδειγμα::"

#: library/stdtypes.rst:6015
msgid ""
">>> import sys\n"
">>> if hasattr(sys, \"set_int_max_str_digits\"):\n"
"...     upper_bound = 68000\n"
"...     lower_bound = 4004\n"
"...     current_limit = sys.get_int_max_str_digits()\n"
"...     if current_limit == 0 or current_limit > upper_bound:\n"
"...         sys.set_int_max_str_digits(upper_bound)\n"
"...     elif current_limit < lower_bound:\n"
"...         sys.set_int_max_str_digits(lower_bound)"
msgstr ""
">>> import sys\n"
">>> if hasattr(sys, \"set_int_max_str_digits\"):\n"
"...     upper_bound = 68000\n"
"...     lower_bound = 4004\n"
"...     current_limit = sys.get_int_max_str_digits()\n"
"...     if current_limit == 0 or current_limit > upper_bound:\n"
"...         sys.set_int_max_str_digits(upper_bound)\n"
"...     elif current_limit < lower_bound:\n"
"...         sys.set_int_max_str_digits(lower_bound)"

#: library/stdtypes.rst:6025
msgid "If you need to disable it entirely, set it to ``0``."
msgstr "Εάν πρέπει να το απενεργοποιήσετε εντελώς, ορίστε το σε ``0``."

#: library/stdtypes.rst:6029
msgid "Footnotes"
msgstr "Υποσημειώσεις"

#: library/stdtypes.rst:6030
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Πρόσθετε πληροφορίες σχετικά με αυτές τις ειδικές μεθόδους μπορείτε να "
"βρείτε στο Εγχειρίδιο Αναφοράς Python (:ref:`customization`)."

#: library/stdtypes.rst:6033
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""
"Σαν συνέπεια, η λίστα ``[1, 2]`` θεωρείται ίση με ``[1.0, 2.0]``, και ομοίως "
"για πλειάδες (tuples)."

#: library/stdtypes.rst:6036
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"Πρέπει να έχουν, αφού ο parser δεν μπορεί να ξεχωρίσει τον τύπο των τελεστών."

#: library/stdtypes.rst:6038
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Οι χαρακτήρες με πεζά είναι αυτοί με την ιδιότητα γενικής κατηγορίας να "
"είναι ένας από τους \"Lu\" (Γράμμα, κεφαλαίο), \"Ll\" (Γράμμα, πεζά), ή "
"\"Lt\" (Γράμμα, κεφαλαία)."

#: library/stdtypes.rst:6041
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"Για να μορφοποιήσετε μόνο μια πλειάδα (tuple) θα πρέπει επομένως να παρέχετε "
"μια πλειάδα singleton της οποίας το μόνο στοιχείο είναι η πλειάδα που "
"πρόκειται να μορφοποιηθεί."

#: library/stdtypes.rst:13
msgid "built-in"
msgstr "ενσωματωμένοι (built-in) τύποι"

#: library/stdtypes.rst:322 library/stdtypes.rst:992 library/stdtypes.rst:1181
#: library/stdtypes.rst:4775 library/stdtypes.rst:5766
msgid "types"
msgstr "τύποι"

#: library/stdtypes.rst:1196 library/stdtypes.rst:4775
msgid "statement"
msgstr "statement"

#: library/stdtypes.rst:34
msgid "if"
msgstr "if"

#: library/stdtypes.rst:34
msgid "while"
msgstr "while"

#: library/stdtypes.rst:34
msgid "truth"
msgstr "αληθές"

#: library/stdtypes.rst:34
msgid "value"
msgstr "τιμή"

#: library/stdtypes.rst:81 library/stdtypes.rst:859
msgid "Boolean"
msgstr "Boolean"

#: library/stdtypes.rst:81 library/stdtypes.rst:399
msgid "operations"
msgstr "λειτουργίες"

#: library/stdtypes.rst:34
msgid "false"
msgstr "false"

#: library/stdtypes.rst:44
msgid "true"
msgstr "true"

#: library/stdtypes.rst:52
msgid "None (Built-in object)"
msgstr "None (Ενσωματωμένο (Built-in) αντικείμενο)"

#: library/stdtypes.rst:52
msgid "False (Built-in object)"
msgstr "False (Ενσωματωμένο (Built-in) αντικείμενο)"

#: library/stdtypes.rst:98 library/stdtypes.rst:195 library/stdtypes.rst:399
#: library/stdtypes.rst:992
msgid "operator"
msgstr "τελεστής"

#: library/stdtypes.rst:98
msgid "or"
msgstr "or"

#: library/stdtypes.rst:98
msgid "and"
msgstr "and"

#: library/stdtypes.rst:859
msgid "False"
msgstr "False"

#: library/stdtypes.rst:859
msgid "True"
msgstr "True"

#: library/stdtypes.rst:98
msgid "not"
msgstr "not"

#: library/stdtypes.rst:123
msgid "chaining"
msgstr "αλυσίδα"

#: library/stdtypes.rst:123
msgid "comparisons"
msgstr "συγκρίσεις"

#: library/stdtypes.rst:123
msgid "comparison"
msgstr "σύγκριση"

#: library/stdtypes.rst:123
msgid "=="
msgstr "=="

#: library/stdtypes.rst:123
msgid "< (less)"
msgstr "< (μικρότερο)"

#: library/stdtypes.rst:123
msgid "<="
msgstr "<="

#: library/stdtypes.rst:123
msgid "> (greater)"
msgstr "> (μεγαλύτερο)"

#: library/stdtypes.rst:123
msgid ">="
msgstr ">="

#: library/stdtypes.rst:123
msgid "!="
msgstr "!="

#: library/stdtypes.rst:123
msgid "is"
msgstr "is"

#: library/stdtypes.rst:123
msgid "is not"
msgstr "is not"

#: library/stdtypes.rst:208 library/stdtypes.rst:1159 library/stdtypes.rst:1302
#: library/stdtypes.rst:1425 library/stdtypes.rst:1676
#: library/stdtypes.rst:2827 library/stdtypes.rst:4573
#: library/stdtypes.rst:5255 library/stdtypes.rst:5686
#: library/stdtypes.rst:5730
msgid "object"
msgstr "αντικείμενο"

#: library/stdtypes.rst:208 library/stdtypes.rst:322 library/stdtypes.rst:341
msgid "numeric"
msgstr "αριθμητικό"

#: library/stdtypes.rst:163
msgid "objects"
msgstr "αντικείμενα"

#: library/stdtypes.rst:163
msgid "comparing"
msgstr "συγκρίνοντας"

#: library/stdtypes.rst:173
msgid "__eq__() (instance method)"
msgstr "__eq__() (μέθοδος στιγμιοτύπου)"

#: library/stdtypes.rst:173
msgid "__ne__() (instance method)"
msgstr "__ne__() (μέθοδος στιγμιοτύπου)"

#: library/stdtypes.rst:173
msgid "__lt__() (instance method)"
msgstr "__lt__() (μέθοδος στιγμιοτύπου)"

#: library/stdtypes.rst:173
msgid "__le__() (instance method)"
msgstr "__le__() (μέθοδος στιγμιοτύπου)"

#: library/stdtypes.rst:173
msgid "__gt__() (instance method)"
msgstr "__gt__() (μέθοδος στιγμιοτύπου)"

#: library/stdtypes.rst:173
msgid "__ge__() (instance method)"
msgstr "__ge__() (μέθοδος στιγμιοτύπου)"

#: library/stdtypes.rst:992
msgid "in"
msgstr "in"

#: library/stdtypes.rst:992
msgid "not in"
msgstr "not in"

#: library/stdtypes.rst:229 library/stdtypes.rst:399
msgid "integer"
msgstr "ακέραιος"

#: library/stdtypes.rst:229
msgid "floating-point"
msgstr "κινητής υποδιαστολής"

#: library/stdtypes.rst:229
msgid "complex number"
msgstr "μιγαδικός αριθμός"

#: library/stdtypes.rst:208
msgid "C"
msgstr "C"

#: library/stdtypes.rst:208
msgid "language"
msgstr "γλώσσα"

#: library/stdtypes.rst:229
msgid "literals"
msgstr "literals"

#: library/stdtypes.rst:229
msgid "hexadecimal"
msgstr "δεκαεξαδικό"

#: library/stdtypes.rst:229
msgid "octal"
msgstr "οκταδικό"

#: library/stdtypes.rst:229
msgid "binary"
msgstr "δυαδικό"

#: library/stdtypes.rst:249
msgid "arithmetic"
msgstr "αριθμητικό"

#: library/stdtypes.rst:992 library/stdtypes.rst:4775 library/stdtypes.rst:5751
#: library/stdtypes.rst:5766
msgid "built-in function"
msgstr "ενσωματωμένες (built-in) συναρτήσεις"

#: library/stdtypes.rst:249
msgid "int"
msgstr "int"

#: library/stdtypes.rst:249
msgid "float"
msgstr "float"

#: library/stdtypes.rst:249
msgid "complex"
msgstr "complex"

#: library/stdtypes.rst:2684 library/stdtypes.rst:3943
msgid "+ (plus)"
msgstr "+ (συν)"

#: library/stdtypes.rst:249
msgid "unary operator"
msgstr "τελεστής unary"

#: library/stdtypes.rst:249
msgid "binary operator"
msgstr "δυαδικός τελεστής"

#: library/stdtypes.rst:2684 library/stdtypes.rst:3943
msgid "- (minus)"
msgstr "- (πλην)"

#: library/stdtypes.rst:2641 library/stdtypes.rst:3900
msgid "* (asterisk)"
msgstr "* (αστερίσκος)"

#: library/stdtypes.rst:249
msgid "/ (slash)"
msgstr "/ (κάθετος)"

#: library/stdtypes.rst:249
msgid "//"
msgstr "//"

#: library/stdtypes.rst:2605 library/stdtypes.rst:3868
msgid "% (percent)"
msgstr "% (τοις εκατό)"

#: library/stdtypes.rst:249
msgid "**"
msgstr "**"

#: library/stdtypes.rst:399 library/stdtypes.rst:1196 library/stdtypes.rst:4775
msgid "operations on"
msgstr "λειτουργίες on"

#: library/stdtypes.rst:322
msgid "conjugate() (complex number method)"
msgstr "conjugate() (μέθοδος μιγαδικών αριθμών)"

#: library/stdtypes.rst:1742 library/stdtypes.rst:5766
msgid "module"
msgstr "module"

#: library/stdtypes.rst:341
msgid "math"
msgstr "math"

#: library/stdtypes.rst:341
msgid "floor() (in module math)"
msgstr "floor() (στο module math)"

#: library/stdtypes.rst:341
msgid "ceil() (in module math)"
msgstr "ceil() (στο module math)"

#: library/stdtypes.rst:341
msgid "trunc() (in module math)"
msgstr "trunc() (στο module math)"

#: library/stdtypes.rst:341
msgid "conversions"
msgstr "μετατροπές"

#: library/stdtypes.rst:399
msgid "bitwise"
msgstr "δυαδικά"

#: library/stdtypes.rst:399
msgid "shifting"
msgstr "μετατόπιση (shifting)"

#: library/stdtypes.rst:399
msgid "masking"
msgstr "συγκάλυψη (masking)"

#: library/stdtypes.rst:399
msgid "| (vertical bar)"
msgstr "| (κάθετη μπάρα)"

#: library/stdtypes.rst:399
msgid "^ (caret)"
msgstr "^ (caret)"

#: library/stdtypes.rst:399
msgid "& (ampersand)"
msgstr "& (ampersand)"

#: library/stdtypes.rst:399
msgid "<<"
msgstr "<<"

#: library/stdtypes.rst:399
msgid ">>"
msgstr ">>"

#: library/stdtypes.rst:399
msgid "~ (tilde)"
msgstr "~ (περισπωμένη)"

#: library/stdtypes.rst:859
msgid "values"
msgstr "τιμές"

#: library/stdtypes.rst:889
msgid "iterator protocol"
msgstr "πρωτόκολλο iterator"

#: library/stdtypes.rst:5170
msgid "protocol"
msgstr "πρωτόκολλο"

#: library/stdtypes.rst:889
msgid "iterator"
msgstr "iterator"

#: library/stdtypes.rst:976 library/stdtypes.rst:1159 library/stdtypes.rst:1196
msgid "sequence"
msgstr "sequence"

#: library/stdtypes.rst:889
msgid "iteration"
msgstr "iteration"

#: library/stdtypes.rst:889
msgid "container"
msgstr "container"

#: library/stdtypes.rst:889
msgid "iteration over"
msgstr "iteration over"

#: library/stdtypes.rst:4775
msgid "len"
msgstr "len"

#: library/stdtypes.rst:992
msgid "min"
msgstr "min"

#: library/stdtypes.rst:992
msgid "max"
msgstr "max"

#: library/stdtypes.rst:992
msgid "concatenation"
msgstr "concatenation"

#: library/stdtypes.rst:992
msgid "operation"
msgstr "λειτουργία"

#: library/stdtypes.rst:992
msgid "repetition"
msgstr "επανάληψη"

#: library/stdtypes.rst:1196
msgid "subscript"
msgstr "subscript"

#: library/stdtypes.rst:1196
msgid "slice"
msgstr "slice"

#: library/stdtypes.rst:992
msgid "count() (sequence method)"
msgstr "count() (μέθοδος ακολουθίας)"

#: library/stdtypes.rst:992
msgid "index() (sequence method)"
msgstr "index() (μέθοδος ακολουθίας)"

#: library/stdtypes.rst:1048
msgid "loop"
msgstr "loop"

#: library/stdtypes.rst:1048
msgid "over mutable sequence"
msgstr "πάνω από μεταβλητή ακολουθίας"

#: library/stdtypes.rst:1048
msgid "mutable sequence"
msgstr "μεταβλητή ακολουθίας"

#: library/stdtypes.rst:1048
msgid "loop over"
msgstr "loop over"

#: library/stdtypes.rst:1159
msgid "immutable"
msgstr "αμετάβλητο"

#: library/stdtypes.rst:1381
msgid "tuple"
msgstr "πλειάδα (tuple)"

#: library/stdtypes.rst:1159
msgid "hash"
msgstr "hash"

#: library/stdtypes.rst:1181
msgid "mutable"
msgstr "ευμετάβλητο"

#: library/stdtypes.rst:1196 library/stdtypes.rst:1302
msgid "list"
msgstr "λίστα"

#: library/stdtypes.rst:2808 library/stdtypes.rst:3046
#: library/stdtypes.rst:3868
msgid "bytearray"
msgstr "bytearray"

#: library/stdtypes.rst:4775 library/stdtypes.rst:5766
msgid "type"
msgstr "τύπος"

#: library/stdtypes.rst:1196
msgid "assignment"
msgstr "εκχώρηση"

#: library/stdtypes.rst:4775
msgid "del"
msgstr "del"

#: library/stdtypes.rst:1196
msgid "append() (sequence method)"
msgstr "append() (μέθοδος ακολουθίας)"

#: library/stdtypes.rst:1196
msgid "clear() (sequence method)"
msgstr "clear() (μέθοδος ακολουθίας)"

#: library/stdtypes.rst:1196
msgid "copy() (sequence method)"
msgstr "copy() (μέθοδος ακολουθίας)"

#: library/stdtypes.rst:1196
msgid "extend() (sequence method)"
msgstr "extend() (μέθοδος ακολουθίας)"

#: library/stdtypes.rst:1196
msgid "insert() (sequence method)"
msgstr "insert() (μέθοδος ακολουθίας)"

#: library/stdtypes.rst:1196
msgid "pop() (sequence method)"
msgstr "pop() (μέθοδος ακολουθίας)"

#: library/stdtypes.rst:1196
msgid "remove() (sequence method)"
msgstr "remove() (μέθοδος ακολουθίας)"

#: library/stdtypes.rst:1196
msgid "reverse() (sequence method)"
msgstr "reverse() (μέθοδος ακολουθίας)"

#: library/stdtypes.rst:1425
msgid "range"
msgstr "range"

#: library/stdtypes.rst:1689 library/stdtypes.rst:2459
#: library/stdtypes.rst:2605
msgid "string"
msgstr "string"

#: library/stdtypes.rst:1546
msgid "text sequence type"
msgstr "τύπος ακολουθίας κειμένου"

#: library/stdtypes.rst:1689 library/stdtypes.rst:1707
msgid "str (built-in class)"
msgstr "str (ενσωματωμένη (built-in) κλάση)"

#: library/stdtypes.rst:1546
msgid "(see also string)"
msgstr "(βλ. επίσης string)"

#: library/stdtypes.rst:1676
msgid "io.StringIO"
msgstr "io.StringIO"

#: library/stdtypes.rst:2800
msgid "buffer protocol"
msgstr "πρωτόκολλο buffer"

#: library/stdtypes.rst:2808 library/stdtypes.rst:3046
#: library/stdtypes.rst:3868
msgid "bytes"
msgstr "bytes"

#: library/stdtypes.rst:3046
msgid "methods"
msgstr "μέθοδοι"

#: library/stdtypes.rst:1742
msgid "re"
msgstr "re"

#: library/stdtypes.rst:3722
msgid "universal newlines"
msgstr "καθολικές νέες γραμμές"

#: library/stdtypes.rst:2273
msgid "str.splitlines method"
msgstr "μέθοδος str.splitlines"

#: library/stdtypes.rst:2459
msgid "! formatted string literal"
msgstr "! μορφοποιημένη συμβολοσειρά κυριολεκτικής μορφής"

#: library/stdtypes.rst:2459
msgid "formatted string literals"
msgstr "μορφοποιημένες συμβολοσειρές κυριολεξίας"

#: library/stdtypes.rst:2459
msgid "! f-string"
msgstr "! f-string"

#: library/stdtypes.rst:2459
msgid "f-strings"
msgstr "string"

#: library/stdtypes.rst:2459
msgid "fstring"
msgstr "fstring"

#: library/stdtypes.rst:2459
msgid "interpolated string literal"
msgstr "συμβολοσειρά κυριολεξίας με παρεμβολή"

#: library/stdtypes.rst:2459
msgid "formatted literal"
msgstr "μορφοποιημένη κυριολεξία"

#: library/stdtypes.rst:2459
msgid "interpolated literal"
msgstr "κυριολεκτικό με παρεμβολή"

#: library/stdtypes.rst:2459
msgid "{} (curly brackets)"
msgstr "{} (αγκύλες)"

#: library/stdtypes.rst:2459
msgid "in formatted string literal"
msgstr "μέσα σε μορφοποιημένη συμβολοσειρά"

#: library/stdtypes.rst:2459
msgid "! (exclamation mark)"
msgstr "! (Θαυμαστικό)"

#: library/stdtypes.rst:2459
msgid ": (colon)"
msgstr ": (άνω κάτω τελεία)"

#: library/stdtypes.rst:2459
msgid "= (equals)"
msgstr "= (ίσο)"

#: library/stdtypes.rst:2459
msgid "for help in debugging using string literals"
msgstr "για βοήθεια στην αποσφαλμάτωση μέσω κυριολεκτικών συμβολοσειρών"

#: library/stdtypes.rst:2605
msgid "formatting, string (%)"
msgstr "μορφοποίηση, string (%)"

#: library/stdtypes.rst:2605
msgid "interpolation, string (%)"
msgstr "παρεμβολή, string (%)"

#: library/stdtypes.rst:2605
msgid "formatting, printf"
msgstr "μορφοποίηση, printf"

#: library/stdtypes.rst:2605
msgid "interpolation, printf"
msgstr "παρεμβολή, printf"

#: library/stdtypes.rst:3868
msgid "printf-style formatting"
msgstr "μορφοποίηση σε στυλ printf"

#: library/stdtypes.rst:3868
msgid "sprintf-style formatting"
msgstr "μορφοποίηση σε στυλ sprintf"

#: library/stdtypes.rst:3900
msgid "() (parentheses)"
msgstr "() (παρενθέσεις)"

#: library/stdtypes.rst:2684 library/stdtypes.rst:3943
msgid "in printf-style formatting"
msgstr "σε μορφοποίηση σε στυλ printf"

#: library/stdtypes.rst:3900
msgid ". (dot)"
msgstr ". (τελεία)"

#: library/stdtypes.rst:3943
msgid "# (hash)"
msgstr "# (δίεση)"

#: library/stdtypes.rst:3943
msgid "space"
msgstr "διάστημα"

#: library/stdtypes.rst:2800
msgid "binary sequence types"
msgstr "τύπος δυαδικών ακολουθιών"

#: library/stdtypes.rst:2808
msgid "memoryview"
msgstr "memoryview"

#: library/stdtypes.rst:2808
msgid "array"
msgstr "πίνακας"

#: library/stdtypes.rst:3722
msgid "bytes.splitlines method"
msgstr "bytes.splitlines μέθοδος"

#: library/stdtypes.rst:3722
msgid "bytearray.splitlines method"
msgstr "bytearray.splitlines μέθοδος"

#: library/stdtypes.rst:3868
msgid "formatting"
msgstr "μορφοποίηση"

#: library/stdtypes.rst:3868
msgid "bytes (%)"
msgstr "bytes (%)"

#: library/stdtypes.rst:3868
msgid "bytearray (%)"
msgstr "bytearray (%)"

#: library/stdtypes.rst:3868
msgid "interpolation"
msgstr "μεταβολή"

#: library/stdtypes.rst:4573
msgid "set"
msgstr "set"

#: library/stdtypes.rst:4775
msgid "mapping"
msgstr "αντιστοίχιση"

#: library/stdtypes.rst:4775
msgid "dictionary"
msgstr "λεξικό"

#: library/stdtypes.rst:4885
msgid "__missing__()"
msgstr "__missing__()"

#: library/stdtypes.rst:5170
msgid "context manager"
msgstr "διαχειριστής περιεχομένου"

#: library/stdtypes.rst:5170
msgid "context management protocol"
msgstr "πρωτόκολλο διαχειριστή περιεχομένου"

#: library/stdtypes.rst:5170
msgid "context management"
msgstr "διαχείριση περιεχομένου"

#: library/stdtypes.rst:5243
msgid "annotation"
msgstr "annotation"

#: library/stdtypes.rst:5243
msgid "type annotation; type hint"
msgstr "type annotation; type hint"

#: library/stdtypes.rst:5255
msgid "GenericAlias"
msgstr "GenericAlias"

#: library/stdtypes.rst:5255
msgid "Generic"
msgstr "Generic"

#: library/stdtypes.rst:5255
msgid "Alias"
msgstr "Alias"

#: library/stdtypes.rst:5511
msgid "Union"
msgstr "Ένωση"

#: library/stdtypes.rst:5511
msgid "union"
msgstr "ένωση"

#: library/stdtypes.rst:5686
msgid "method"
msgstr "μέθοδος"

#: library/stdtypes.rst:5730
msgid "code"
msgstr "κώδικας"

#: library/stdtypes.rst:5730
msgid "code object"
msgstr "αντικείμενο κώδικα"

#: library/stdtypes.rst:5737
msgid "compile"
msgstr "compile"

#: library/stdtypes.rst:5737
msgid "__code__ (function object attribute)"
msgstr "__code__ (χαρακτηριστικό αντικείμενου συνάρτησης)"

#: library/stdtypes.rst:5751
msgid "exec"
msgstr "exec"

#: library/stdtypes.rst:5751
msgid "eval"
msgstr "eval"

#: library/stdtypes.rst:5790
msgid "..."
msgstr "..."

#: library/stdtypes.rst:5790
msgid "ellipsis literal"
msgstr "ellipsis literal"

#~ msgid ""
#~ "To illustrate, the following examples all return a dictionary equal to "
#~ "``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
#~ msgstr ""
#~ "Για επεξήγηση, τα ακόλουθα παραδείγματα επιστρέφουν όλα ένα λεξικό ίσο με "
#~ "``{\"one\": 1, \"two\": 2, \"three\": 3}``::"

#~ msgid ":class:`collections.abc.ByteString`"
#~ msgstr ":class:`collections.abc.ByteString`"

#~ msgid ""
#~ "Return ``True`` if all characters in the string are printable or the "
#~ "string is empty, ``False`` otherwise.  Nonprintable characters are those "
#~ "characters defined in the Unicode character database as \"Other\" or "
#~ "\"Separator\", excepting the ASCII space (0x20) which is considered "
#~ "printable.  (Note that printable characters in this context are those "
#~ "which should not be escaped when :func:`repr` is invoked on a string.  It "
#~ "has no bearing on the handling of strings written to :data:`sys.stdout` "
#~ "or :data:`sys.stderr`.)"
#~ msgstr ""
#~ "Επιστρέφει ``True`` αν όλοι οι χαρακτήρες της συμβολοσειράς (string) "
#~ "είναι εκτυπώσιμοι ή η συμβολοσειρά είναι κενή, διαφορετικά ``False``.  Μη "
#~ "εκτυπώσιμοι χαρακτήρες είναι οι χαρακτήρες που ορίζονται στη βάση "
#~ "δεδομένων χαρακτήρων Unicode ως \"Other\" ή \"Separator\", εκτός από το "
#~ "κενό ASCII (0x20) που θεωρείται εκτυπώσιμος.  (Σημειώστε ότι εκτυπώσιμοι "
#~ "χαρακτήρες σε αυτό το πλαίσιο είναι εκείνοι που δεν πρέπει να "
#~ "αποφεύγονται όταν η :func:`repr` καλείται σε ένα αλφαριθμητικό.  Δεν έχει "
#~ "καμία σχέση με τον χειρισμό των συμβολοσειρών που γράφονται στα :data:"
#~ "`sys.stdout` ή :data:`sys.stderr`)."

#~ msgid ""
#~ "A dictionary or other mapping object used to store an object's (writable) "
#~ "attributes."
#~ msgstr ""
#~ "Ένα λεξικό ή άλλο αντικείμενο αντιστοίχισης που χρησιμοποιείται για την "
#~ "αποθήκευση των (εγγράψιμων) χαρακτηριστικών ενός αντικειμένου."

#~ msgid "The class to which a class instance belongs."
#~ msgstr "Η κλάση στην οποία ανήκει ένα στιγμιότυπο κλάσης."

#~ msgid "The tuple of base classes of a class object."
#~ msgstr "Η πλειάδα (tuple) των βασικών κλάσεων ενός αντικειμένου κλάσης."

#~ msgid ""
#~ "This attribute is a tuple of classes that are considered when looking for "
#~ "base classes during method resolution."
#~ msgstr ""
#~ "Αυτό το χαρακτηριστικό είναι μια πλειάδα κλάσεων που λαμβάνονται υπόψη "
#~ "κατά την αναζήτηση βασικών κλάσεων κατά την ανάλυση μεθόδου."

#~ msgid ""
#~ "This method can be overridden by a metaclass to customize the method "
#~ "resolution order for its instances.  It is called at class instantiation, "
#~ "and its result is stored in :attr:`~class.__mro__`."
#~ msgstr ""
#~ "Αυτή η μέθοδος μπορεί να παρακαμφθεί από μια μετακλάση για να προσαρμόσει "
#~ "τη σειρά ανάλυσης της μεθόδου για τα στιγμιότυπα της.  Καλείται στην "
#~ "εγκατάσταση κλάσης, και το αποτέλεσμα της αποθηκεύεται σε :attr:`~class."
#~ "__mro__`."

#~ msgid ""
#~ "Each class keeps a list of weak references to its immediate subclasses.  "
#~ "This method returns a list of all those references still alive.  The list "
#~ "is in definition order.  Example::"
#~ msgstr ""
#~ "Κάθε κλάση διατηρεί μια λίστα αδύναμων αναφορών στις άμεσες υποκλάσεις "
#~ "της.  Αυτή η μέθοδος επιστρέφει μια λίστα με όλες αυτές τις αναφορές που "
#~ "είναι ακόμα ζωντανές.  Η λίστα είναι με τη σειρά ορισμού.  Παράδειγμα::"
