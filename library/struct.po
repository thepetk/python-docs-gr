# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-10 10:19+0300\n"
"PO-Revision-Date: 2025-05-10 22:42+0200\n"
"Last-Translator: Marios Giannopoulos <mariosgian_2002@yahoo.gr>\n"
"Language-Team: PyGreece <organizers@pygreece.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: library/struct.rst:2
msgid ":mod:`!struct` --- Interpret bytes as packed binary data"
msgstr ":mod:`!struct` --- Ερμηνεία bytes ως πακετοποιημένα δυαδικά δεδομένα"

#: library/struct.rst:11
msgid "**Source code:** :source:`Lib/struct.py`"
msgstr "**Πηγαίος κώδικας:** :source:`Lib/struct.py`"

#: library/struct.rst:19
msgid ""
"This module converts between Python values and C structs represented as "
"Python :class:`bytes` objects.  Compact :ref:`format strings <struct-format-"
"strings>` describe the intended conversions to/from Python values. The "
"module's functions and objects can be used for two largely distinct "
"applications, data exchange with external sources (files or network "
"connections), or data transfer between the Python application and the C "
"layer."
msgstr ""
"Αυτό το module μετατρέπει μεταξύ τιμών της Python και δομών της C που "
"αναπαρίστανται ως αντικείμενα :class:`bytes` της Python. Συμπαγείς :ref:"
"`format strings <struct-format-strings>` περιγράφουν τις προβλεπόμενες "
"μετατροπές από/προς τιμές της Python. Οι συναρτήσεις και τα αντικείμενα του "
"module μπορούν να χρησιμοποιηθούν για δύο κυρίως εφαρμογές: την ανταλλαγή "
"δεδομένων με εξωτερικές πηγές (αρχεία ή συνδέσεις δικτύου) ή τη μεταφορά "
"δεδομένων μεταξύ της εφαρμογής Python και του επιπέδου C."

#: library/struct.rst:29
msgid ""
"When no prefix character is given, native mode is the default. It packs or "
"unpacks data based on the platform and compiler on which the Python "
"interpreter was built. The result of packing a given C struct includes pad "
"bytes which maintain proper alignment for the C types involved; similarly, "
"alignment is taken into account when unpacking.  In contrast, when "
"communicating data between external sources, the programmer is responsible "
"for defining byte ordering and padding between elements. See :ref:`struct-"
"alignment` for details."
msgstr ""
"Όταν δεν δίνεται χαρακτήρας προθέματος, η προεπιλεγμένη λειτουργία είναι η "
"εγγενής (native mode). Πακετάρει ή αποσυμπιέζει δεδομένα με βάση την "
"πλατφόρμα και τον μεταγλωττιστή με τον οποίο κατασκευάστηκε ο διερμηνέας της "
"Python. Το αποτέλεσμα της συσκευασίας μιας δεδομένης δομής C περιλαμβάνει "
"συμπληρωματικά bytes (pad bytes) που διατηρούν τη σωστή στοίχιση για τους "
"εμπλεκόμενους τύπους C· παρομοίως, η στοίχιση λαμβάνεται υπόψη κατά την "
"αποσυσκευασία. Αντίθετα, κατά την επικοινωνία δεδομένων με εξωτερικές πηγές, "
"ο προγραμματιστής είναι υπεύθυνος για τον καθορισμό της σειράς byte και του "
"συμπληρώματος μεταξύ των στοιχείων. Δείτε :ref:`struct-alignment` για "
"λεπτομέρειες. "

#: library/struct.rst:39
msgid ""
"Several :mod:`struct` functions (and methods of :class:`Struct`) take a "
"*buffer* argument.  This refers to objects that implement the :ref:"
"`bufferobjects` and provide either a readable or read-writable buffer.  The "
"most common types used for that purpose are :class:`bytes` and :class:"
"`bytearray`, but many other types that can be viewed as an array of bytes "
"implement the buffer protocol, so that they can be read/filled without "
"additional copying from a :class:`bytes` object."
msgstr ""
"Αρκετές συναρτήσεις του :mod:`struct` (και μέθοδοι της κλάσης :class:"
"`Struct`) δέχονται μια παράμετρο *buffer*. Αυτή αναφέρεται σε αντικείμενα "
"που υλοποιούν τα :ref:`bufferobjects` και παρέχουν είτε ένα αναγνώσιμο είτε "
"έναν αναγνώσιμο-εγγράψιμο buffer. Οι πιο συνηθισμένοι τύποι που "
"χρησιμοποιούνται για αυτόν τον σκοπό είναι οι :class:`bytes` και :class:"
"`bytearray`, αλλά πολλοί άλλοι τύποι που μπορούν να θεωρηθούν ως πίνακες "
"bytes υλοποιούν το πρωτόκολλο buffer, επιτρέποντας την ανάγνωση/τροφοδότηση "
"χωρίς επιπλέον αντιγραφή από ένα αντικείμενο :class:`bytes`."

#: library/struct.rst:48
msgid "Functions and Exceptions"
msgstr "Συναρτήσεις και εξαιρέσεις"

#: library/struct.rst:50
msgid "The module defines the following exception and functions:"
msgstr "Το module ορίζει την ακόλουθη εξαίρεση και συναρτήσεις:"

#: library/struct.rst:55
msgid ""
"Exception raised on various occasions; argument is a string describing what "
"is wrong."
msgstr ""
"Εξαίρεση που γίνεται raise σε διάφορες περιπτώσεις· το όρισμα είναι μια "
"συμβολοσειρά που περιγράφει το σφάλμα."

#: library/struct.rst:61
msgid ""
"Return a bytes object containing the values *v1*, *v2*, ... packed according "
"to the format string *format*.  The arguments must match the values required "
"by the format exactly."
msgstr ""
"Επιστρέφει ένα αντικείμενο τύπου bytes που περιέχει τις τιμές *v1*, "
"*v2*, ... πακεταρισμένες σύμφωνα με τη συμβολοσειρά μορφοποίησης *format*. "
"Τα ορίσματα πρέπει να ταιριάζουν ακριβώς με τις απαιτούμενες τιμές της "
"μορφοποίησης."

#: library/struct.rst:68
msgid ""
"Pack the values *v1*, *v2*, ... according to the format string *format* and "
"write the packed bytes into the writable buffer *buffer* starting at "
"position *offset*.  Note that *offset* is a required argument."
msgstr ""
"Πακετάρει τις τιμές *v1*, *v2*, ... σύμφωνα με τη συμβολοσειρά μορφοποίησης "
"*format* και γράφει τα πακεταρισμένα bytes στον εγγράψιμο buffer *buffer* "
"ξεκινώντας από τη θέση *offset*. Σημειώστε ότι το *offset* είναι υποχρεωτικό "
"όρισμα."

#: library/struct.rst:75
msgid ""
"Unpack from the buffer *buffer* (presumably packed by ``pack(format, ...)``) "
"according to the format string *format*.  The result is a tuple even if it "
"contains exactly one item.  The buffer's size in bytes must match the size "
"required by the format, as reflected by :func:`calcsize`."
msgstr ""
"Αποσυμπιέζει από τον buffer *buffer* (ο οποίος υποτίθεται έχει πακεταριστεί "
"με τη μέθοδο ``pack(format, ...)``) σύμφωνα με την συμβολοσειρά μορφοποίησης "
"*format*. Το αποτέλεσμα είναι μια πλειάδα, ακόμα κι αν περιέχει μόνο ένα "
"στοιχείο. Το μέγεθος του buffer σε bytes πρέπει να ταιριάζει με το "
"απαιτούμενο μέγεθος σύμφωνα με τη μορφή, όπως καθορίζεται από τη συνάρτηση :"
"func:`calcsize`."

#: library/struct.rst:83
msgid ""
"Unpack from *buffer* starting at position *offset*, according to the format "
"string *format*.  The result is a tuple even if it contains exactly one "
"item.  The buffer's size in bytes, starting at position *offset*, must be at "
"least the size required by the format, as reflected by :func:`calcsize`."
msgstr ""
"Αποσυμπιέζει από τον *buffer* ξεκινώντας από τη θέση *offset*, σύμφωνα με τη "
"συμβολοσειρά μορφοποίησης *format*.  Το αποτέλεσμα είναι μια πλειάδα, ακόμα "
"κι αν περιέχει μόνο ένα στοιχείο. Το μέγεθος του buffer σε bytes, ξεκινώντας "
"από τη θέση *offset*, πρέπει να είναι τουλάχιστον το μέγεθος που απαιτείται "
"από τη μορφή, όπως καθορίζεται από τη συνάρτηση :func:`calcsize`."

#: library/struct.rst:91
msgid ""
"Iteratively unpack from the buffer *buffer* according to the format string "
"*format*.  This function returns an iterator which will read equally sized "
"chunks from the buffer until all its contents have been consumed.  The "
"buffer's size in bytes must be a multiple of the size required by the "
"format, as reflected by :func:`calcsize`."
msgstr ""
"Αποσυμπιέζει επαναληπτικά από τον buffer *buffer* σύμφωνα με τη συμβολοσειρά "
"μορφοποίησης *format*. Αυτή η συνάρτηση επιστρέφει έναν iterator ο οποίος θα "
"διαβάσει κομμάτια ίδιου μεγέθους από τον buffer μέχρι να καταναλωθούν όλα τα "
"περιεχόμενά του. Το μέγεθος του buffer σε bytes πρέπει να είναι πολλαπλάσιο "
"του μεγέθους που απαιτείται από τη μορφή, όπως καθορίζεται από τη συνάρτηση :"
"func:`calcsize`."

#: library/struct.rst:97
msgid "Each iteration yields a tuple as specified by the format string."
msgstr ""
"Κάθε επανάληψη επιστρέφει μια πλειάδα σύμφωνα με τη συμβολοσειρά "
"μορφοποίησης."

#: library/struct.rst:104
msgid ""
"Return the size of the struct (and hence of the bytes object produced by "
"``pack(format, ...)``) corresponding to the format string *format*."
msgstr ""
"Επιστρέφει το μέγεθος της δομής (και κατά συνέπεια του αντικειμένου bytes "
"που παράγεται από το ``pack(format, ...)``) που αντιστοιχεί στη συμβολοσειρά "
"μορφοποίησης *format*."

#: library/struct.rst:111
msgid "Format Strings"
msgstr "Συμβολοσειρές μορφοποίησης"

#: library/struct.rst:113
msgid ""
"Format strings describe the data layout when packing and unpacking data.  "
"They are built up from :ref:`format characters<format-characters>`, which "
"specify the type of data being packed/unpacked.  In addition, special "
"characters control the :ref:`byte order, size and alignment<struct-"
"alignment>`. Each format string consists of an optional prefix character "
"which describes the overall properties of the data and one or more format "
"characters which describe the actual data values and padding."
msgstr ""
"Οι συμβολοσειρές μορφοποίησης περιγράφουν τη διάταξη των δεδομένων κατά την "
"συσκευασία και αποσυσκευασία των δεδομένων. Δημιουργούνται από :ref:`format "
"characters<format-characters>`, οι οποίοι καθορίζουν τον τύπο των δεδομένων "
"που συσκευάζονται/αποσυσκευάζονται. Επιπλέον, ειδικοί χαρακτήρες ελέγχουν "
"την :ref:`byte order, size and alignment<struct-alignment>`. Κάθε "
"συμβολοσειρά μορφοποίησης αποτελείται από έναν προαιρετικό χαρακτήρα πρόθεμα "
"που περιγράφει τις συνολικές ιδιότητες των δεδομένων και έναν ή "
"περισσότερους χαρακτήρες μορφοποίησης που περιγράφουν τις πραγματικές τιμές "
"δεδομένων και το συμπλήρωμα."

#: library/struct.rst:125
msgid "Byte Order, Size, and Alignment"
msgstr "Διάταξη Byte, Μέγεθος και Στοίχιση"

#: library/struct.rst:127
msgid ""
"By default, C types are represented in the machine's native format and byte "
"order, and properly aligned by skipping pad bytes if necessary (according to "
"the rules used by the C compiler). This behavior is chosen so that the bytes "
"of a packed struct correspond exactly to the memory layout of the "
"corresponding C struct. Whether to use native byte ordering and padding or "
"standard formats depends on the application."
msgstr ""
"Από προεπιλογή, οι τύποι της C αναπαρίστανται στη φυσική μορφή και διάταξη "
"byte της μηχανής και ευθυγραμμίζονται σωστά, παραλείποντας byte γεμίσματος "
"εάν είναι απαραίτητο (σύμφωνα με τους κανόνες που χρησιμοποιεί ο "
"μεταγλωττιστής C). Αυτή η συμπεριφορά επιλέγεται έτσι ώστε τα byte μιας "
"συσκευασμένης δομής να αντιστοιχούν ακριβώς στη διάταξη μνήμης της "
"αντίστοιχης δομής της C. Το αν θα χρησιμοποιηθεί φυσική διάταξη byte και "
"γέμισμα ή τυποποιημένες μορφές εξαρτάται από την εφαρμογή."

#: library/struct.rst:143
msgid ""
"Alternatively, the first character of the format string can be used to "
"indicate the byte order, size and alignment of the packed data, according to "
"the following table:"
msgstr ""
"Εναλλακτικά, ο πρώτος χαρακτήρας της συμβολοσειράς μορφοποίησης μπορεί να "
"χρησιμοποιηθεί για να υποδείξει τη σειρά byte, το μέγεθος και την "
"ευθυγράμμιση των συσκευασμένων δεδομένων, σύμφωνα με το παρακάτω πίνακα: "

#: library/struct.rst:148
msgid "Character"
msgstr "Χαρακτήρας"

#: library/struct.rst:148
msgid "Byte order"
msgstr "Σειρά bytes"

#: library/struct.rst:148
msgid "Size"
msgstr "Μέγεθος"

#: library/struct.rst:148
msgid "Alignment"
msgstr "Στοίχιση"

#: library/struct.rst:150
msgid "``@``"
msgstr "``@``"

#: library/struct.rst:152
msgid "native"
msgstr "native"

#: library/struct.rst:152
msgid "``=``"
msgstr "``=``"

#: library/struct.rst:154 library/struct.rst:158
msgid "standard"
msgstr "τυπικό"

#: library/struct.rst:154 library/struct.rst:158
msgid "none"
msgstr "κανένα"

#: library/struct.rst:154
msgid "``<``"
msgstr "``<``"

#: library/struct.rst:154
msgid "little-endian"
msgstr "little-endian"

#: library/struct.rst:156
msgid "``>``"
msgstr "``>``"

#: library/struct.rst:156
msgid "big-endian"
msgstr "big-endian"

#: library/struct.rst:158
msgid "``!``"
msgstr "``!``"

#: library/struct.rst:158
msgid "network (= big-endian)"
msgstr "δίκτυο (= big-endian)"

#: library/struct.rst:161
msgid "If the first character is not one of these, ``'@'`` is assumed."
msgstr "Αν ο πρώτος χαρακτήρας δεν είναι ένας από αυτούς, υποτίθεται ``'@'``."

#: library/struct.rst:165
msgid ""
"The number 1023 (``0x3ff`` in hexadecimal) has the following byte "
"representations:"
msgstr ""
"Ο αριθμός 1023 (``0x3ff`` σε δεκαεξαδική μορφή) έχει τις ακόλουθες "
"αναπαραστάσεις σε byte:"

#: library/struct.rst:167
msgid "``03 ff`` in big-endian (``>``)"
msgstr "``03 ff`` σε big-endian (``>``)"

#: library/struct.rst:168
msgid "``ff 03`` in little-endian (``<``)"
msgstr "``ff 03`` σε little-endian (``<``)"

#: library/struct.rst:170
msgid "Python example:"
msgstr "Παράδειγμα Python:"

#: library/struct.rst:178
msgid ""
"Native byte order is big-endian or little-endian, depending on the host "
"system. For example, Intel x86, AMD64 (x86-64), and Apple M1 are little-"
"endian; IBM z and many legacy architectures are big-endian. Use :data:`sys."
"byteorder` to check the endianness of your system."
msgstr ""
"Η native σειρά byte είναι big-endian ή little-endian, ανάλογα με το σύστημα "
"υποδοχής. Για παράδειγμα, οι Intel x86, AMD64 (x86-64) και Apple M1 είναι "
"little-endian, ενώ οι IBM z και πολλές παλαιότερες αρχιτεκτονικές είναι big-"
"endian. Χρησιμοποιήστε τη μεταβλητή :data:`sys.byteorder` για να ελέγξετε το "
"endianness του συστήματος σας."

#: library/struct.rst:183
msgid ""
"Native size and alignment are determined using the C compiler's ``sizeof`` "
"expression.  This is always combined with native byte order."
msgstr ""
"Το native μέγεθος και η στοίχιση καθορίζονται χρησιμοποιώντας την έκφραση "
"``sizeof`` του μεταγλωττιστή C. Αυτό συνδυάζεται πάντα με την native σειρά "
"byte."

#: library/struct.rst:186
msgid ""
"Standard size depends only on the format character;  see the table in the :"
"ref:`format-characters` section."
msgstr ""
"Το τυπικό μέγεθος εξαρτάται μόνο από τον χαρακτήρα μορφοποίησης· δείτε τον "
"πίνακα στην ενότητα :ref:`format-characters`."

#: library/struct.rst:189
msgid ""
"Note the difference between ``'@'`` and ``'='``: both use native byte order, "
"but the size and alignment of the latter is standardized."
msgstr ""
"Σημειώστε τη διαφορά μεταξύ του ``'@'`` και ``'='``: και τα δύο "
"χρησιμοποιούν τη native σειρά byte,  αλλά το μέγεθος και η στοίχιση του "
"τελευταίου είναι τυποποιημένα. "

#: library/struct.rst:192
msgid ""
"The form ``'!'`` represents the network byte order which is always big-"
"endian as defined in `IETF RFC 1700 <IETF RFC 1700_>`_."
msgstr ""
"Η μορφή ``'!'`` αντιπροσωπεύει τη σειρά byte του δικτύου, η οποία είναι "
"πάντα big-endian όπως ορίζεται στο `IETF RFC 1700 <IETF RFC 1700_>`_."

#: library/struct.rst:195
msgid ""
"There is no way to indicate non-native byte order (force byte-swapping); use "
"the appropriate choice of ``'<'`` or ``'>'``."
msgstr ""
"Δεν υπάρχει τρόπος να δηλωθεί non-native σειρά byte (να επιβληθεί εναλλαγή "
"byte). Χρησιμοποιήστε την κατάλληλη επιλογή ``'<'`` ή ``'>'``."

#: library/struct.rst:284
msgid "Notes:"
msgstr "Σημειώσεις:"

#: library/struct.rst:200
msgid ""
"Padding is only automatically added between successive structure members. No "
"padding is added at the beginning or the end of the encoded struct."
msgstr ""
"Το συμπλήρωμα (padding) προστίθεται αυτόματα μόνο μεταξύ διαδοχικών μελών "
"της δομής. Δεν προστίθεται συμπλήρωμα στην αρχή ή στο τέλος της "
"κωδικοποιημένης δομής. "

#: library/struct.rst:203
msgid ""
"No padding is added when using non-native size and alignment, e.g. with '<', "
"'>', '=', and '!'."
msgstr ""
"Δεν προστίθεται συμπλήρωμα όταν χρησιμοποιείται non-native μέγεθος και "
"στοίχιση, π.χ. με '<','>', '=', και '!'."

#: library/struct.rst:206
msgid ""
"To align the end of a structure to the alignment requirement of a particular "
"type, end the format with the code for that type with a repeat count of "
"zero.  See :ref:`struct-examples`."
msgstr ""
"Για να ευθυγραμμίσετε το τέλος μιας δομής με την απαίτηση στοίχισης ενός "
"συγκεκριμένου τύπου, τελειώστε τη μορφή με τον κωδικό για αυτό τον τύπο με "
"πλήθος επαναλήψεων μηδέν. Δείτε :ref:`struct-examples`."

#: library/struct.rst:214
msgid "Format Characters"
msgstr "Χαρακτήρες μορφής"

#: library/struct.rst:216
msgid ""
"Format characters have the following meaning; the conversion between C and "
"Python values should be obvious given their types.  The 'Standard size' "
"column refers to the size of the packed value in bytes when using standard "
"size; that is, when the format string starts with one of ``'<'``, ``'>'``, "
"``'!'`` or ``'='``.  When using native size, the size of the packed value is "
"platform-dependent."
msgstr ""
"Οι χαρακτήρες μορφής έχουν την ακόλουθη σημασία· η μετατροπή μεταξύ τιμών C "
"και Python είναι προφανής, δεδομένων των τύπων τους. Η στήλη 'Τυπικό "
"μέγεθος' αναφέρεται στο μέγεθος της συμπιεσμένης τιμής σε byte όταν "
"χρησιμοποιείται τυπικό μέγεθος· δηλαδή, όταν η συμβολοσειρά μορφής ξεκινά με "
"ένα από τα ``'<'``, ``'>'``, ``'!'`` or ``'='``. Όταν χρησιμοποιείται το "
"native μέγεθος, το μέγεθος της συμπιεσμένης τιμής εξαρτάται από την "
"πλατφόρμα."

#: library/struct.rst:224
msgid "Format"
msgstr "Μορφή"

#: library/struct.rst:224
msgid "C Type"
msgstr "Τύπος C"

#: library/struct.rst:224
msgid "Python type"
msgstr "Τύπος Python"

#: library/struct.rst:224
msgid "Standard size"
msgstr "Τυπικό μέγεθος"

#: library/struct.rst:224
msgid "Notes"
msgstr "Σημειώσεις"

#: library/struct.rst:226
msgid "``x``"
msgstr "``x``"

#: library/struct.rst:226
msgid "pad byte"
msgstr "συμπληρωματικό byte"

#: library/struct.rst:226
msgid "no value"
msgstr "καμία τιμή"

#: library/struct.rst:226
msgid "\\(7)"
msgstr "\\(7)"

#: library/struct.rst:228
msgid "``c``"
msgstr "``c``"

#: library/struct.rst:228
msgid ":c:expr:`char`"
msgstr ":c:expr:`char`"

#: library/struct.rst:228
msgid "bytes of length 1"
msgstr "bytes μήκους 1"

#: library/struct.rst:230 library/struct.rst:234
msgid "1"
msgstr "1"

#: library/struct.rst:230
msgid "``b``"
msgstr "``b``"

#: library/struct.rst:230
msgid ":c:expr:`signed char`"
msgstr ":c:expr:`signed char`"

#: library/struct.rst:232 library/struct.rst:238 library/struct.rst:242
#: library/struct.rst:246 library/struct.rst:250 library/struct.rst:255
#: library/struct.rst:271
msgid "integer"
msgstr "integer"

#: library/struct.rst:230
msgid "\\(1), \\(2)"
msgstr "\\(1), \\(2)"

#: library/struct.rst:232
msgid "``B``"
msgstr "``B``"

#: library/struct.rst:232
msgid ":c:expr:`unsigned char`"
msgstr ":c:expr:`unsigned char`"

#: library/struct.rst:236 library/struct.rst:240 library/struct.rst:244
#: library/struct.rst:248 library/struct.rst:250
msgid "\\(2)"
msgstr "\\(2)"

#: library/struct.rst:234
msgid "``?``"
msgstr "``?``"

#: library/struct.rst:234
msgid ":c:expr:`_Bool`"
msgstr ":c:expr:`_Bool`"

#: library/struct.rst:234
msgid "bool"
msgstr "bool"

#: library/struct.rst:234
msgid "\\(1)"
msgstr "\\(1)"

#: library/struct.rst:236
msgid "``h``"
msgstr "``h``"

#: library/struct.rst:236
msgid ":c:expr:`short`"
msgstr ":c:expr:`short`"

#: library/struct.rst:238 library/struct.rst:257
msgid "2"
msgstr "2"

#: library/struct.rst:238
msgid "``H``"
msgstr "``H``"

#: library/struct.rst:238
msgid ":c:expr:`unsigned short`"
msgstr ":c:expr:`unsigned short`"

#: library/struct.rst:240
msgid "``i``"
msgstr "``i``"

#: library/struct.rst:240
msgid ":c:expr:`int`"
msgstr ":c:expr:`int`"

#: library/struct.rst:242 library/struct.rst:246 library/struct.rst:259
msgid "4"
msgstr "4"

#: library/struct.rst:242
msgid "``I``"
msgstr "``I``"

#: library/struct.rst:242
msgid ":c:expr:`unsigned int`"
msgstr ":c:expr:`unsigned int`"

#: library/struct.rst:244
msgid "``l``"
msgstr "``l``"

#: library/struct.rst:244
msgid ":c:expr:`long`"
msgstr ":c:expr:`long`"

#: library/struct.rst:246
msgid "``L``"
msgstr "``L``"

#: library/struct.rst:246
msgid ":c:expr:`unsigned long`"
msgstr ":c:expr:`unsigned long`"

#: library/struct.rst:248
msgid "``q``"
msgstr "``q``"

#: library/struct.rst:248
msgid ":c:expr:`long long`"
msgstr ":c:expr:`long long`"

#: library/struct.rst:250 library/struct.rst:263
msgid "8"
msgstr "8"

#: library/struct.rst:250
msgid "``Q``"
msgstr "``Q``"

#: library/struct.rst:250
msgid ":c:expr:`unsigned long long`"
msgstr ":c:expr:`unsigned long long`"

#: library/struct.rst:253
msgid "``n``"
msgstr "``n``"

#: library/struct.rst:253
msgid ":c:type:`ssize_t`"
msgstr ":c:type:`ssize_t`"

#: library/struct.rst:255
msgid "\\(3)"
msgstr "\\(3)"

#: library/struct.rst:255
msgid "``N``"
msgstr "``N``"

#: library/struct.rst:255
msgid ":c:type:`size_t`"
msgstr ":c:type:`size_t`"

#: library/struct.rst:257
msgid "``e``"
msgstr "``e``"

#: library/struct.rst:257
msgid "\\(6)"
msgstr "\\(6)"

#: library/struct.rst:259 library/struct.rst:261
msgid "float"
msgstr "float"

#: library/struct.rst:259 library/struct.rst:261
msgid "\\(4)"
msgstr "\\(4)"

#: library/struct.rst:259
msgid "``f``"
msgstr "``f``"

#: library/struct.rst:259
msgid ":c:expr:`float`"
msgstr ":c:expr:`float`"

#: library/struct.rst:261
msgid "``d``"
msgstr "``d``"

#: library/struct.rst:261
msgid ":c:expr:`double`"
msgstr ":c:expr:`double`"

#: library/struct.rst:263
msgid "``F``"
msgstr "``F``"

#: library/struct.rst:263
msgid ":c:expr:`float complex`"
msgstr ":c:expr:`float complex`"

#: library/struct.rst:265
msgid "complex"
msgstr "μιγαδικός"

#: library/struct.rst:265
msgid "\\(10)"
msgstr "\\(10)"

#: library/struct.rst:265
msgid "``D``"
msgstr "``D``"

#: library/struct.rst:265
msgid ":c:expr:`double complex`"
msgstr ":c:expr:`double complex`"

#: library/struct.rst:265
msgid "16"
msgstr "16"

#: library/struct.rst:267
msgid "``s``"
msgstr "``s``"

#: library/struct.rst:269
msgid ":c:expr:`char[]`"
msgstr ":c:expr:`char[]`"

#: library/struct.rst:269
msgid "bytes"
msgstr "bytes"

#: library/struct.rst:267
msgid "\\(9)"
msgstr "\\(9)"

#: library/struct.rst:269
msgid "``p``"
msgstr "``p``"

#: library/struct.rst:269
msgid "\\(8)"
msgstr "\\(8)"

#: library/struct.rst:271
msgid "``P``"
msgstr "``P``"

#: library/struct.rst:271
msgid ":c:expr:`void \\*`"
msgstr ":c:expr:`void \\*`"

#: library/struct.rst:271
msgid "\\(5)"
msgstr "\\(5)"

#: library/struct.rst:274
msgid "Added support for the ``'n'`` and ``'N'`` formats."
msgstr "Προστέθηκε υποστήριξη για τις μορφές ``'n'`` και ``'N'``."

#: library/struct.rst:277
msgid "Added support for the ``'e'`` format."
msgstr "Προστέθηκε υποστήριξη για τη μορφή ``'e'``."

#: library/struct.rst:280
msgid "Added support for the ``'F'`` and ``'D'`` formats."
msgstr "Προστέθηκε υποστήριξη για τις μορφές ``'F'`` και ``'D'``."

#: library/struct.rst:289
msgid ""
"The ``'?'`` conversion code corresponds to the :c:expr:`_Bool` type defined "
"by C standards since C99.  In standard mode, it is represented by one byte."
msgstr ""
"Ο κωδικός μετατροπής ``'?'`` αντιστοιχεί στον τύπο :c:expr:`_Bool` που "
"ορίζεται από τα πρότυπα C από την έκδοση C99. Σε τυπική λειτουργία, "
"αναπαρίσταται από ένα byte."

#: library/struct.rst:294
msgid ""
"When attempting to pack a non-integer using any of the integer conversion "
"codes, if the non-integer has a :meth:`~object.__index__` method then that "
"method is called to convert the argument to an integer before packing."
msgstr ""
"Όταν επιχειρείται η συσκευασία ενός μη ακέραιου αριθμού χρησιμοποιώντας "
"οποιονδήποτε από τους κωδικούς μετατροπής ακεραίων, αν το αντικείμενο "
"διαθέτει τη μέθοδο :meth:`~object.__index__`, τότε καλείται αυτή η μέθοδος "
"για τη μετατροπή του ορίσματος σε ακέραιο πριν από τη συσκευασία."

#: library/struct.rst:298
msgid "Added use of the :meth:`~object.__index__` method for non-integers."
msgstr ""
"Προστέθηκε η χρήση της μεθόδου :meth:`~object.__index__` για μη ακέραιους "
"αριθμούς."

#: library/struct.rst:302
msgid ""
"The ``'n'`` and ``'N'`` conversion codes are only available for the native "
"size (selected as the default or with the ``'@'`` byte order character). For "
"the standard size, you can use whichever of the other integer formats fits "
"your application."
msgstr ""
"Οι κωδικοί μετατροπής ``'n'`` και ``'N'`` είναι διαθέσιμοι μόνο για το "
"native μέγεθος (επιλεγμένο ως προεπιλογή ή με τον χαρακτήρα διάταξης byte "
"``'@'``). Για το τυπικό μέγεθος, μπορείτε να χρησιμοποιήσετε οποιαδήποτε από "
"τις άλλες μορφές ακέραιων που ταιριάζουν στην εφαρμογή σας."

#: library/struct.rst:308
msgid ""
"For the ``'f'``, ``'d'`` and ``'e'`` conversion codes, the packed "
"representation uses the IEEE 754 binary32, binary64 or binary16 format (for "
"``'f'``, ``'d'`` or ``'e'`` respectively), regardless of the floating-point "
"format used by the platform."
msgstr ""
"Για τους κωδικούς μετατροπής ``'f'``, ``'d'`` και ``'e'``, η συσκευασμένη "
"αναπαράσταση χρησιμοποιεί τη μορφή IEEE 754 binary32, binary64 ή binary16 "
"(αντίστοιχα για ``'f'``, ``'d'`` ή ``'e'``), ανεξάρτητα από τη μορφή κινητής "
"υποδιαστολής που χρησιμοποιεί η πλατφόρμα."

#: library/struct.rst:314
msgid ""
"The ``'P'`` format character is only available for the native byte ordering "
"(selected as the default or with the ``'@'`` byte order character). The byte "
"order character ``'='`` chooses to use little- or big-endian ordering based "
"on the host system. The struct module does not interpret this as native "
"ordering, so the ``'P'`` format is not available."
msgstr ""
"Ο χαρακτήρας μορφοποίησης ``'P'`` είναι διαθέσιμος μόνο για τη φυσική σειρά "
"byte (επιλεγμένη ως προεπιλογή ή με τον χαρακτήρα σειράς byte ``'@'``). Ο "
"χαρακτήρας σειράς byte ``'='`` επιλέγει τη χρήση little- ή big-endian σειράς "
"με βάση το σύστημα. Το module struct δεν ερμηνεύει αυτό ως native σειρά, "
"επομένως η μορφή ``'P'`` δεν είναι διαθέσιμη."

#: library/struct.rst:321
msgid ""
"The IEEE 754 binary16 \"half precision\" type was introduced in the 2008 "
"revision of the `IEEE 754 standard <ieee 754 standard_>`_. It has a sign "
"bit, a 5-bit exponent and 11-bit precision (with 10 bits explicitly stored), "
"and can represent numbers between approximately ``6.1e-05`` and ``6.5e+04`` "
"at full precision. This type is not widely supported by C compilers: on a "
"typical machine, an unsigned short can be used for storage, but not for math "
"operations. See the Wikipedia page on the `half-precision floating-point "
"format <half precision format_>`_ for more information."
msgstr ""
"Ο τύπος IEEE 754 binary16 \"half precision\" εισήχθη στην αναθεώρηση του "
"2008 του προτύπου `IEEE 754 standard <ieee 754 standard_>`_. Διαθέτει ένα "
"bit προσήμου, έναν εκθέτη 5-bit και ακρίβεια 11-bit (με 10 bit αποθηκευμένα "
"ρητά) και μπορεί να αναπαραστήσει αριθμούς μεταξύ περίπου ``6.1e-05`` και "
"``6.5e+04`` με πλήρη ακρίβεια. Αυτός ο τύπος δεν υποστηρίζεται ευρέως από "
"τους μεταγλωττιστές της C: σε μια τυπική μηχανή, ένας μη προσημασμένος short "
"μπορεί να χρησιμοποιηθεί για αποθήκευση, αλλά όχι για αριθμητικές πράξεις. "
"Δείτε τη σελίδα της Wikipedia για τη `half-precision floating-point format "
"<half precision format_>`_ για περισσότερες πληροφορίες. "

#: library/struct.rst:331
msgid "When packing, ``'x'`` inserts one NUL byte."
msgstr "Κατά τη συσκευασία, το ``'x'`` εισάγει ένα NUL byte."

#: library/struct.rst:334
msgid ""
"The ``'p'`` format character encodes a \"Pascal string\", meaning a short "
"variable-length string stored in a *fixed number of bytes*, given by the "
"count. The first byte stored is the length of the string, or 255, whichever "
"is smaller.  The bytes of the string follow.  If the string passed in to :"
"func:`pack` is too long (longer than the count minus 1), only the leading "
"``count-1`` bytes of the string are stored.  If the string is shorter than "
"``count-1``, it is padded with null bytes so that exactly count bytes in all "
"are used.  Note that for :func:`unpack`, the ``'p'`` format character "
"consumes ``count`` bytes, but that the string returned can never contain "
"more than 255 bytes."
msgstr ""
"Ο χαρακτήρας μορφοποίησης ``'p'`` κωδικοποιεί ένα \"Pascal string\", δηλαδή "
"μια μικρή συμβολοσειρά μεταβλητού μήκους αποθηκευμένη σε *σταθερό αριθμό "
"byte*, που καθορίζεται από τον μετρητή. Το πρώτο byte που αποθηκεύεται είναι "
"το μήκος της συμβολοσειράς ή 255, όποιο είναι μικρότερο. Ακολουθούν τα byte "
"της συμβολοσειράς. Εάν η συμβολοσειρά που περνά στην :func:`pack` είναι πολύ "
"μεγάλη (μεγαλύτερη από τον μετρητή μείον 1), αποθηκεύονται μόνο τα πρώτα "
"``count-1`` byte της συμβολοσειράς. Εάν η συμβολοσειρά είναι μικρότερη από "
"``count-1``, συμπληρώνεται με μηδενικά byte ώστε να χρησιμοποιηθούν ακριβώς "
"τόσα byte όσα καθορίζει ο μετρητής. Σημειώστε ότι για τη :func:`unpack`, ο "
"χαρακτήρας μορφοποίησης ``'p'`` καταναλώνει ``count`` byte, αλλά η "
"συμβολοσειρά που επιστρέφεται δεν μπορεί ποτέ να περιέχει περισσότερα από "
"255 byte. "

#: library/struct.rst:346
msgid ""
"For the ``'s'`` format character, the count is interpreted as the length of "
"the bytes, not a repeat count like for the other format characters; for "
"example, ``'10s'`` means a single 10-byte string mapping to or from a single "
"Python byte string, while ``'10c'`` means 10 separate one byte character "
"elements (e.g., ``cccccccccc``) mapping to or from ten different Python byte "
"objects. (See :ref:`struct-examples` for a concrete demonstration of the "
"difference.) If a count is not given, it defaults to 1.  For packing, the "
"string is truncated or padded with null bytes as appropriate to make it fit. "
"For unpacking, the resulting bytes object always has exactly the specified "
"number of bytes.  As a special case, ``'0s'`` means a single, empty string "
"(while ``'0c'`` means 0 characters)."
msgstr ""
"Για το χαρακτήρα μορφοποίησης ``'s'``, αριθμός (count) ερμηνεύεται ως το "
"μήκος των byte, και όχι ως ένας αριθμός επαναλήψεων, όπως συμβαίνει με "
"άλλους χαρακτήρες μορφοποίησης. Για παράδειγμα, ``'10s'``σημαίνει μια "
"μοναδική συμβολοσειρά 10 byte που αντιστοιχεί ή προέρχεται από ένα ενιαίο "
"byte string της Python, ενώ ``'10c'`` σημαίνει 10 ξεχωριστούς χαρακτήρες του "
"ενός byte στοιχεία (π.χ. ``cccccccccc``) που αντιστοιχούν σε ή από δέκα "
"διαφορετικά byte objects της Python. (Δείτε το :ref:`struct-examples` για "
"μια συγκεκριμένη επίδειξη της διαφοράς.) Αν δεν δοθεί αριθμός, η "
"προεπιλεγμένη τιμή είναι 1. Κατά την συσκευασία (packing), η συμβολοσειρά "
"περικόπτεται ή συμπληρώνεται με μηδενικά byte ώστε να ταιριάζει στο "
"καθορισμένο μήκος. Κατά την αποσυσκευασία (unpacking), το αποτέλεσμα είναι "
"πάντα ένα αντικείμενο bytes με ακριβώς το καθορισμένο μήκος. Ως ειδική "
"περίπτωση, το ``'0s'`` σημαίνει μια μοναδική, κενή συμβολοσειρά (ενώ το "
"``'0c'`` σημαίνει 0 χαρακτήρες). "

#: library/struct.rst:360
msgid ""
"For the ``'F'`` and ``'D'`` format characters, the packed representation "
"uses the IEEE 754 binary32 and binary64 format for components of the complex "
"number, regardless of the floating-point format used by the platform. Note "
"that complex types (``F`` and ``D``) are available unconditionally, despite "
"complex types being an optional feature in C. As specified in the C11 "
"standard, each complex type is represented by a two-element C array "
"containing, respectively, the real and imaginary parts."
msgstr ""
"Για τους χαρακτήρες μορφής ``'F'`` and ``'D'``, η πακεταρισμένη αναπαράσταση "
"χρησιμοποιεί τη μορφή IEEE 754 binary32 και binary64 για τα στοιχεία του "
"μιγαδικού αριθμού, ανεξάρτητα από τη μορφή κινητής υποδιαστολής που "
"χρησιμοποιείται από την πλατφόρμα. Σημειώστε ότι οι μιγαδικοί τύποι (``F`` "
"και ``D``) είναι διαθέσιμοι άνευ όρων, παρά το γεγονός ότι οι μιγαδικοί "
"τύποι αποτελούν προαιρετικό χαρακτηριστικό στη C. Όπως ορίζεται στο πρότυπο "
"C11, κάθε μιγαδικός τύπος αναπαρίσταται από έναν πίνακα C δύο στοιχείων που "
"περιέχει αντίστοιχα, τα πραγματικά και τα φανταστικά μέρη."

#: library/struct.rst:369
msgid ""
"A format character may be preceded by an integral repeat count.  For "
"example, the format string ``'4h'`` means exactly the same as ``'hhhh'``."
msgstr ""
"Ένας χαρακτήρας μορφοποίησης μπορεί να προηγείται από έναν ακέραιο αριθμό "
"επαναλήψεων. Για παράδειγμα, η συμβολοσειρά μορφοποίησης ``'4h'`` σημαίνει "
"ακριβώς το ίδιο με ``'hhhh'``."

#: library/struct.rst:372
msgid ""
"Whitespace characters between formats are ignored; a count and its format "
"must not contain whitespace though."
msgstr ""
"Οι χαρακτήρες κενού μεταξύ των μορφοποιήσεων αγνοούνται· ωστόσο, ένας "
"αριθμός και η μορφή του δεν πρέπει να περιέχουν κενά."

#: library/struct.rst:375
msgid ""
"When packing a value ``x`` using one of the integer formats (``'b'``, "
"``'B'``, ``'h'``, ``'H'``, ``'i'``, ``'I'``, ``'l'``, ``'L'``, ``'q'``, "
"``'Q'``), if ``x`` is outside the valid range for that format then :exc:"
"`struct.error` is raised."
msgstr ""
"Κατά το πακετάρισμα μιας τιμής ``x`` χρησιμοποιώντας μια από τις μορφές "
"ακεραίων (``'b'``, ``'B'``, ``'h'``, ``'H'``, ``'i'``, ``'I'``, ``'l'``, "
"``'L'``, ``'q'``, ``'Q'``), εάν το ``x`` είναι εκτός του έγκυρου εύρους για "
"αυτήν τη μορφή, γίνεται raise μια εξαίρεση :exc:`struct.error`."

#: library/struct.rst:380
msgid ""
"Previously, some of the integer formats wrapped out-of-range values and "
"raised :exc:`DeprecationWarning` instead of :exc:`struct.error`."
msgstr ""
"Προηγουμένως, ορισμένες από τις μορφές ακεραίων περιτύλιγαν τιμές εκτός "
"εύρους και εμφάνιζαν :exc:`DeprecationWarning` αντί για :exc:`struct.error`."

#: library/struct.rst:386
msgid ""
"For the ``'?'`` format character, the return value is either :const:`True` "
"or :const:`False`. When packing, the truth value of the argument object is "
"used. Either 0 or 1 in the native or standard bool representation will be "
"packed, and any non-zero value will be ``True`` when unpacking."
msgstr ""
"Για το χαρακτήρα μορφής ``'?'``, η τιμή που επιστρέφεται είναι είτε :const:"
"`True` είτε :const:`False`. Κατά την συσκευασία, χρησιμοποιείται η λογική "
"τιμή του αντικειμένου-ορίσματος. Είτε 0 είτε 1 στη native ή τυπική "
"αναπαράσταση του bool θα συσκευαστούν, και οποιαδήποτε μη μηδενική τιμή θα "
"είναι ``True`` κατά την αποσυσκευασία."

#: library/struct.rst:396
msgid "Examples"
msgstr "Παραδείγματα"

#: library/struct.rst:399
msgid ""
"Native byte order examples (designated by the ``'@'`` format prefix or lack "
"of any prefix character) may not match what the reader's machine produces as "
"that depends on the platform and compiler."
msgstr ""
"Τα παραδείγματα native σειράς byte (που καθορίζονται από το πρόθεμα μορφής "
"``'@'`` ή την απουσία οποιουδήποτε χαρακτήρα προθέματος) ενδέχεται να μην "
"αντιστοιχούν σε αυτά που παράγει η μηχανή του αναγνώστη, καθώς αυτό "
"εξαρτάται από την πλατφόρμα και τον μεταγλωττιστή."

#: library/struct.rst:404
msgid ""
"Pack and unpack integers of three different sizes, using big endian "
"ordering::"
msgstr ""
"Συσκευασία και αποσυσκευασία ακεραίων τριών διαφορετικών μεγεθών, "
"χρησιμοποιώντας διάταξη big endian::"

#: library/struct.rst:407
msgid ""
">>> from struct import *\n"
">>> pack(\">bhl\", 1, 2, 3)\n"
"b'\\x01\\x00\\x02\\x00\\x00\\x00\\x03'\n"
">>> unpack('>bhl', b'\\x01\\x00\\x02\\x00\\x00\\x00\\x03')\n"
"(1, 2, 3)\n"
">>> calcsize('>bhl')\n"
"7"
msgstr ""
">>> from struct import *\n"
">>> pack(\">bhl\", 1, 2, 3)\n"
"b'\\x01\\x00\\x02\\x00\\x00\\x00\\x03'\n"
">>> unpack('>bhl', b'\\x01\\x00\\x02\\x00\\x00\\x00\\x03')\n"
"(1, 2, 3)\n"
">>> calcsize('>bhl')\n"
"7"

#: library/struct.rst:415
msgid "Attempt to pack an integer which is too large for the defined field::"
msgstr ""
"Προσπάθεια συσκευασίας ενός ακεραίου που είναι πολύ μεγάλος για το "
"καθορισμένο πεδίο::"

#: library/struct.rst:417
msgid ""
">>> pack(\">h\", 99999)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"struct.error: 'h' format requires -32768 <= number <= 32767"
msgstr ""
">>> pack(\">h\", 99999)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"struct.error: 'h' format requires -32768 <= number <= 32767"

#: library/struct.rst:422
msgid ""
"Demonstrate the difference between ``'s'`` and ``'c'`` format characters::"
msgstr ""
"Επιδεικνύει την διαφορά μεταξύ των χαρακτήρων μορφοποίησης ``'s'`` και "
"``'c'``::"

#: library/struct.rst:425
msgid ""
">>> pack(\"@ccc\", b'1', b'2', b'3')\n"
"b'123'\n"
">>> pack(\"@3s\", b'123')\n"
"b'123'"
msgstr ""
">>> pack(\"@ccc\", b'1', b'2', b'3')\n"
"b'123'\n"
">>> pack(\"@3s\", b'123')\n"
"b'123'"

#: library/struct.rst:430
msgid ""
"Unpacked fields can be named by assigning them to variables or by wrapping "
"the result in a named tuple::"
msgstr ""
"Τα αποσυσκευασμένα πεδία μπορούν να ονομαστούν είτε αναθέτοντάς τα σε "
"μεταβλητές είτε περιτυλίγοντάς τα σε μια ονομασμένη πλειάδα::"

#: library/struct.rst:433
msgid ""
">>> record = b'raymond   \\x32\\x12\\x08\\x01\\x08'\n"
">>> name, serialnum, school, gradelevel = unpack('<10sHHb', record)\n"
"\n"
">>> from collections import namedtuple\n"
">>> Student = namedtuple('Student', 'name serialnum school gradelevel')\n"
">>> Student._make(unpack('<10sHHb', record))\n"
"Student(name=b'raymond   ', serialnum=4658, school=264, gradelevel=8)"
msgstr ""
">>> record = b'raymond   \\x32\\x12\\x08\\x01\\x08'\n"
">>> name, serialnum, school, gradelevel = unpack('<10sHHb', record)\n"
"\n"
">>> from collections import namedtuple\n"
">>> Student = namedtuple('Student', 'name serialnum school gradelevel')\n"
">>> Student._make(unpack('<10sHHb', record))\n"
"Student(name=b'raymond   ', serialnum=4658, school=264, gradelevel=8)"

#: library/struct.rst:441
msgid ""
"The ordering of format characters may have an impact on size in native mode "
"since padding is implicit. In standard mode, the user is responsible for "
"inserting any desired padding. Note in the first ``pack`` call below that "
"three NUL bytes were added after the packed ``'#'`` to align the following "
"integer on a four-byte boundary. In this example, the output was produced on "
"a little endian machine::"
msgstr ""
"Η σειρά των χαρακτήρων μορφοποίησης μπορεί να επηρεάσει το μέγεθος σε "
"κατάσταση native λειτουργίας, καθώς το συμπλήρωμα είναι έμμεσο. Σε τυπική "
"λειτουργία, ο χρήστης είναι υπεύθυνος για την εισαγωγή οποιασδήποτε "
"επιθυμητού συμπληρώματος. Σημειώστε στην πρώτη κλήση ``pack`` παρακάτω ότι "
"προστέθηκαν τρία μηδενικά (NUL) bytes μετά την συσκευασμένη τιμή ``'#'`` για "
"να ευθυγραμμιστεί ο επόμενος ακέραιος σε όριο τεσσάρων bytes. Σε αυτό το "
"παράδειγμα, η έξοδος παράχθηκε σε έναν υπολογιστή με little endian "
"αρχιτεκτονική::"

#: library/struct.rst:449
msgid ""
">>> pack('@ci', b'#', 0x12131415)\n"
"b'#\\x00\\x00\\x00\\x15\\x14\\x13\\x12'\n"
">>> pack('@ic', 0x12131415, b'#')\n"
"b'\\x15\\x14\\x13\\x12#'\n"
">>> calcsize('@ci')\n"
"8\n"
">>> calcsize('@ic')\n"
"5"
msgstr ""
">>> pack('@ci', b'#', 0x12131415)\n"
"b'#\\x00\\x00\\x00\\x15\\x14\\x13\\x12'\n"
">>> pack('@ic', 0x12131415, b'#')\n"
"b'\\x15\\x14\\x13\\x12#'\n"
">>> calcsize('@ci')\n"
"8\n"
">>> calcsize('@ic')\n"
"5"

#: library/struct.rst:458
msgid ""
"The following format ``'llh0l'`` results in two pad bytes being added at the "
"end, assuming the platform's longs are aligned on 4-byte boundaries::"
msgstr ""
"Η ακόλουθη μορφή ``'llh0l'`` έχει ως αποτέλεσμα την προσθήκη δύο bytes "
"συμπλήρωσης στο τέλος, υποθέτοντας ότι οι μακροί ακέραιοι (longs) της "
"πλατφόρμας ευθυγραμμίζονται σε όρια 4-byte::"

#: library/struct.rst:461
msgid ""
">>> pack('@llh0l', 1, 2, 3)\n"
"b'\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x03\\x00\\x00'"
msgstr ""
">>> pack('@llh0l', 1, 2, 3)\n"
"b'\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x03\\x00\\x00'"

#: library/struct.rst:467
msgid "Module :mod:`array`"
msgstr "Module :mod:`array`"

#: library/struct.rst:468
msgid "Packed binary storage of homogeneous data."
msgstr "Πακεταρισμένη δυαδική αποθήκευση ομοιογενών δεδομένων."

#: library/struct.rst:470
msgid "Module :mod:`json`"
msgstr "Module :mod:`json`"

#: library/struct.rst:471
msgid "JSON encoder and decoder."
msgstr "Κωδικοποιητής και αποκωδικοποιητής JSON."

#: library/struct.rst:473
msgid "Module :mod:`pickle`"
msgstr "Module :mod:`pickle`"

#: library/struct.rst:474
msgid "Python object serialization."
msgstr "Σειριοποίηση αντικειμένων Python."

#: library/struct.rst:480
msgid "Applications"
msgstr "Εφαρμογές"

#: library/struct.rst:482
msgid ""
"Two main applications for the :mod:`struct` module exist, data interchange "
"between Python and C code within an application or another application "
"compiled using the same compiler (:ref:`native formats<struct-native-"
"formats>`), and data interchange between applications using agreed upon data "
"layout (:ref:`standard formats<struct-standard-formats>`).  Generally "
"speaking, the format strings constructed for these two domains are distinct."
msgstr ""
"Υπάρχουν δύο κύριες εφαρμογές για τη χρήση του :mod:`struct`: η ανταλλαγή "
"δεδομένων μεταξύ Python και κώδικα C μέσα σε μια εφαρμογή ή με μια άλλη "
"εφαρμογή που έχει μεταγλωττιστεί με τον ίδιο μεταγλωττιστή (:ref:`native "
"formats<struct-native-formats>`), και η ανταλλαγή δεδομένων μεταξύ εφαρμογών "
"που χρησιμοποιούν μια συμφωνημένη διάταξη δεδομένων (:ref:`standard "
"formats<struct-standard-formats>`). Γενικά, οι συμβολοσειρές μορφής που "
"χρησιμοποιούνται σε αυτούς τους δύο τομείς είναι διαφορετικές."

#: library/struct.rst:493
msgid "Native Formats"
msgstr "Native Μορφές"

#: library/struct.rst:495
msgid ""
"When constructing format strings which mimic native layouts, the compiler "
"and machine architecture determine byte ordering and padding. In such cases, "
"the ``@`` format character should be used to specify native byte ordering "
"and data sizes.  Internal pad bytes are normally inserted automatically.  It "
"is possible that a zero-repeat format code will be needed at the end of a "
"format string to round up to the correct byte boundary for proper alignment "
"of consecutive chunks of data."
msgstr ""
"Όταν κατασκευάζετε συμβολοσειρές μορφοποίησης που μιμούνται native "
"διατάξεις, ο μεταγλωττιστής και η αρχιτεκτονική του μηχανήματος καθορίζουν "
"τη σειρά των byte και τη συμπλήρωση. Σε τέτοιες περιπτώσεις, ο χαρακτήρας "
"μορφής ``@`` θα πρέπει να χρησιμοποιείται για να καθορίζει την native σειρά "
"byte και τα μεγέθη δεδομένων. Τα εσωτερικά byte συμπλήρωσης εισάγονται "
"συνήθως αυτόματα. Είναι πιθανό να χρειαστεί ένας κωδικός μορφοποίησης με "
"επανάληψη μηδέν στο τέλος μιας συμβολοσειράς μορφοποίησης για να "
"ευθυγραμμιστεί σωστά με τα όρια byte των διαδοχικών τμημάτων δεδομένων."

#: library/struct.rst:503
msgid ""
"Consider these two simple examples (on a 64-bit, little-endian machine)::"
msgstr ""
"Εξετάστε αυτά τα δύο απλά παραδείγματα (σε έναν 64-bit, little-endian "
"υπολογιστή)::"

#: library/struct.rst:506
msgid ""
">>> calcsize('@lhl')\n"
"24\n"
">>> calcsize('@llh')\n"
"18"
msgstr ""
">>> calcsize('@lhl')\n"
"24\n"
">>> calcsize('@llh')\n"
"18"

#: library/struct.rst:511
msgid ""
"Data is not padded to an 8-byte boundary at the end of the second format "
"string without the use of extra padding.  A zero-repeat format code solves "
"that problem::"
msgstr ""
"Τα δεδομένα δεν συμπληρώνονται σε όριο 8 byte στο τέλος της δεύτερης "
"συμβολοσειράς μορφοποίησης χωρίς τη χρήση επιπλέον συμπλήρωσης. Ένας κωδικός "
"μορφοποίησης με επανάληψη μηδέν λύνει αυτό το πρόβλημα::"

#: library/struct.rst:515
msgid ""
">>> calcsize('@llh0l')\n"
"24"
msgstr ""
">>> calcsize('@llh0l')\n"
"24"

#: library/struct.rst:518
msgid ""
"The ``'x'`` format code can be used to specify the repeat, but for native "
"formats it is better to use a zero-repeat format like ``'0l'``."
msgstr ""
"Ο κωδικός μορφοποίησης ``'x'`` μπορεί να χρησιμοποιηθεί για να καθορίσει την "
"επανάληψη, αλλά για native μορφές είναι προτιμότερο να χρησιμοποιείται ένας "
"κωδικός μορφοποίησης με επανάληψη μηδέν, όπως ``'0l'``."

#: library/struct.rst:521
msgid ""
"By default, native byte ordering and alignment is used, but it is better to "
"be explicit and use the ``'@'`` prefix character."
msgstr ""
"Από προεπιλογή, χρησιμοποιείται η native σειρά byte και στοίχιση, αλλά είναι "
"καλύτερο να είμαστε σαφείς και να χρησιμοποιούμε τον χαρακτήρα πρόθεμα "
"``'@'``."

#: library/struct.rst:528
msgid "Standard Formats"
msgstr "Τυπικές μορφές"

#: library/struct.rst:530
msgid ""
"When exchanging data beyond your process such as networking or storage, be "
"precise.  Specify the exact byte order, size, and alignment.  Do not assume "
"they match the native order of a particular machine. For example, network "
"byte order is big-endian, while many popular CPUs are little-endian.  By "
"defining this explicitly, the user need not care about the specifics of the "
"platform their code is running on. The first character should typically be "
"``<`` or ``>`` (or ``!``).  Padding is the responsibility of the "
"programmer.  The zero-repeat format character won't work.  Instead, the user "
"must explicitly add ``'x'`` pad bytes where needed.  Revisiting the examples "
"from the previous section, we have::"
msgstr ""
"Όταν ανταλλάσετε δεδομένα πέρα από τη διεργασία σας, όπως σε δικτύωση ή "
"αποθήκευση, να είστε ακριβείς. Καθορίστε την ακριβή σειρά των byte, το "
"μέγεθος και την ευθυγράμμιση. Μην υποθέτετε ότι ταιριάζουν με τη φυσική "
"σειρά μιας συγκεκριμένης μηχανής. Για παράδειγμα, η σειρά byte του δικτύου "
"είναι big-endian, ενώ πολλοί δημοφιλείς επεξεργαστές είναι little-endian. "
"Ορίζοντας αυτό ρητά, ο χρήστης δεν χρειάζεται να ενδιαφέρεται για τις "
"λεπτομέρειες της πλατφόρμας στην οποία εκτελείται ο κώδικας. Ο πρώτος "
"χαρακτήρας πρέπει τυπικά να είναι ``<`` ή ``>`` (ή ``!``). Η ευθύνη για την "
"προσθήκη συμπληρωματικών byte ανήκει στον προγραμματιστή. Ο χαρακτήρας "
"μορφής με μηδενική επανάληψη δεν θα λειτουργήσει. Αντ' αυτού, ο χρήστης "
"πρέπει να προσθέτει ρητά byte ``'x'`` όπου απαιτείται. Επανεξετάζοντας τα "
"παραδείγματα από την προηγούμενη ενότητα, έχουμε::"

#: library/struct.rst:542
msgid ""
">>> calcsize('<qh6xq')\n"
"24\n"
">>> pack('<qh6xq', 1, 2, 3) == pack('@lhl', 1, 2, 3)\n"
"True\n"
">>> calcsize('@llh')\n"
"18\n"
">>> pack('@llh', 1, 2, 3) == pack('<qqh', 1, 2, 3)\n"
"True\n"
">>> calcsize('<qqh6x')\n"
"24\n"
">>> calcsize('@llh0l')\n"
"24\n"
">>> pack('@llh0l', 1, 2, 3) == pack('<qqh6x', 1, 2, 3)\n"
"True"
msgstr ""
">>> calcsize('<qh6xq')\n"
"24\n"
">>> pack('<qh6xq', 1, 2, 3) == pack('@lhl', 1, 2, 3)\n"
"True\n"
">>> calcsize('@llh')\n"
"18\n"
">>> pack('@llh', 1, 2, 3) == pack('<qqh', 1, 2, 3)\n"
"True\n"
">>> calcsize('<qqh6x')\n"
"24\n"
">>> calcsize('@llh0l')\n"
"24\n"
">>> pack('@llh0l', 1, 2, 3) == pack('<qqh6x', 1, 2, 3)\n"
"True"

#: library/struct.rst:557
msgid ""
"The above results (executed on a 64-bit machine) aren't guaranteed to match "
"when executed on different machines.  For example, the examples below were "
"executed on a 32-bit machine::"
msgstr ""
"Τα παραπάνω αποτελέσματα (εκτελεσμένα σε 64-bit μηχανή) δεν είναι εγγυημένο "
"ότι θα ταιριάζουν όταν εκτελούνται σε διαφορετικές μηχανές. Για παράδειγμα, "
"τα παρακάτω παραδείγματα εκτελέστηκαν σε 32-bit μηχανή::"

#: library/struct.rst:561
msgid ""
">>> calcsize('<qqh6x')\n"
"24\n"
">>> calcsize('@llh0l')\n"
"12\n"
">>> pack('@llh0l', 1, 2, 3) == pack('<qqh6x', 1, 2, 3)\n"
"False"
msgstr ""
">>> calcsize('<qqh6x')\n"
"24\n"
">>> calcsize('@llh0l')\n"
"12\n"
">>> pack('@llh0l', 1, 2, 3) == pack('<qqh6x', 1, 2, 3)\n"
"False"

#: library/struct.rst:572
msgid "Classes"
msgstr "Κλάσεις"

#: library/struct.rst:574
msgid "The :mod:`struct` module also defines the following type:"
msgstr "Το module :mod:`struct` ορίζει επίσης τον ακόλουθο τύπο:"

#: library/struct.rst:579
msgid ""
"Return a new Struct object which writes and reads binary data according to "
"the format string *format*.  Creating a ``Struct`` object once and calling "
"its methods is more efficient than calling module-level functions with the "
"same format since the format string is only compiled once."
msgstr ""
"Επιστρέφει ένα νέο αντικείμενο Struct που γράφει και διαβάζει δυαδικά "
"δεδομένα σύμφωνα με τη συμβολοσειρά μορφοποίησης *format*. Η δημιουργία ενός "
"αντικειμένου ``Struct`` μια φορά και η κλήση των μεθόδων του είναι πιο "
"αποδοτική από την κλήση συναρτήσεων σε επίπεδο module με την ίδια μορφή, "
"καθώς η συμβολοσειρά μορφοποίησης μεταγλωττίζεται μόνο μία φορά."

#: library/struct.rst:586
msgid ""
"The compiled versions of the most recent format strings passed to the module-"
"level functions are cached, so programs that use only a few format strings "
"needn't worry about reusing a single :class:`Struct` instance."
msgstr ""
"Οι μεταγλωττισμένες εκδόσεις των πιο πρόσφατων συμβολοσειρών μορφοποίησης "
"που περνούν στις συναρτήσεις του module αποθηκεύονται προσωρινά, επομένως τα "
"προγράμματα που χρησιμοποιούν μόνο λίγες συμβολοσειρές μορφοποίησης δεν "
"χρειάζεται να ανησυχούν για την επαναχρησιμοποίηση μιας μεμονωμένης "
"περίπτωσης της κλάσης :class:`Struct`."

#: library/struct.rst:591
msgid "Compiled Struct objects support the following methods and attributes:"
msgstr ""
"Τα μεταγλωττισμένα αντικείμενα Struct υποστηρίζουν τις ακόλουθες μεθόδους "
"και ιδιότητες:"

#: library/struct.rst:595
msgid ""
"Identical to the :func:`pack` function, using the compiled format. "
"(``len(result)`` will equal :attr:`size`.)"
msgstr ""
"Ταυτόσημο με τη συνάρτηση :func:`pack`, χρησιμοποιώντας τη μεταγλωττισμένη "
"μορφή. (``len(result)`` θα είναι ίσο με :attr:`size`.)"

#: library/struct.rst:601
msgid "Identical to the :func:`pack_into` function, using the compiled format."
msgstr ""
"Ταυτόσημο με τη συνάρτηση :func:`pack_into`, χρησιμοποιώντας τη "
"μεταγλωττισμένη μορφή."

#: library/struct.rst:606
msgid ""
"Identical to the :func:`unpack` function, using the compiled format. The "
"buffer's size in bytes must equal :attr:`size`."
msgstr ""
"Ταυτόσημο με τη συνάρτηση :func:`unpack`, χρησιμοποιώντας τη μεταγλωττισμένη "
"μορφή. Το μέγεθος του buffer σε bytes πρέπει να είναι ίσο με :attr:`size`."

#: library/struct.rst:612
msgid ""
"Identical to the :func:`unpack_from` function, using the compiled format. "
"The buffer's size in bytes, starting at position *offset*, must be at least :"
"attr:`size`."
msgstr ""
"Ταυτόσημο με τη συνάρτηση :func:`unpack_from`, χρησιμοποιώντας τη "
"μεταγλωττισμένη μορφή. Το μέγεθος του buffer σε bytes, ξεκινώντας από τη "
"θέση *offset*, πρέπει να είναι τουλάχιστον :attr:`size`."

#: library/struct.rst:619
msgid ""
"Identical to the :func:`iter_unpack` function, using the compiled format. "
"The buffer's size in bytes must be a multiple of :attr:`size`."
msgstr ""
"Ταυτόσημο με τη συνάρτηση :func:`iter_unpack`, χρησιμοποιώντας τη "
"μεταγλωττισμένη μορφή. Το μέγεθος του buffer σε bytes πρέπει να είναι "
"πολλαπλάσιο του :attr:`size`."

#: library/struct.rst:626
msgid "The format string used to construct this Struct object."
msgstr ""
"Η συμβολοσειρά μορφής που χρησιμοποιήθηκε για τη δημιουργία αυτού του "
"αντικειμένου Struct."

#: library/struct.rst:628
msgid "The format string type is now :class:`str` instead of :class:`bytes`."
msgstr ""
"Ο τύπος της συμβολοσειράς μορφής είναι πλέον :class:`str` αντί για :class:"
"`bytes`."

#: library/struct.rst:633
msgid ""
"The calculated size of the struct (and hence of the bytes object produced by "
"the :meth:`pack` method) corresponding to :attr:`format`."
msgstr ""
"Το υπολογισμένο μέγεθος της δομής (και κατά συνέπεια του αντικειμένου bytes "
"που παράγεται από τη μέθοδο :meth:`pack`) που αντιστοιχεί στη :attr:`format`."

#: library/struct.rst:636
msgid "The *repr()* of structs has changed.  It is now:"
msgstr "Η *repr()* αναπαράσταση των δομών έχει αλλάξει.  Είναι πλέον:"

#: library/struct.rst:13
msgid "C"
msgstr "C"

#: library/struct.rst:13
msgid "structures"
msgstr "δομές"

#: library/struct.rst:13
msgid "packing"
msgstr "πακετάρισμα"

#: library/struct.rst:13
msgid "binary"
msgstr "δυαδικό"

#: library/struct.rst:13
msgid "data"
msgstr "δεδομένα"

#: library/struct.rst:136
msgid "@ (at)"
msgstr "@ (παπάκι)"

#: library/struct.rst:287 library/struct.rst:384
msgid "in struct format strings"
msgstr "στις συμβολοσειρές μορφοποίησης struct"

#: library/struct.rst:136
msgid "= (equals)"
msgstr "= (ίσο)"

#: library/struct.rst:136
msgid "< (less)"
msgstr "< (μικρότερο)"

#: library/struct.rst:136
msgid "> (greater)"
msgstr "> (μεγαλύτερο)"

#: library/struct.rst:136
msgid "! (exclamation)"
msgstr "! (θαυμαστικό)"

#: library/struct.rst:384
msgid "? (question mark)"
msgstr "? (ερωτηματικό)"
